{
    "core_tables": [
        "tmp_case_getDevStories",
        "tmp_task_getProjectTasks",
        "view_datasource_10",
        "view_datasource_11",
        "view_datasource_12",
        "view_datasource_4",
        "view_datasource_41",
        "view_datasource_5",
        "view_datasource_6",
        "zt_acl",
        "zt_action",
        "zt_actionrecent",
        "zt_activity",
        "zt_ai_miniprogram",
        "zt_ai_miniprogramfield",
        "zt_ai_prompt",
        "zt_ai_promptrole",
        "zt_approvalflow",
        "zt_approvalflowobject",
        "zt_approvalflowspec",
        "zt_block",
        "zt_bug",
        "zt_build",
        "zt_burn",
        "zt_case",
        "zt_casestep",
        "zt_chart",
        "zt_company",
        "zt_config",
        "zt_cron",
        "zt_dept",
        "zt_dimension",
        "zt_doclib",
        "zt_effort",
        "zt_group",
        "zt_grouppriv",
        "zt_history",
        "zt_kanbancell",
        "zt_kanbancolumn",
        "zt_kanbanlane",
        "zt_lang",
        "zt_metric",
        "zt_metriclib",
        "zt_module",
        "zt_pivot",
        "zt_pivotdrill",
        "zt_pivotspec",
        "zt_process",
        "zt_product",
        "zt_productplan",
        "zt_project",
        "zt_projectadmin",
        "zt_projectcase",
        "zt_projectproduct",
        "zt_projectstory",
        "zt_queue",
        "zt_screen",
        "zt_searchdict",
        "zt_searchindex",
        "zt_stage",
        "zt_story",
        "zt_storygrade",
        "zt_storyreview",
        "zt_storyspec",
        "zt_system",
        "zt_task",
        "zt_taskspec",
        "zt_team",
        "zt_testresult",
        "zt_testrun",
        "zt_testtask",
        "zt_user",
        "zt_usergroup",
        "zt_userview",
        "zt_weeklyreport",
        "zt_workflowdatasource",
        "zt_workflowgroup",
        "zt_workflowrule",
        "zt_zoutput",
        "ztv_dayactions",
        "ztv_daybugopen",
        "ztv_daybugresolve",
        "ztv_dayeffort",
        "ztv_daystoryopen",
        "ztv_daytaskfinish",
        "ztv_daytaskopen",
        "ztv_dayuserlogin",
        "ztv_executionsummary",
        "ztv_normalproduct",
        "ztv_productbugs",
        "ztv_productstories",
        "ztv_projectbugs",
        "ztv_projectstories",
        "ztv_projectsummary",
        "ztv_projectteams"
    ],
    "table_analysis": {
        "tmp_case_getDevStories": {
            "business_purpose": "This table appears to represent a summary or aggregation of cases associated with specific 'stories'. Each row links a unique story identifier to a count of related cases, likely for reporting, analytics, or temporary processing purposes. The 'tmp_' prefix suggests it is a temporary or intermediate table, possibly used in the context of generating reports or supporting batch operations.",
            "key_fields": [
                "story",
                "case_count"
            ],
            "potential_relationships": [
                "One-to-many: Each 'story' can be associated with multiple cases, as indicated by the 'case_count'. The 'story' field is likely a foreign key or reference to a unique story entity elsewhere, but this is not enforced in this table."
            ],
            "business_operations": [
                "Generating summary reports of case counts per story",
                "Supporting analytics or dashboard views that require aggregated case data by story",
                "Serving as an intermediate result set for further processing or data transformation tasks",
                "Facilitating batch updates or exports where case counts per story are needed"
            ]
        },
        "tmp_task_getProjectTasks": {
            "business_purpose": "This table appears to represent a temporary or intermediate storage of task-related data, specifically tracking the amount of effort or resources ('consumed') associated with a particular project ('project'). It is likely used to aggregate or report on resource consumption at the project level, possibly as part of a larger process for project management, time tracking, or resource allocation.",
            "key_fields": [
                "consumed",
                "project"
            ],
            "potential_relationships": [
                "Many-to-one: Multiple records in this table may reference the same project identifier, indicating aggregation or grouping by project.",
                "Lookup/aggregation: The 'project' field may be used to join or relate to more detailed project information elsewhere, or to summarize resource consumption per project."
            ],
            "business_operations": [
                "Generating reports on resource or time consumption per project.",
                "Aggregating task data for project-level analysis.",
                "Temporary staging of data for further processing, such as exporting, transforming, or loading into another system.",
                "Supporting dashboards or analytics that display project resource usage."
            ]
        },
        "view_datasource_10": {
            "business_purpose": "This table appears to represent a simple reference or lookup entity, likely used to store a list of named items or resources. The use of 'view_datasource_10' as the table name suggests it may be a view or a data source reference, possibly for reporting, configuration, or categorization purposes within a business process.",
            "key_fields": [
                "id",
                "name"
            ],
            "potential_relationships": [
                "Could serve as a lookup or reference table for other tables that need to associate records with a named entity via the 'id' field (one-to-many relationship)",
                "Might be used in join operations to provide descriptive names for codes or identifiers stored elsewhere"
            ],
            "business_operations": [
                "Retrieving the list of available named entities for selection or display",
                "Validating or constraining input data to ensure only valid 'id' values are used",
                "Reporting or analytics that require mapping between an identifier and its human-readable name",
                "Maintaining or updating the list of available entities (adding, editing, or removing entries)"
            ]
        },
        "view_datasource_11": {
            "business_purpose": "This table appears to represent a simple reference or lookup entity, likely used to store a list of named items or resources. The use of 'view_datasource_11' as the table name suggests it may be a view or a denormalized source for reporting, analytics, or selection lists within an application. Each record is uniquely identified by an 'id' and has an associated 'name', indicating it is used to map identifiers to human-readable names.",
            "key_fields": [
                "id",
                "name"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as the 'one' side in a one-to-many relationship, where other tables reference its 'id' to associate records with a specific named entity.",
                "Lookup/reference: It may be used as a lookup table for validation or display purposes in forms, reports, or data entry screens."
            ],
            "business_operations": [
                "Retrieving the list of available named entities for selection or display.",
                "Mapping internal identifiers to user-friendly names in reports or user interfaces.",
                "Validating input data against the list of valid 'id' values.",
                "Maintaining (adding, updating, or removing) the set of available named entities."
            ]
        },
        "view_datasource_12": {
            "business_purpose": "This table appears to represent a simple catalog or listing of entities, each identified by a unique numeric ID and a descriptive title. It could be used to store reference data, lookup values, or a list of items relevant to a specific business process, such as products, resources, or document types.",
            "key_fields": [
                "id",
                "title"
            ],
            "potential_relationships": [
                "One-to-many: Other tables may reference the 'id' field in this table to associate records with a specific entry in this catalog.",
                "Lookup/reference: This table may serve as a lookup for descriptive titles based on the 'id'."
            ],
            "business_operations": [
                "Listing all available entries for selection or display.",
                "Retrieving the title associated with a specific id.",
                "Adding new entries to the catalog.",
                "Updating the title of an existing entry.",
                "Deleting entries that are no longer relevant."
            ]
        },
        "view_datasource_4": {
            "business_purpose": "This table appears to represent a simple catalog or registry of entities, each identified by a unique numeric id and a descriptive title. It could be used to store reference data, lookup values, or a list of items relevant to a business process, such as data sources, document types, or named resources.",
            "key_fields": [
                "id",
                "title"
            ],
            "potential_relationships": [
                "One-to-many: Other tables might reference the id field as a foreign key to associate records with a specific entry in this table.",
                "Many-to-many: This table could participate in a join table to associate its entries with entries from another table."
            ],
            "business_operations": [
                "Listing all available entries for selection or reference",
                "Retrieving the title for a given id",
                "Adding new entries to the catalog",
                "Updating the title of an existing entry",
                "Deleting entries (if allowed by business rules)"
            ]
        },
        "view_datasource_41": {
            "business_purpose": "This table appears to represent a simple catalog or listing of entities, each identified by a unique numeric ID and a descriptive title. It could serve as a lookup or reference table for named items, resources, or records within a business process, where each entry is uniquely identified and described by its title.",
            "key_fields": [
                "id",
                "title"
            ],
            "potential_relationships": [
                "One-to-many: Other tables may reference the 'id' field as a foreign key to associate records with a specific entry in this table.",
                "Many-to-many: This table could participate in a join table to associate its entries with entries from another table.",
                "Lookup/reference: This table may be used as a source for dropdowns, selections, or mappings in other business processes."
            ],
            "business_operations": [
                "Adding new entries to the catalog/list",
                "Retrieving the title for a given id",
                "Listing all available entries for selection or reporting",
                "Updating the title of an existing entry",
                "Deleting entries if they are no longer needed"
            ]
        },
        "view_datasource_5": {
            "business_purpose": "This table appears to represent a simple reference or lookup entity, where each record has a unique identifier and a corresponding name. It could be used to store a list of distinct items, types, or categories relevant to a business process, such as data sources, statuses, or other enumerated values.",
            "key_fields": [
                "id",
                "name"
            ],
            "potential_relationships": [
                "One-to-many: Other tables may reference the 'id' field as a foreign key to associate records with a specific entry in this table.",
                "Many-to-one: Multiple records in other tables could point to a single record in this table."
            ],
            "business_operations": [
                "Listing all available entries for selection or display.",
                "Inserting new entries to expand the list of available options.",
                "Updating the 'name' of an entry for correction or rebranding.",
                "Referencing the 'id' in other business processes to categorize or identify records."
            ]
        },
        "view_datasource_6": {
            "business_purpose": "This table appears to represent a simple catalog or listing of entities, each identified by a unique numeric id and a descriptive title. It could be used to store reference data, lookup values, or a list of items relevant to a specific business process, such as products, resources, or document types.",
            "key_fields": [
                "id",
                "title"
            ],
            "potential_relationships": [
                "One-to-many: Other tables might reference the id field as a foreign key to associate records with a specific entry in this table.",
                "Lookup/reference: This table could serve as a lookup for descriptive titles based on the id."
            ],
            "business_operations": [
                "Inserting new entries to expand the catalog or list.",
                "Updating titles to correct or clarify descriptions.",
                "Querying the table to retrieve the title associated with a given id.",
                "Listing all entries for selection or reporting purposes."
            ]
        },
        "zt_acl": {
            "business_purpose": "The zt_acl table represents an access control list (ACL) mechanism, used to define and manage permissions for specific accounts over various objects within a system. Each record specifies which account has what type of access (e.g., whitelist) to a particular object, identified by its type and ID, and possibly the source or context of the permission.",
            "key_fields": [
                "id",
                "account",
                "objectType",
                "objectID",
                "type",
                "source"
            ],
            "potential_relationships": [
                "Many-to-one: Multiple ACL entries may reference the same objectType/objectID combination, indicating multiple accounts with permissions on the same object.",
                "One-to-many: A single account may have multiple ACL entries for different objects or types.",
                "Categorization: The 'type' and 'source' fields may be used to group or filter ACL entries by permission type or origin."
            ],
            "business_operations": [
                "Granting or revoking access permissions for accounts to specific objects.",
                "Querying which accounts have access to a given object or set of objects.",
                "Auditing or reporting on access control assignments.",
                "Filtering or enforcing access to resources based on ACL entries during business process execution."
            ]
        },
        "zt_action": {
            "business_purpose": "The zt_action table is designed to record and track actions or events performed on various business objects within a system. Each record logs a specific action taken by an actor (user or system) on a particular object (such as a product, project, or execution), along with contextual details like date, comments, files, and status flags. This table serves as an audit trail or activity log, supporting traceability, accountability, and historical analysis of changes or activities within the business process.",
            "key_fields": [
                "id",
                "objectType",
                "objectID",
                "product",
                "project",
                "execution",
                "actor",
                "action",
                "date",
                "read",
                "vision",
                "efforted"
            ],
            "potential_relationships": [
                "Many-to-one relationship with business objects identified by objectType and objectID (e.g., each action is linked to a specific object)",
                "Many-to-one relationship with projects (via project field)",
                "Many-to-one relationship with executions (via execution field)",
                "Many-to-one relationship with actors (via actor field, which could represent a user or system entity)",
                "Possible one-to-many relationship from a business object to its actions (i.e., each object can have multiple actions logged)"
            ],
            "business_operations": [
                "Logging actions or events performed on business objects",
                "Auditing and tracking changes or activities for compliance and accountability",
                "Displaying activity history or timelines for objects (e.g., project history, product updates)",
                "Filtering or searching actions by actor, date, type, or status",
                "Marking actions as read/unread for notification or workflow purposes",
                "Attaching comments or files to specific actions for documentation",
                "Analyzing user or system activity for reporting or process improvement"
            ]
        },
        "zt_actionrecent": {
            "business_purpose": "The zt_actionrecent table is designed to log and track recent actions or activities performed on various business objects within a system. Each record represents a discrete action taken by an actor (user or system process) on a specific object (such as a product, project, or execution), capturing details like the type of action, associated comments, files, and metadata such as whether the action has been read or efforted. This table serves as an audit trail or activity feed for monitoring and reviewing recent changes or events within the system.",
            "key_fields": [
                "id",
                "objectType",
                "objectID",
                "product",
                "project",
                "execution",
                "actor",
                "action",
                "date",
                "read"
            ],
            "potential_relationships": [
                "Links to various business objects via objectType and objectID (polymorphic association)",
                "Associations with products, projects, and executions through their respective fields",
                "Connections to actors (users or processes) via the actor field",
                "Possible grouping or filtering by action type, date, or read status"
            ],
            "business_operations": [
                "Recording and displaying recent activity feeds or audit logs",
                "Tracking user or system actions for compliance and accountability",
                "Filtering or searching actions by object, actor, action type, or date",
                "Marking actions as read/unread for notification or review purposes",
                "Attaching comments or files to specific actions for documentation",
                "Analyzing activity patterns for reporting or process improvement"
            ]
        },
        "zt_activity": {
            "business_purpose": "The zt_activity table represents individual activities or tasks that are part of a larger process. Each activity has attributes such as name, content, assignment, status, and audit information, indicating it is used to track, manage, and document discrete steps or actions within a business workflow or process management system.",
            "key_fields": [
                "id",
                "process",
                "name",
                "assignedTo",
                "status",
                "createdBy",
                "createdDate",
                "editedBy",
                "editedDate",
                "assignedBy",
                "assignedDate",
                "order",
                "deleted"
            ],
            "potential_relationships": [
                "Belongs to a process (via the 'process' field, likely referencing a process entity)",
                "May be ordered or sequenced within a process (via the 'order' field)",
                "May be filtered or grouped by assignment or status",
                "May be soft-deleted (via the 'deleted' field) and thus related to audit or archival operations"
            ],
            "business_operations": [
                "Creating new activities as part of a process",
                "Assigning activities to responsible parties",
                "Tracking the status and progress of activities",
                "Editing or updating activity details",
                "Auditing changes and assignments to activities",
                "Soft-deleting (marking as deleted) activities",
                "Sequencing or reordering activities within a process"
            ]
        },
        "zt_ai_miniprogram": {
            "business_purpose": "This table represents a registry or catalog of AI-powered mini-programs or applications. Each record describes a distinct AI mini-program, including its metadata, categorization, status, and configuration details such as prompts and associated models. The table is designed to manage the lifecycle (creation, editing, publishing, deletion) and properties of these AI mini-programs within a system.",
            "key_fields": [
                "id",
                "name",
                "category",
                "model",
                "createdBy",
                "createdDate",
                "editedBy",
                "editedDate",
                "published",
                "publishedDate",
                "deleted",
                "prompt",
                "builtIn"
            ],
            "potential_relationships": [
                "Could be referenced by logs or usage tracking tables to record interactions with specific mini-programs",
                "Might be linked to configuration or deployment tables that manage how and where each mini-program is available",
                "Could be associated with versioning or audit tables to track changes over time"
            ],
            "business_operations": [
                "Registering new AI mini-programs",
                "Editing or updating existing mini-programs",
                "Publishing or unpublishing mini-programs for end-user access",
                "Soft-deleting mini-programs (marking as deleted without removing from database)",
                "Displaying lists or catalogs of available mini-programs",
                "Filtering mini-programs by category, status, or built-in flag",
                "Auditing creation and modification history for compliance or review",
                "Managing prompts and model associations for each mini-program"
            ]
        },
        "zt_ai_miniprogramfield": {
            "business_purpose": "This table defines the structure and configuration of input fields for a mini-program or application form. Each record represents a single field (such as a text box, radio button, or checkbox) that can be dynamically rendered in a mini-program interface. The table allows for customization of field types, labels, placeholders, options, and whether the field is required, supporting the dynamic generation of forms or data collection interfaces within a mini-program context.",
            "key_fields": [
                "id",
                "appID",
                "name",
                "type",
                "placeholder",
                "options",
                "required"
            ],
            "potential_relationships": [
                "Many-to-one: Multiple field definitions (rows) can be associated with a single mini-program or application, as indicated by the appID field.",
                "One-to-many: Each field (by id) could be referenced by other tables that store user input or responses, though such tables are not present in the schema."
            ],
            "business_operations": [
                "Defining and configuring the fields for a mini-program's input form.",
                "Retrieving field definitions to dynamically render forms in a mini-program interface.",
                "Updating field properties (such as type, placeholder, or required status) to modify the form structure.",
                "Deleting or deactivating fields from a mini-program's form configuration."
            ]
        },
        "zt_ai_prompt": {
            "business_purpose": "The zt_ai_prompt table represents a repository of AI prompts, likely used to store, manage, and track prompts for AI models within a business application. Each record defines a prompt with its metadata, intended use, associated model, module, and lifecycle status. This enables structured management of AI prompt assets for various business or application modules.",
            "key_fields": [
                "id",
                "name",
                "desc",
                "model",
                "module",
                "status",
                "createdBy",
                "createdDate",
                "deleted"
            ],
            "potential_relationships": [
                "May reference or be referenced by tables representing AI models (via 'model')",
                "May be linked to modules or forms in the application (via 'module', 'targetForm')",
                "May be associated with user or audit entities (via 'createdBy', 'editedBy')",
                "Could be related to workflow or versioning tables for prompt management"
            ],
            "business_operations": [
                "Creating and storing new AI prompts",
                "Editing and updating existing prompts",
                "Activating or deactivating prompts (status management)",
                "Soft-deleting prompts (logical deletion via 'deleted' flag)",
                "Auditing prompt creation and modification (tracking 'createdBy', 'createdDate', 'editedBy', 'editedDate')",
                "Filtering or retrieving prompts by module, model, status, or other metadata",
                "Documenting and elaborating on prompt purpose, role, and characterization for business or technical review"
            ]
        },
        "zt_ai_promptrole": {
            "business_purpose": "The zt_ai_promptrole table represents a catalog of AI prompt roles, likely used to define different personas, instructions, or contexts for AI models. Each record describes a specific role or characterization that can be used to guide AI behavior, possibly in a prompt engineering or conversational AI system.",
            "key_fields": [
                "id",
                "name",
                "desc",
                "model",
                "role",
                "characterization",
                "deleted"
            ],
            "potential_relationships": [
                "May be referenced by other tables that assign or use AI prompt roles",
                "The 'model' field suggests a possible link to an AI model entity, indicating which model the prompt role is associated with",
                "Could serve as a lookup or reference table for prompt configurations"
            ],
            "business_operations": [
                "Creating, updating, or deleting AI prompt roles",
                "Retrieving available prompt roles for selection or assignment",
                "Filtering prompt roles by model or status (active/deleted)",
                "Describing or displaying the characteristics and instructions of a prompt role for AI interactions"
            ]
        },
        "zt_approvalflow": {
            "business_purpose": "The zt_approvalflow table represents the definition and management of approval workflows within a business process. Each record defines a unique approval flow, including its name, code, description, version, creator, creation date, associated workflow, and deletion status. This table is likely used to configure, track, and manage different approval processes that can be applied to various business activities or documents.",
            "key_fields": [
                "id",
                "name",
                "code",
                "version",
                "createdBy",
                "createdDate",
                "workflow",
                "deleted"
            ],
            "potential_relationships": [
                "One-to-many: This table could be referenced by other tables that need to associate records with a specific approval flow (e.g., business documents, requests, or transactions that require approval).",
                "Versioning: The version field suggests that multiple versions of an approval flow may exist, potentially related by code or name.",
                "Workflow linkage: The workflow field may link to a workflow definition or type, indicating a relationship to a broader workflow management structure."
            ],
            "business_operations": [
                "Defining new approval flows for business processes",
                "Updating or versioning existing approval flows",
                "Retrieving approval flow definitions for use in process automation or user interfaces",
                "Soft-deleting approval flows (using the deleted flag)",
                "Auditing or reporting on approval flow creation and changes"
            ]
        },
        "zt_approvalflowobject": {
            "business_purpose": "This table represents the association between approval flows and specific business objects within a system that manages approval processes. Each record links a particular approval flow (identified by 'flow') to a business object (identified by 'objectType' and 'objectID'), possibly within a certain context or hierarchy (indicated by 'root'). The 'extra' field allows for additional metadata or parameters related to the approval flow-object association.",
            "key_fields": [
                "id",
                "root",
                "flow",
                "objectType",
                "objectID",
                "extra"
            ],
            "potential_relationships": [
                "Many-to-one: Multiple records may reference the same 'flow', indicating that a single approval flow can be associated with multiple objects.",
                "Many-to-one: Multiple records may share the same 'root', suggesting a hierarchical or grouped context for approval flows.",
                "Polymorphic association: The combination of 'objectType' and 'objectID' allows this table to reference different types of business objects, supporting a flexible, polymorphic relationship."
            ],
            "business_operations": [
                "Linking approval flows to specific business objects for tracking and management.",
                "Querying which objects are currently under a particular approval flow.",
                "Auditing or reporting on approval processes for various object types.",
                "Storing and retrieving additional metadata about the approval-object association via the 'extra' field.",
                "Managing the lifecycle of approval flows as they relate to business objects (e.g., initiating, updating, or terminating approval processes)."
            ]
        },
        "zt_approvalflowspec": {
            "business_purpose": "This table represents the specification or definition of an approval flow process, likely used to manage and version approval workflows within a business application. Each record defines a particular version of an approval flow, including its structure (nodes), creator, and creation date.",
            "key_fields": [
                "id",
                "flow",
                "version",
                "nodes",
                "createdBy",
                "createdDate"
            ],
            "potential_relationships": [
                "One-to-many: Multiple approval flow specifications (versions) may be associated with a single approval flow (via the 'flow' field).",
                "Versioning: The 'version' field allows tracking of different iterations of the same approval flow.",
                "Possible linkage to process execution or audit tables that reference a specific approval flow specification."
            ],
            "business_operations": [
                "Defining and saving new approval flow structures.",
                "Versioning approval flows to allow updates and historical tracking.",
                "Retrieving the structure of an approval flow for execution or display.",
                "Auditing or tracking who created or modified approval flows and when."
            ]
        },
        "zt_block": {
            "business_purpose": "The zt_block table represents configurable dashboard blocks or widgets for individual user accounts. Each record defines a block's properties, such as its position, size, module association, and display parameters, allowing users to customize their dashboard or workspace layout within an application.",
            "key_fields": [
                "id",
                "account",
                "dashboard",
                "module",
                "title",
                "block",
                "code",
                "width",
                "height",
                "left",
                "top",
                "params",
                "hidden",
                "vision"
            ],
            "potential_relationships": [
                "One-to-many: Each account can have multiple blocks configured.",
                "One-to-many: Each dashboard can contain multiple blocks.",
                "One-to-many: Each module can have multiple blocks associated with it.",
                "Blocks may be grouped or filtered by vision (e.g., different product lines or application areas)."
            ],
            "business_operations": [
                "Creating and saving new dashboard blocks for user customization.",
                "Retrieving and rendering dashboard layouts for users based on their account and dashboard.",
                "Updating block properties such as position, size, visibility, and parameters.",
                "Hiding or showing blocks on a user's dashboard.",
                "Deleting blocks from a user's dashboard.",
                "Filtering or displaying blocks based on module or vision context."
            ]
        },
        "zt_bug": {
            "business_purpose": "The zt_bug table represents the tracking and management of software bugs or defects within a project or product lifecycle. It is designed to capture detailed information about each bug, including its context, status, severity, assignment, and resolution history. The table supports comprehensive bug lifecycle management, including reporting, assignment, resolution, and closure, as well as integration with related entities such as projects, products, modules, test cases, and version control repositories.",
            "key_fields": [
                "id",
                "project",
                "product",
                "execution",
                "plan",
                "story",
                "title",
                "severity",
                "pri",
                "type",
                "status",
                "assignedTo",
                "openedBy",
                "openedDate",
                "resolvedBy",
                "resolvedDate",
                "closedBy",
                "closedDate",
                "steps",
                "resolution",
                "duplicateBug",
                "relatedBug",
                "case",
                "repo",
                "deleted"
            ],
            "potential_relationships": [
                "Many-to-one: Each bug is associated with a single project, product, execution, plan, story, module, branch, and possibly a test case or repository (via their respective ID fields).",
                "Self-referencing: Bugs can reference other bugs as duplicates or related issues (duplicateBug, relatedBug).",
                "One-to-many: A single project, product, or module can have multiple bugs associated with it.",
                "Versioning: Bugs can be linked to specific versions of stories, cases, or builds (storyVersion, caseVersion, openedBuild, resolvedBuild).",
                "Assignment: Bugs are assigned to individuals (assignedTo, openedBy, resolvedBy, closedBy, lastEditedBy) for workflow management, though these are not foreign keys."
            ],
            "business_operations": [
                "Bug reporting: Creating new bug records with detailed information.",
                "Bug triage: Reviewing, prioritizing, and assigning bugs to team members.",
                "Bug tracking: Monitoring the status, severity, and progress of bugs through their lifecycle.",
                "Bug resolution: Updating bugs with resolution details, marking as resolved or closed.",
                "Bug analysis: Querying and analyzing bug data for quality assurance, reporting, and process improvement.",
                "Audit and history: Tracking changes, assignments, and edits to bug records.",
                "Integration: Linking bugs to test cases, plans, executions, repositories, and other development artifacts."
            ]
        },
        "zt_build": {
            "business_purpose": "The zt_build table represents a record of software build instances within a project management or software development lifecycle system. Each row captures details about a specific build, including its association with a project, product, branch, execution context, and related artifacts such as stories and bugs. The table is designed to track the creation, metadata, and status of builds, likely for release management, quality assurance, and traceability purposes.",
            "key_fields": [
                "id",
                "project",
                "product",
                "branch",
                "execution",
                "name",
                "system",
                "scmPath",
                "filePath",
                "date",
                "stories",
                "bugs",
                "artifactRepoID",
                "builder",
                "createdBy",
                "createdDate",
                "deleted"
            ],
            "potential_relationships": [
                "Many-to-one: Each build is associated with a single project (project), product (product), execution context (execution), and system (system), suggesting that builds are grouped under these entities.",
                "One-to-many: A single build may reference multiple stories and bugs (via the stories and bugs fields, likely storing lists or references).",
                "One-to-one or many-to-one: Each build may be linked to a specific artifact repository (artifactRepoID)."
            ],
            "business_operations": [
                "Recording and tracking new software builds as part of the development and release process.",
                "Associating builds with specific projects, products, branches, and execution contexts for traceability.",
                "Linking builds to related stories and bugs for quality assurance and release notes.",
                "Storing metadata about the build process, such as builder, creation date, and file locations.",
                "Managing build lifecycle, including marking builds as deleted (soft delete) and maintaining historical build records.",
                "Retrieving build information for reporting, auditing, or deployment purposes."
            ]
        },
        "zt_burn": {
            "business_purpose": "The zt_burn table represents the tracking of work progress and effort (such as time or story points) for specific tasks within an execution (possibly a sprint, iteration, or project phase) and product, on a daily basis. It is designed to record and monitor the estimated, remaining, and consumed effort for each task on each date, supporting burn-down or burn-up reporting for project management and agile tracking.",
            "key_fields": [
                "execution",
                "task",
                "date",
                "estimate",
                "left",
                "consumed",
                "storyPoint"
            ],
            "potential_relationships": [
                "Many-to-one relationship to an 'execution' entity (each record belongs to a specific execution)",
                "Many-to-one relationship to a 'product' entity (each record is associated with a product)",
                "Many-to-one relationship to a 'task' entity (each record tracks a specific task)",
                "Composite primary key (execution, task, date) suggests uniqueness per task per execution per day"
            ],
            "business_operations": [
                "Recording daily progress updates for tasks",
                "Calculating and displaying burn-down or burn-up charts for project tracking",
                "Monitoring remaining effort and consumed effort for project management",
                "Analyzing task performance and forecasting completion based on historical data",
                "Supporting reporting on story points and effort estimation accuracy"
            ]
        },
        "zt_case": {
            "business_purpose": "The zt_case table represents test cases within a software development or quality assurance process. Each record details a specific test case, including its association with projects, products, modules, requirements (stories), and potentially bugs. The table tracks the creation, review, execution, and status of test cases, supporting both manual and automated testing workflows.",
            "key_fields": [
                "id",
                "project",
                "product",
                "execution",
                "module",
                "story",
                "title",
                "precondition",
                "pri",
                "type",
                "auto",
                "status",
                "version",
                "openedBy",
                "openedDate",
                "lastRunner",
                "lastRunDate",
                "lastRunResult",
                "fromBug",
                "deleted"
            ],
            "potential_relationships": [
                "Many-to-one: Each test case may be linked to a single project, product, execution, module, story, or bug (via their respective IDs).",
                "Self-referencing: Test cases can reference other cases (fromCaseID, linkCase), supporting versioning or case derivation.",
                "One-to-many: A single test case may have multiple executions or runs, as tracked by lastRunner, lastRunDate, and lastRunResult fields.",
                "Many-to-one: Test cases may be grouped by branch, lib, or scene, indicating organizational or functional grouping."
            ],
            "business_operations": [
                "Creating and maintaining test cases for software features or requirements.",
                "Associating test cases with specific projects, products, modules, or requirements (stories).",
                "Tracking the review, approval, and versioning of test cases.",
                "Executing test cases and recording results, including automation details.",
                "Linking test cases to bugs for regression or verification purposes.",
                "Managing the lifecycle and status of test cases, including deletion and updates."
            ]
        },
        "zt_casestep": {
            "business_purpose": "The zt_casestep table represents the individual steps within a test case, likely used in a software testing or quality assurance process. Each record details a specific action or verification step, its expected outcome, and its relationship to a parent step or test case, supporting the definition and execution of structured test scenarios.",
            "key_fields": [
                "id",
                "parent",
                "case",
                "version",
                "type",
                "desc",
                "expect"
            ],
            "potential_relationships": [
                "Hierarchical relationship within the table itself via the 'parent' field, allowing steps to be nested or grouped (e.g., sub-steps).",
                "Association with a broader 'case' entity via the 'case' field, indicating that each step belongs to a specific test case.",
                "Versioning relationship via the 'version' field, supporting multiple versions of steps for the same case."
            ],
            "business_operations": [
                "Defining and editing the steps of a test case, including their descriptions and expected results.",
                "Organizing steps hierarchically (e.g., grouping steps under a parent step).",
                "Tracking and managing different versions of test case steps.",
                "Retrieving and displaying the steps for a given test case and version during test execution or review.",
                "Auditing or reviewing the evolution of test case steps over time."
            ]
        },
        "zt_chart": {
            "business_purpose": "The zt_chart table represents a configurable chart or data visualization definition within a business intelligence, analytics, or reporting system. Each record defines a chart, including its metadata, data source, configuration, access control, and versioning information. This enables users to create, manage, and display custom charts based on underlying datasets or queries.",
            "key_fields": [
                "id",
                "name",
                "code",
                "driver",
                "mode",
                "dimension",
                "type",
                "group",
                "dataset",
                "acl",
                "settings",
                "filters",
                "fields",
                "sql",
                "stage",
                "createdBy",
                "createdDate",
                "editedBy",
                "editedDate",
                "deleted"
            ],
            "potential_relationships": [
                "One-to-many: A single chart may reference multiple datasets, fields, or filters (as stored in text/mediumtext fields).",
                "Many-to-one: Multiple charts may be grouped together by the 'group' field.",
                "Versioning: Multiple versions of a chart may exist, distinguished by the 'version' and 'stage' fields.",
                "Ownership: Charts are associated with creators and editors via 'createdBy' and 'editedBy' fields (as plain values, not foreign keys)."
            ],
            "business_operations": [
                "Creating new chart definitions for reporting or dashboards.",
                "Editing and updating existing charts, including their configuration and data sources.",
                "Publishing or drafting charts for review and release control.",
                "Controlling access to charts via ACL and whitelist fields.",
                "Filtering, grouping, and organizing charts for display or management.",
                "Soft-deleting charts (marking as deleted without removing from the database).",
                "Versioning and tracking changes to chart definitions."
            ]
        },
        "zt_company": {
            "business_purpose": "The zt_company table represents a business entity for storing information about companies or organizations. It is designed to capture core company details such as contact information, address, website, and administrative settings. The table also includes fields for managing access (guest, admins) and soft deletion (deleted), indicating its use in a system where company records may be managed, updated, or restricted.",
            "key_fields": [
                "id",
                "name",
                "phone",
                "address",
                "website",
                "guest",
                "admins",
                "deleted"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as a parent entity for other records (e.g., a company may have multiple related records in other tables such as projects, assets, or transactions).",
                "Many-to-many: The 'admins' field suggests a possible relationship to a set of administrative users or roles, potentially linking companies to multiple administrators.",
                "Soft deletion: The 'deleted' field indicates that records may be flagged as deleted rather than physically removed, which could affect how related data is queried or displayed."
            ],
            "business_operations": [
                "Creating and registering new company records",
                "Updating company contact and administrative information",
                "Managing company access permissions (e.g., guest access, admin assignments)",
                "Soft-deleting (archiving) and restoring company records",
                "Searching and displaying company information for business processes such as reporting, communication, or system configuration"
            ]
        },
        "zt_config": {
            "business_purpose": "The zt_config table represents a flexible configuration or settings storage system for an application. It is designed to store various configuration values that can be scoped by vision, owner, module, section, and key, allowing for granular and hierarchical configuration management across different parts of the application or system.",
            "key_fields": [
                "id",
                "vision",
                "owner",
                "module",
                "section",
                "key",
                "value"
            ],
            "potential_relationships": [
                "This table may serve as a child or detail table to higher-level entities (such as different application modules or owners), storing configuration data specific to those entities.",
                "It may be referenced by application logic to retrieve or update configuration values based on the combination of vision, owner, module, section, and key.",
                "It could be used in a one-to-many relationship where each owner, module, or vision has multiple configuration entries."
            ],
            "business_operations": [
                "Reading configuration values for application modules or features at runtime.",
                "Updating or overriding configuration settings for specific owners, modules, or visions.",
                "Inserting new configuration entries when new features or modules are added.",
                "Deleting obsolete or deprecated configuration settings.",
                "Querying for all configuration settings related to a particular module, owner, or vision for auditing or management purposes."
            ]
        },
        "zt_cron": {
            "business_purpose": "This table represents a scheduler for automated tasks (cron jobs) within an application. Each record defines a scheduled command, its timing (using cron-like fields), status, and metadata. It is used to manage, track, and execute recurring or scheduled operations within the system.",
            "key_fields": [
                "id",
                "m",
                "h",
                "dom",
                "mon",
                "dow",
                "command",
                "type",
                "status",
                "lastTime",
                "buildin"
            ],
            "potential_relationships": [
                "Could serve as a parent or reference for logs or execution history tables (e.g., a log of each time a cron job runs)",
                "Might be referenced by tables that define task results or outputs",
                "Could be linked to configuration or notification tables for alerting on job status"
            ],
            "business_operations": [
                "Defining and scheduling automated tasks or scripts",
                "Enabling, disabling, or modifying scheduled jobs",
                "Tracking the last execution time and status of scheduled jobs",
                "Distinguishing between built-in and user-defined scheduled tasks",
                "Storing and updating remarks or descriptions for each scheduled job"
            ]
        },
        "zt_dept": {
            "business_purpose": "The zt_dept table represents an organizational department hierarchy. It is designed to store information about each department within an organization, including its name, hierarchical structure (parent/child relationships), order, grade (level), position, function, and manager. This structure supports the modeling of complex, multi-level department trees for business or administrative purposes.",
            "key_fields": [
                "id",
                "name",
                "parent",
                "path",
                "grade",
                "order",
                "position",
                "function",
                "manager"
            ],
            "potential_relationships": [
                "Self-referential (hierarchical) relationship via the 'parent' field, where each department can have a parent department (except the root).",
                "Hierarchical path tracking via the 'path' field, which likely encodes the lineage or ancestry of the department within the hierarchy."
            ],
            "business_operations": [
                "Creating, updating, or deleting departments within the organizational structure.",
                "Querying the department hierarchy to display organizational charts or department trees.",
                "Assigning or updating department managers and their roles.",
                "Ordering or sorting departments for reporting or display purposes.",
                "Analyzing departmental functions and positions for HR or administrative planning.",
                "Navigating or traversing the department hierarchy for workflow, permissions, or reporting."
            ]
        },
        "zt_dimension": {
            "business_purpose": "The zt_dimension table represents a configurable or definable 'dimension' entity within a business application. A 'dimension' in this context is likely a categorization, attribute, or analytical axis that can be defined, described, and managed by users. It supports access control, descriptive metadata, and audit tracking, suggesting its use in scenarios where business data needs to be organized, filtered, or analyzed along custom axes.",
            "key_fields": [
                "id",
                "name",
                "code",
                "acl",
                "whitelist",
                "createdBy",
                "createdDate",
                "editedBy",
                "editedDate",
                "deleted"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as a parent to other tables that reference a dimension (e.g., facts, records, or items categorized by dimension).",
                "Many-to-many: Dimensions could be associated with multiple entities or records in other tables, possibly via a junction table.",
                "Self-referencing: If dimensions can be hierarchical, a self-referencing relationship could exist (though not present in this schema)."
            ],
            "business_operations": [
                "Defining and managing dimensions (create, update, delete, soft-delete).",
                "Controlling access to dimensions via ACL and whitelist.",
                "Auditing changes to dimensions (tracking who created/edited and when).",
                "Retrieving dimension metadata for use in reporting, filtering, or categorization.",
                "Filtering or restricting data access based on dimension ACL settings."
            ]
        },
        "zt_doclib": {
            "business_purpose": "The zt_doclib table represents a document library or repository structure, likely used to organize, categorize, and control access to collections of documents or knowledge resources within a business context. It supports hierarchical organization, access control, and association with business entities such as products, projects, or executions.",
            "key_fields": [
                "id",
                "type",
                "vision",
                "parent",
                "product",
                "project",
                "execution",
                "name",
                "acl",
                "groups",
                "users",
                "main",
                "order",
                "addedBy",
                "addedDate",
                "deleted",
                "archived"
            ],
            "potential_relationships": [
                "Hierarchical self-relation via the 'parent' field, allowing document libraries to be nested within each other",
                "Associative relationships to business entities such as products, projects, or executions via the 'product', 'project', and 'execution' fields",
                "Access control relationships through 'groups' and 'users' fields, defining which users or groups can access each library"
            ],
            "business_operations": [
                "Creating, updating, and deleting document libraries",
                "Organizing document libraries in a hierarchical structure",
                "Associating document libraries with specific products, projects, or executions",
                "Managing access permissions for users and groups",
                "Archiving or soft-deleting document libraries",
                "Searching, sorting, and displaying document libraries based on various criteria"
            ]
        },
        "zt_effort": {
            "business_purpose": "The zt_effort table is designed to record and track individual work efforts or time logs associated with various business objects (such as tasks, bugs, or requirements) within projects and executions. It captures details about the work performed, the user who performed it, the time spent, and the context (project, execution, product) in which the effort occurred. This table is likely used for time tracking, progress monitoring, and resource management within a project or product development environment.",
            "key_fields": [
                "id",
                "objectType",
                "objectID",
                "project",
                "execution",
                "account",
                "date",
                "consumed",
                "left",
                "begin",
                "end",
                "deleted"
            ],
            "potential_relationships": [
                "Many-to-one relationship to a business object (objectType/objectID) such as a task, bug, or requirement",
                "Many-to-one relationship to a project (project)",
                "Many-to-one relationship to an execution (execution)",
                "Many-to-one relationship to a user or account (account)",
                "Potential grouping or filtering by date for reporting or analytics"
            ],
            "business_operations": [
                "Logging work or time spent on specific business objects",
                "Tracking progress and remaining effort for tasks or activities",
                "Generating timesheets or effort reports for users, projects, or executions",
                "Auditing and reviewing work history for project management",
                "Calculating resource utilization and forecasting project timelines",
                "Marking effort records as deleted for soft-deletion or audit purposes"
            ]
        },
        "zt_group": {
            "business_purpose": "The zt_group table represents a grouping or team entity within a project context, likely used to define roles, permissions, and access control for different groups associated with specific projects and visions. It is designed to manage group-level metadata, including their name, role, description, access control settings, and whether the group is considered a developer group.",
            "key_fields": [
                "id",
                "project",
                "vision",
                "name",
                "role",
                "desc",
                "acl",
                "developer"
            ],
            "potential_relationships": [
                "Each group is associated with a specific project (project field), suggesting a one-to-many relationship from projects to groups.",
                "Groups may be categorized or filtered by vision (vision field), indicating a possible grouping or segmentation within the business process.",
                "The acl (access control list) field suggests that groups may have permissions or access rights that could relate to other entities or resources, though these are not explicitly defined in this schema."
            ],
            "business_operations": [
                "Creating, updating, or deleting group definitions for projects.",
                "Assigning or modifying group roles and descriptions for organizational clarity.",
                "Configuring access control settings (acl) for groups to manage permissions.",
                "Identifying developer groups for specialized access or workflow handling.",
                "Filtering or reporting on groups by project or vision for management or auditing purposes."
            ]
        },
        "zt_grouppriv": {
            "business_purpose": "This table represents the assignment of access privileges to groups for specific actions within modules of a system. Each record defines that a particular group has permission to execute a certain method (action) within a given module (functional area). It is used to control and manage group-based access rights at a granular level.",
            "key_fields": [
                "group",
                "module",
                "method"
            ],
            "potential_relationships": [
                "Many-to-many relationship between groups and module-method pairs: Each group can have privileges on multiple module-method combinations, and each module-method can be accessible to multiple groups.",
                "Acts as a mapping or junction table for group-based permissions to system functionalities."
            ],
            "business_operations": [
                "Checking if a group has permission to perform a specific action in a module.",
                "Granting or revoking access rights for groups to certain module-method combinations.",
                "Auditing or reporting on group access privileges.",
                "Enforcing access control during system operations based on group privileges."
            ]
        },
        "zt_history": {
            "business_purpose": "The zt_history table is designed to record and track changes made to data fields within a system. Each record represents a single change event, capturing the field that was changed, its previous and new values, and a reference to the action that triggered the change. This table serves as an audit log or change history for tracking modifications over time.",
            "key_fields": [
                "id",
                "action",
                "field",
                "old",
                "oldValue",
                "new",
                "newValue",
                "diff"
            ],
            "potential_relationships": [
                "Many-to-one relationship with an 'action' entity, where each history record is linked to a specific action (as indicated by the 'action' field, which is indexed).",
                "One-to-many relationship from the entity being tracked to this history table, where each entity change can generate multiple history records (one per field change)."
            ],
            "business_operations": [
                "Auditing changes to data for compliance or troubleshooting.",
                "Displaying change history to end users or administrators.",
                "Restoring previous values or understanding the evolution of a record.",
                "Generating reports on data modifications over time."
            ]
        },
        "zt_kanbancell": {
            "business_purpose": "The zt_kanbancell table represents individual cells within a Kanban board system. Each record defines a specific cell, identified by its position (kanban, lane, column), its type, and the cards (work items or tasks) it contains. This structure is used to organize and track the flow of work items through different stages and lanes in a visual project management or workflow tool.",
            "key_fields": [
                "id",
                "kanban",
                "lane",
                "column",
                "type",
                "cards"
            ],
            "potential_relationships": [
                "Each cell (row) is associated with a specific Kanban board (via the 'kanban' field).",
                "Cells are organized by their position, indicated by 'lane' and 'column', suggesting a grid or matrix structure within a Kanban board.",
                "The 'cards' field likely contains references or data about work items associated with this cell, possibly as a serialized or delimited list."
            ],
            "business_operations": [
                "Creating, updating, or deleting Kanban cells as the board structure changes.",
                "Moving cards between cells to reflect progress or status changes.",
                "Querying the board to display the current state of all cells and their cards.",
                "Filtering or searching for specific cards within cells based on their type or position.",
                "Aggregating data for reporting on workflow, such as bottlenecks or throughput per lane/column."
            ]
        },
        "zt_kanbancolumn": {
            "business_purpose": "This table represents columns within a Kanban board system. Each record defines a single column, including its display properties, organizational hierarchy, and operational constraints. The table is designed to support the structure and management of Kanban boards, which are commonly used for workflow visualization and task management.",
            "key_fields": [
                "id",
                "parent",
                "type",
                "region",
                "group",
                "name",
                "color",
                "limit",
                "order",
                "archived",
                "deleted"
            ],
            "potential_relationships": [
                "Self-referencing hierarchy via the 'parent' field, allowing columns to be nested or grouped",
                "Logical grouping or categorization using 'region' and 'group' fields, which may correspond to higher-level Kanban board structures or swimlanes",
                "Ordering and workflow sequencing through the 'order' field"
            ],
            "business_operations": [
                "Creating, updating, and deleting Kanban columns",
                "Organizing columns into hierarchies or groups",
                "Archiving or restoring columns",
                "Setting work-in-progress limits for columns",
                "Customizing column appearance (e.g., color, name)",
                "Reordering columns within a board or region",
                "Filtering or displaying only active (non-archived, non-deleted) columns"
            ]
        },
        "zt_kanbanlane": {
            "business_purpose": "This table represents a 'lane' within a Kanban board system, likely used for project or task management. Each record defines a specific lane (such as a workflow stage or column) within a Kanban execution context, with attributes for display, grouping, and organization. The table supports features like ordering, coloring, grouping, and soft deletion, indicating its use in visual workflow management.",
            "key_fields": [
                "id",
                "execution",
                "type",
                "region",
                "group",
                "groupby",
                "name",
                "order",
                "deleted"
            ],
            "potential_relationships": [
                "Belongs to an execution context (possibly a Kanban board or project, referenced by 'execution')",
                "May be grouped or categorized by 'region', 'group', or 'groupby' fields",
                "Could be referenced by other entities (such as tasks or cards) that are assigned to a specific lane"
            ],
            "business_operations": [
                "Creating new Kanban lanes for workflow customization",
                "Updating lane properties (name, color, order, grouping, etc.)",
                "Reordering lanes within a Kanban board",
                "Soft-deleting lanes (marking as deleted without physical removal)",
                "Displaying lanes in a Kanban interface, grouped or filtered by various attributes",
                "Auditing or tracking changes via 'lastEditedTime'"
            ]
        },
        "zt_lang": {
            "business_purpose": "The zt_lang table is designed to store language-specific text resources for an application, supporting internationalization and localization. Each record represents a translatable string or label, categorized by language, module, section, and key, with the actual translation stored in the value field. The table also distinguishes between system and non-system entries and can support different application 'visions' or contexts.",
            "key_fields": [
                "id",
                "lang",
                "module",
                "section",
                "key",
                "value",
                "system",
                "vision"
            ],
            "potential_relationships": [
                "May serve as a lookup or reference table for application modules that need to display localized text",
                "Could be referenced by application logic to retrieve the correct translation based on language, module, section, and key",
                "Might be used in conjunction with configuration or settings tables to determine available languages or modules"
            ],
            "business_operations": [
                "Retrieving localized text for display in the user interface",
                "Inserting or updating translations for new or existing application features",
                "Filtering or exporting translations for specific languages, modules, or sections",
                "Managing system versus custom (non-system) translations",
                "Supporting multi-language or multi-vision deployments of the application"
            ]
        },
        "zt_metric": {
            "business_purpose": "The zt_metric table represents the definition and management of business or system metrics. Each record defines a specific metric, including its purpose, scope, calculation method, scheduling, and lifecycle status. This table is likely used to catalog, configure, and track metrics that are collected, calculated, and reported within an organization or system.",
            "key_fields": [
                "id",
                "purpose",
                "scope",
                "object",
                "stage",
                "type",
                "name",
                "alias",
                "code",
                "unit",
                "dateType",
                "collector",
                "definition",
                "when",
                "event",
                "cronCFG",
                "time",
                "createdBy",
                "createdDate",
                "editedBy",
                "editedDate",
                "implementedBy",
                "implementedDate",
                "delistedBy",
                "delistedDate",
                "builtin",
                "fromID",
                "order",
                "lastCalcRows",
                "lastCalcTime",
                "deleted"
            ],
            "potential_relationships": [
                "Self-referencing: The fromID field suggests a possible hierarchical or versioning relationship within the same table, where a metric may be derived from or related to another metric.",
                "Temporal relationships: Fields like createdDate, editedDate, implementedDate, delistedDate, and lastCalcTime indicate tracking of metric lifecycle events, which could be related to audit or history tracking processes.",
                "Process or event linkage: Fields such as event, when, and cronCFG suggest that metrics may be associated with specific events or scheduled processes, potentially linking to event or scheduling subsystems if they exist."
            ],
            "business_operations": [
                "Defining new metrics for business or system monitoring.",
                "Editing or updating existing metric definitions.",
                "Tracking the implementation, release, or deprecation (delisting) of metrics.",
                "Scheduling and configuring metric collection or calculation routines.",
                "Auditing changes to metric definitions and their lifecycle.",
                "Reporting on metric calculation status, such as last calculation time and number of rows processed.",
                "Managing built-in versus custom metrics."
            ]
        },
        "zt_metriclib": {
            "business_purpose": "The zt_metriclib table is designed to store metric values and their associated metadata for various business entities and time periods. It acts as a metric library or repository, capturing calculated or inferred metrics (such as KPIs, performance indicators, or operational statistics) across different organizational dimensions (system, program, project, product, execution, code, pipeline, repo, dept, user) and timeframes (year, month, week, day). Each record represents a specific metric value, how and when it was calculated, and its contextual associations.",
            "key_fields": [
                "id",
                "metricID",
                "metricCode",
                "system",
                "program",
                "project",
                "product",
                "execution",
                "code",
                "pipeline",
                "repo",
                "user",
                "dept",
                "year",
                "month",
                "week",
                "day",
                "value",
                "calcType",
                "calculatedBy",
                "date",
                "deleted"
            ],
            "potential_relationships": [
                "Acts as a fact or transaction table referencing various business dimensions (system, program, project, etc.)",
                "Can be linked to reporting or analytics processes for aggregating and analyzing metrics",
                "May serve as a source for dashboards or performance monitoring tools",
                "Could be filtered or grouped by time, organizational unit, or calculation type"
            ],
            "business_operations": [
                "Storing calculated or inferred metric values for business analysis",
                "Retrieving metrics for reporting, dashboards, or performance reviews",
                "Auditing or tracking metric calculation history (who calculated, when, and how)",
                "Filtering or aggregating metrics by time period, business unit, or calculation method",
                "Soft-deleting metric records (using the 'deleted' flag) for data lifecycle management"
            ]
        },
        "zt_module": {
            "business_purpose": "The zt_module table represents a hierarchical module or component structure within a larger system or application. It is designed to organize modules into parent-child relationships, track their order, type, ownership, and status, and support operations such as categorization, navigation, or modular configuration.",
            "key_fields": [
                "id",
                "root",
                "parent",
                "path",
                "name",
                "type",
                "order",
                "grade",
                "deleted"
            ],
            "potential_relationships": [
                "Self-referencing hierarchy via the 'parent' field (modules can have submodules)",
                "Grouping or categorization via the 'root' and 'branch' fields",
                "Ownership or responsibility assignment via the 'owner' field",
                "Logical grouping or inheritance via the 'from' field"
            ],
            "business_operations": [
                "Creating, updating, and deleting modules or submodules",
                "Organizing modules into hierarchical structures",
                "Navigating or displaying module trees",
                "Assigning ownership or responsibility for modules",
                "Filtering or searching modules by type, owner, or status",
                "Soft-deleting modules (using the 'deleted' flag)",
                "Ordering modules within a hierarchy"
            ]
        },
        "zt_pivot": {
            "business_purpose": "The zt_pivot table represents a configurable, user-defined data pivot or report definition. It stores metadata and configuration for generating pivot tables or analytical reports, including SQL queries, field definitions, filters, access control, and versioning. This enables users or systems to define, save, and manage custom data views or reports, possibly for business intelligence or dashboarding purposes.",
            "key_fields": [
                "id",
                "dimension",
                "group",
                "code",
                "driver",
                "mode",
                "name",
                "desc",
                "acl",
                "sql",
                "fields",
                "filters",
                "stage",
                "builtin",
                "version",
                "createdBy",
                "createdDate",
                "editedBy",
                "editedDate",
                "deleted"
            ],
            "potential_relationships": [
                "May reference a dimension entity or concept via the 'dimension' field (possibly a foreign key to a dimension definition table)",
                "May be grouped or categorized by the 'group' field (could relate to a logical grouping or category)",
                "Could be linked to user or creator information via 'createdBy' and 'editedBy' (but no explicit foreign key)",
                "Could be referenced by other tables that use or schedule these pivot definitions"
            ],
            "business_operations": [
                "Creating and saving new pivot/report definitions",
                "Editing or updating existing pivot/report definitions",
                "Publishing or drafting pivot/report definitions (via 'stage')",
                "Controlling access to pivots/reports (via 'acl' and 'whitelist')",
                "Executing or rendering reports based on the stored SQL and configuration",
                "Versioning and managing built-in vs. user-defined pivots",
                "Soft-deleting pivots/reports (via 'deleted')",
                "Filtering, searching, and listing available pivots/reports"
            ]
        },
        "zt_pivotdrill": {
            "business_purpose": "The zt_pivotdrill table appears to represent the configuration or definition of drill-down options for pivot reports or dashboards. Each record defines how a user can 'drill' into a specific field of a pivot report, including the object being analyzed, the filtering conditions, and the SQL logic to apply. This enables dynamic, user-defined or system-defined exploration of data within a reporting or business intelligence context.",
            "key_fields": [
                "pivot",
                "version",
                "field",
                "object",
                "whereSql",
                "condition",
                "status",
                "type"
            ],
            "potential_relationships": [
                "May be associated with a parent pivot report or dashboard (via the 'pivot' field, which likely references a pivot definition elsewhere)",
                "Could be linked to specific data objects or modules (via the 'object' field)",
                "May be filtered or personalized by user/account (via the 'account' field)"
            ],
            "business_operations": [
                "Defining and saving drill-down configurations for pivot reports",
                "Managing versions of drill-down definitions",
                "Publishing or designing new drill-down options for reports",
                "Applying dynamic or static filtering logic to report data",
                "Enabling users to explore data interactively through drill-down actions in dashboards"
            ]
        },
        "zt_pivotspec": {
            "business_purpose": "The zt_pivotspec table represents the specification and configuration of pivot reports or data analysis views. Each record defines a unique pivot report, including its SQL logic, fields, filters, variables, and settings, potentially for use in a reporting or business intelligence module. The table supports versioning and multiple database drivers, allowing for flexible report definitions across different environments and versions.",
            "key_fields": [
                "pivot",
                "version",
                "driver",
                "mode",
                "name",
                "sql",
                "fields",
                "filters",
                "settings",
                "createdDate"
            ],
            "potential_relationships": [
                "Could serve as a parent or reference for tables storing pivot report results, execution logs, or user-specific pivot configurations",
                "Might be referenced by tables that track usage, sharing, or scheduling of pivot reports"
            ],
            "business_operations": [
                "Defining and saving new pivot report specifications",
                "Versioning and updating existing pivot report definitions",
                "Retrieving pivot specifications for report generation or display",
                "Filtering and searching available pivot reports",
                "Managing report settings, filters, and variables for dynamic data analysis",
                "Auditing or tracking creation dates for report lifecycle management"
            ]
        },
        "zt_process": {
            "business_purpose": "The 'zt_process' table represents a business process or workflow step definition within a system that manages structured processes. Each record defines a specific process step, including its name, type, description, assignment, status, and metadata about its creation and modification. The table is designed to support process modeling, tracking, and assignment within a project or operational workflow context.",
            "key_fields": [
                "id",
                "model",
                "name",
                "type",
                "abbr",
                "desc",
                "assignedTo",
                "status",
                "order",
                "createdBy",
                "createdDate",
                "editedBy",
                "editedDate",
                "assignedBy",
                "assignedDate",
                "deleted"
            ],
            "potential_relationships": [
                "Could serve as a parent or reference table for process steps in a workflow",
                "Might be referenced by tables that track process execution, process logs, or process assignments",
                "Could be related to tables that define process templates, process instances, or process dependencies"
            ],
            "business_operations": [
                "Defining and configuring process steps or workflow stages",
                "Assigning process steps to responsible individuals or roles",
                "Tracking the status and order of process steps",
                "Auditing creation, assignment, and modification history of process steps",
                "Soft-deleting (marking as deleted) process steps without physical removal"
            ]
        },
        "zt_product": {
            "business_purpose": "The zt_product table represents a product entity within a project or product management system. It is designed to track detailed information about products, including their status, type, associated personnel, access control, and aggregated statistics about related work items such as epics, requirements, stories, bugs, plans, and releases. The table supports product lifecycle management, team collaboration, and reporting.",
            "key_fields": [
                "id",
                "program",
                "name",
                "code",
                "type",
                "status",
                "subStatus",
                "PO",
                "QD",
                "RD",
                "workflowGroup",
                "acl",
                "order",
                "vision",
                "deleted",
                "createdBy",
                "createdDate",
                "closedDate",
                "desc",
                "draftEpics",
                "activeEpics",
                "changingEpics",
                "reviewingEpics",
                "finishedEpics",
                "closedEpics",
                "totalEpics",
                "draftRequirements",
                "activeRequirements",
                "changingRequirements",
                "reviewingRequirements",
                "finishedRequirements",
                "closedRequirements",
                "totalRequirements",
                "draftStories",
                "activeStories",
                "changingStories",
                "reviewingStories",
                "finishedStories",
                "closedStories",
                "totalStories",
                "unresolvedBugs",
                "closedBugs",
                "fixedBugs",
                "totalBugs",
                "plans",
                "releases"
            ],
            "potential_relationships": [
                "One-to-many: Each product may be associated with multiple epics, requirements, stories, bugs, plans, and releases, as indicated by the aggregate count fields.",
                "Many-to-one: The 'program' and 'line' fields suggest that each product may belong to a program or product line.",
                "Many-to-many: The 'groups', 'whitelist', and 'reviewer' fields (as text) may represent associations with multiple groups or users, possibly for access control or review processes.",
                "Role-based: Fields like 'PO', 'QD', 'RD', and 'feedback' indicate assignment of specific roles or responsibilities to individuals or teams for each product."
            ],
            "business_operations": [
                "Creating, updating, and deleting product records",
                "Tracking and reporting product progress and status",
                "Aggregating and displaying statistics for epics, requirements, stories, and bugs related to each product",
                "Managing product access control and permissions",
                "Assigning and managing product roles and responsibilities",
                "Planning and tracking product releases and plans",
                "Auditing product lifecycle events (creation, closure, deletion)",
                "Filtering and ordering products for dashboards or reports"
            ]
        },
        "zt_productplan": {
            "business_purpose": "The zt_productplan table represents the planning and tracking of product plans or roadmaps within a business context. Each record details a specific plan for a product, including its status, timeline, description, and hierarchical relationships to other plans. This table is likely used to manage and monitor the lifecycle, progress, and organization of product development or release plans.",
            "key_fields": [
                "id",
                "product",
                "branch",
                "parent",
                "title",
                "status",
                "begin",
                "end",
                "finishedDate",
                "closedDate",
                "closedReason",
                "createdBy",
                "createdDate",
                "deleted"
            ],
            "potential_relationships": [
                "Belongs-to relationship with a product entity (via the 'product' field)",
                "Self-referential hierarchical relationship (via the 'parent' field, allowing plans to be nested or structured in a tree)",
                "Possible association with different branches or versions (via the 'branch' field)",
                "Potential linkage to user or creator information (via the 'createdBy' field, though not enforced by a foreign key)"
            ],
            "business_operations": [
                "Creating new product plans and associating them with products and branches",
                "Updating the status, timeline, and details of product plans as work progresses",
                "Organizing plans hierarchically (e.g., sub-plans or phases under a main plan)",
                "Tracking the lifecycle of plans, including when they are started, finished, or closed, and the reasons for closure",
                "Filtering or reporting on plans by status, date, or branch for project management and oversight",
                "Soft-deleting plans (using the 'deleted' flag) for audit or archival purposes"
            ]
        },
        "zt_project": {
            "business_purpose": "The zt_project table represents a comprehensive project management entity, capturing detailed information about projects, sub-projects, or project phases. It is designed to track project attributes, hierarchy, progress, budgeting, scheduling, team assignments, and status throughout the project lifecycle. The table supports complex project structures, including parent-child relationships, milestones, and various project management methodologies.",
            "key_fields": [
                "id",
                "name",
                "code",
                "parent",
                "project",
                "type",
                "status",
                "begin",
                "end",
                "budget",
                "budgetUnit",
                "percent",
                "progress",
                "estimate",
                "consumed",
                "left",
                "PM",
                "team",
                "milestone",
                "deleted"
            ],
            "potential_relationships": [
                "Self-referencing hierarchy via the 'parent' field, allowing projects to have sub-projects or phases",
                "Grouping or linking of projects via the 'project' field, possibly representing a program or higher-level grouping",
                "Milestone tracking within projects using the 'milestone' field",
                "Workflow or process grouping via 'workflowGroup'",
                "Project ordering or prioritization via the 'order' field"
            ],
            "business_operations": [
                "Creating, updating, and deleting project records",
                "Organizing projects into hierarchies or phases",
                "Tracking project progress, status, and completion",
                "Managing project budgets and financials",
                "Assigning project managers and teams",
                "Monitoring project timelines and schedules",
                "Reporting on project performance and milestones",
                "Archiving or soft-deleting projects (using the 'deleted' flag)",
                "Filtering and sorting projects by status, priority, or other attributes"
            ]
        },
        "zt_projectadmin": {
            "business_purpose": "This table represents the assignment of administrative privileges or roles to specific user accounts within defined groups, with scope over certain programs, projects, products, and executions. It is likely used to manage which users (accounts) have administrative rights over specific business entities, organized by group.",
            "key_fields": [
                "group",
                "account",
                "programs",
                "projects",
                "products",
                "executions"
            ],
            "potential_relationships": [
                "Many-to-many relationship between groups and accounts, as both fields are part of the primary key",
                "Possible one-to-many or many-to-many relationships between an account/group and the entities listed in the text fields (programs, projects, products, executions), depending on how those text fields are structured (e.g., as lists of IDs or names)",
                "Acts as a mapping or junction table for administrative assignments"
            ],
            "business_operations": [
                "Assigning or revoking administrative privileges for users within groups",
                "Querying which users have admin rights over specific programs, projects, products, or executions",
                "Auditing or reporting on administrative assignments",
                "Updating the scope of admin rights for a user (e.g., adding or removing projects or products they can administer)",
                "Validating user permissions for access control in business processes"
            ]
        },
        "zt_projectcase": {
            "business_purpose": "The zt_projectcase table appears to represent the association between projects and test cases, possibly within the context of a product. It likely tracks which test cases are assigned to which projects, along with metadata such as the number of times a case is used (count), its version, and its order within the project. This structure is typical in environments where test management or quality assurance is performed on a per-project basis, and where test cases may be reused across multiple projects and products.",
            "key_fields": [
                "project",
                "case",
                "product",
                "count",
                "version",
                "order"
            ],
            "potential_relationships": [
                "Many-to-many relationship between projects and cases (each project can have multiple cases, and each case can belong to multiple projects)",
                "Possible association with products, indicating that the project-case link is also product-specific",
                "Composite primary key on (project, case) suggests uniqueness of each project-case pair"
            ],
            "business_operations": [
                "Assigning test cases to projects",
                "Tracking the usage count of a test case within a project",
                "Managing versions of test cases as they are used in projects",
                "Ordering or sequencing test cases within a project",
                "Reporting on which test cases are associated with which projects and products"
            ]
        },
        "zt_projectproduct": {
            "business_purpose": "This table represents the association between projects, products, and their specific branches, along with related planning and roadmap information. It is likely used to track which products (and their branches) are involved in which projects, and to store plan and roadmap details for each unique combination.",
            "key_fields": [
                "project",
                "product",
                "branch",
                "plan",
                "roadmap"
            ],
            "potential_relationships": [
                "Many-to-many relationship between projects and products, further refined by branch",
                "Composite primary key (project, product, branch) indicates each combination is unique",
                "Potential for referencing or being referenced by tables that define projects, products, or branches (if they exist)"
            ],
            "business_operations": [
                "Assigning products (and their branches) to projects",
                "Tracking or updating the plan and roadmap for a specific project-product-branch combination",
                "Querying which products/branches are associated with a project",
                "Reporting on project progress or planning at the product/branch level"
            ]
        },
        "zt_projectstory": {
            "business_purpose": "The zt_projectstory table represents the association between projects and stories (likely requirements, features, or tasks) within the context of a specific product and branch. It tracks which stories are included in which projects, along with their version and order, supporting project management or product development processes.",
            "key_fields": [
                "project",
                "story",
                "product",
                "branch",
                "version",
                "order"
            ],
            "potential_relationships": [
                "Many-to-many relationship between projects and stories, as each project can have multiple stories and each story can belong to multiple projects.",
                "Association with products and branches, indicating that the linkage between project and story is contextualized by a specific product and branch.",
                "Versioning relationship, where the same story can have multiple versions within a project."
            ],
            "business_operations": [
                "Assigning stories to projects for planning and tracking purposes.",
                "Managing the order of stories within a project (prioritization or workflow sequencing).",
                "Tracking which version of a story is included in a project.",
                "Filtering or reporting on stories by project, product, branch, or version.",
                "Supporting project progress tracking and release planning."
            ]
        },
        "zt_queue": {
            "business_purpose": "The zt_queue table represents a task or job queue system, designed to manage and track the execution of scheduled or background tasks. Each record corresponds to a queued job, including its scheduling information, execution command, type, status, and metadata for tracking and soft deletion.",
            "key_fields": [
                "id",
                "cron",
                "type",
                "command",
                "status",
                "execId",
                "createdDate",
                "deleted"
            ],
            "potential_relationships": [
                "May reference a scheduling or cron configuration entity via the 'cron' field",
                "May be linked to an execution log or result entity via the 'execId' field",
                "Could be filtered or grouped by 'type' for different job categories"
            ],
            "business_operations": [
                "Enqueuing new tasks or jobs for future execution",
                "Updating the status of jobs as they move from waiting to doing to done",
                "Retrieving and dispatching jobs that are ready to be executed",
                "Auditing or reviewing job execution history",
                "Soft-deleting jobs (marking as deleted without physical removal)",
                "Filtering or reporting on jobs by type, status, or creation date"
            ]
        },
        "zt_screen": {
            "business_purpose": "The zt_screen table represents a configurable or customizable 'screen' entity, likely used for displaying information, dashboards, or visual layouts within an application. Each record defines a screen's properties, access control, content scheme, and metadata, supporting both user-created and built-in screens.",
            "key_fields": [
                "id",
                "dimension",
                "name",
                "acl",
                "whitelist",
                "scheme",
                "status",
                "builtin",
                "createdBy",
                "createdDate",
                "editedBy",
                "editedDate",
                "deleted"
            ],
            "potential_relationships": [
                "May be referenced by other tables that assign or use screens (e.g., via the id field as a foreign key).",
                "The 'dimension' field may relate to another entity or concept representing screen size, type, or grouping, but no explicit relationship is defined.",
                "The 'createdBy' and 'editedBy' fields suggest a possible association with entities representing creators or editors, but no foreign keys are present."
            ],
            "business_operations": [
                "Creating new screens with specific layouts and access controls.",
                "Editing or updating screen properties, content, and metadata.",
                "Publishing or drafting screens for workflow management.",
                "Controlling access to screens via ACL and whitelist mechanisms.",
                "Displaying or rendering screens based on their scheme and cover definitions.",
                "Managing built-in versus user-defined screens.",
                "Soft-deleting screens (marking as deleted without physical removal)."
            ]
        },
        "zt_searchdict": {
            "business_purpose": "The zt_searchdict table appears to function as a small dictionary or lookup table, mapping numeric keys to short string values. Its structure suggests it is used to standardize or encode small sets of values (such as codes, abbreviations, or flags) for use in search, filtering, or categorization processes within an application.",
            "key_fields": [
                "key",
                "value"
            ],
            "potential_relationships": [
                "Could serve as a reference or lookup table for other tables that store the 'key' or 'value' as a foreign key or code",
                "Might be used in many-to-one relationships where multiple records in another table reference a single entry in this dictionary"
            ],
            "business_operations": [
                "Translating or decoding numeric codes into human-readable short codes or abbreviations",
                "Populating dropdowns or filter options in search interfaces",
                "Validating input data against allowed codes",
                "Supporting reporting or analytics by providing standardized code mappings"
            ]
        },
        "zt_searchindex": {
            "business_purpose": "The zt_searchindex table is designed to serve as a search index for various business objects within an application. It stores searchable metadata (such as title and content) for different object types, allowing efficient full-text or filtered search functionality across multiple entities. The table acts as a centralized index to facilitate quick retrieval of relevant records based on user queries.",
            "key_fields": [
                "id",
                "vision",
                "objectType",
                "objectID",
                "title",
                "content",
                "addedDate"
            ],
            "potential_relationships": [
                "Polymorphic relationship: The combination of objectType and objectID suggests that each row references a record in another table, with objectType indicating the type of object and objectID its unique identifier.",
                "Temporal relationship: The addedDate and editedDate fields allow tracking of when the indexed content was created or updated, supporting time-based queries or filtering."
            ],
            "business_operations": [
                "Indexing new or updated business objects for searchability",
                "Performing full-text or filtered searches across multiple object types",
                "Retrieving metadata (title, content) for search result display",
                "Maintaining and updating the search index when underlying business objects change",
                "Auditing or reporting on indexed content based on creation or modification dates"
            ]
        },
        "zt_stage": {
            "business_purpose": "The zt_stage table represents a set of defined stages or phases within a business process, likely related to project or workflow management. Each record defines a stage with a name, a percentage (possibly indicating completion or progress), a type, and an associated project type. The table also tracks who created or edited each stage, when these actions occurred, and whether the stage is marked as deleted. This structure is typical for managing the lifecycle or progress tracking of projects, tasks, or other multi-stage processes.",
            "key_fields": [
                "id",
                "name",
                "percent",
                "type",
                "projectType",
                "createdBy",
                "createdDate",
                "editedBy",
                "editedDate",
                "deleted"
            ],
            "potential_relationships": [
                "Could serve as a reference or lookup table for stages in a process or project workflow",
                "Might be linked to records representing projects, tasks, or process instances that use these stages",
                "Could be used in reporting or auditing to track changes to stage definitions"
            ],
            "business_operations": [
                "Defining and managing the stages of a business process or project workflow",
                "Tracking progress or status by associating entities with specific stages",
                "Auditing changes to stage definitions (who created/edited and when)",
                "Filtering or excluding deleted stages from active use",
                "Customizing workflows by project type or stage type"
            ]
        },
        "zt_story": {
            "business_purpose": "The zt_story table represents a business entity for managing 'stories' or 'requirements' within a product or project lifecycle. Each record captures a user story, feature, or requirement, tracking its status, relationships, origin, and lifecycle events. The table is designed to support hierarchical, versioned, and collaborative management of requirements, including their planning, assignment, review, and closure.",
            "key_fields": [
                "id",
                "title",
                "product",
                "parent",
                "isParent",
                "status",
                "stage",
                "type",
                "category",
                "estimate",
                "pri",
                "assignedTo",
                "openedBy",
                "openedDate",
                "lastEditedBy",
                "lastEditedDate",
                "version",
                "deleted"
            ],
            "potential_relationships": [
                "Hierarchical self-relation via 'parent' and 'isParent' fields (stories can be nested or grouped)",
                "Versioning/self-relation via 'fromStory', 'fromVersion', 'parentVersion', 'demandVersion', and 'duplicateStory'",
                "Linkage to other requirements or stories via 'linkStories', 'linkRequirements', and 'twins'",
                "Association with products or modules via 'product', 'branch', 'module', and 'plan'",
                "Traceability to bugs or feedback via 'fromBug', 'toBug', and 'feedback'",
                "Lifecycle and workflow tracking via status, stage, and various user/date fields"
            ],
            "business_operations": [
                "Creating and submitting new stories or requirements",
                "Editing and updating story details, status, and stage",
                "Assigning stories to responsible individuals",
                "Tracking the progress and lifecycle of stories (review, approval, closure, release, etc.)",
                "Organizing stories hierarchically (epics, parent/child stories)",
                "Linking stories to other requirements, feedback, or bugs",
                "Versioning and managing changes to stories",
                "Filtering and reporting on stories by status, stage, product, or assignee",
                "Soft-deleting or retracting stories"
            ]
        },
        "zt_storygrade": {
            "business_purpose": "The zt_storygrade table represents a classification or grading system for different types of work items, such as stories, requirements, and epics. It is likely used to assign a grade or level to these items, along with a descriptive name and status, supporting processes like evaluation, prioritization, or progress tracking within a project or product management context.",
            "key_fields": [
                "type",
                "grade",
                "name",
                "status"
            ],
            "potential_relationships": [
                "Could be referenced by work item tables (e.g., stories, requirements, epics) to assign a grade or classification",
                "May serve as a lookup or reference table for grading schemes",
                "Might be used in reporting or analytics to group or filter work items by grade, type, or status"
            ],
            "business_operations": [
                "Assigning or updating grades for work items",
                "Defining or modifying grading schemes for different types of work items",
                "Reporting on the distribution of grades across stories, requirements, or epics",
                "Filtering or sorting work items based on grade, type, or status"
            ]
        },
        "zt_storyreview": {
            "business_purpose": "The zt_storyreview table represents the process of recording individual reviews of specific versions of a 'story' entity by different reviewers. It is designed to track the outcome and timing of each review, supporting versioned review workflows for stories.",
            "key_fields": [
                "story",
                "version",
                "reviewer",
                "result",
                "reviewDate"
            ],
            "potential_relationships": [
                "Many-to-one relationship to a 'story' entity, where each review references a specific story.",
                "Many-to-one relationship to a 'version' entity or versioning system, as each review is tied to a specific version of a story.",
                "Many-to-one relationship to a 'reviewer' entity, as each review is performed by a specific reviewer.",
                "Composite primary key (story, version, reviewer) indicates that each reviewer can review each version of a story only once."
            ],
            "business_operations": [
                "Recording the outcome of a review for a specific version of a story by a reviewer.",
                "Querying the review history for a particular story or version.",
                "Auditing who reviewed which version of a story and when.",
                "Aggregating review results to determine the overall status of a story version.",
                "Tracking the review process for compliance or quality assurance purposes."
            ]
        },
        "zt_storyspec": {
            "business_purpose": "The zt_storyspec table represents versioned specifications for 'stories', likely in the context of requirements management, product development, or software project tracking. Each record captures a specific version of a story's specification, including its title, detailed description, verification criteria, and associated files or documentation. This enables tracking changes and maintaining a history of how a story's requirements evolve over time.",
            "key_fields": [
                "story",
                "version",
                "title",
                "spec",
                "verify",
                "files",
                "docs",
                "docVersions"
            ],
            "potential_relationships": [
                "One-to-many: Each 'story' can have multiple versions, with each version represented by a unique (story, version) pair.",
                "Potential reference: The 'story' field likely corresponds to a unique story entity elsewhere, but within this table, it is used to group versions of the same story."
            ],
            "business_operations": [
                "Creating new versions of a story's specification as requirements change.",
                "Retrieving the latest or historical versions of a story's specification for review or audit.",
                "Comparing different versions of a story's specification to track changes.",
                "Attaching or referencing files and documentation relevant to a specific version of a story.",
                "Defining and reviewing verification criteria for each version of a story."
            ]
        },
        "zt_system": {
            "business_purpose": "The zt_system table represents a business entity for managing and tracking systems or subsystems within a larger product context. Each record describes a distinct system, its association with a product, its integration status, release information, hierarchical relationships (children), and lifecycle metadata (status, creation, editing, deletion). This table is likely used to organize, monitor, and maintain systems as part of a product's development, deployment, or operational lifecycle.",
            "key_fields": [
                "id",
                "name",
                "product",
                "integrated",
                "latestRelease",
                "latestDate",
                "children",
                "status",
                "desc",
                "createdBy",
                "createdDate",
                "editedBy",
                "editedDate",
                "deleted"
            ],
            "potential_relationships": [
                "Belongs-to relationship with a product entity (via the 'product' field, which is a foreign key reference to a product identifier)",
                "Hierarchical or parent-child relationship with other systems (via the 'children' field, which may store references to child system IDs)",
                "Associations with release entities (via 'latestRelease')",
                "Audit trail or user tracking for creation and editing (via 'createdBy' and 'editedBy', which may reference user identifiers, but this is not enforced in the schema)"
            ],
            "business_operations": [
                "Creating new system records as part of product development or system onboarding",
                "Updating system details, such as integration status, release information, or descriptions",
                "Tracking the latest release and release date for each system",
                "Managing system status (activating, deactivating, or soft-deleting systems)",
                "Maintaining hierarchical relationships between systems and their subsystems",
                "Auditing changes to systems, including who created or edited them and when"
            ]
        },
        "zt_task": {
            "business_purpose": "The zt_task table represents tasks or work items within a project management or workflow tracking system. Each record captures detailed information about a specific task, including its hierarchy, association with projects, execution phases, related requirements or issues, status, assignment, and progress metrics. The table is designed to support complex task management, including sub-tasks, dependencies, and integration with other project artifacts such as stories, bugs, designs, and documentation.",
            "key_fields": [
                "id",
                "project",
                "parent",
                "isParent",
                "path",
                "execution",
                "story",
                "design",
                "fromBug",
                "fromIssue",
                "name",
                "type",
                "status",
                "assignedTo",
                "estimate",
                "consumed",
                "left",
                "deadline",
                "openedBy",
                "openedDate",
                "finishedBy",
                "finishedDate",
                "canceledBy",
                "canceledDate",
                "closedBy",
                "closedDate",
                "deleted"
            ],
            "potential_relationships": [
                "Hierarchical (self-referencing) relationships via the 'parent' field, allowing tasks to have sub-tasks or be grouped under parent tasks.",
                "Associative relationships to projects (via 'project'), executions/phases (via 'execution'), modules (via 'module'), stories (via 'story'), designs (via 'design'), bugs (via 'fromBug'), issues (via 'fromIssue'), and repositories (via 'repo').",
                "Versioning relationships through fields like 'storyVersion', 'designVersion', and 'version', indicating linkage to specific versions of related entities.",
                "Document and feedback associations through 'docs', 'docVersions', and 'feedback'."
            ],
            "business_operations": [
                "Creating, updating, and deleting tasks as part of project planning and execution.",
                "Assigning tasks to individuals and tracking their progress and status changes.",
                "Organizing tasks into hierarchies (parent/child relationships) for work breakdown structures.",
                "Linking tasks to project artifacts such as requirements (stories), designs, bugs, issues, and documentation.",
                "Monitoring task estimates, actual work consumed, and remaining effort for project tracking and reporting.",
                "Managing task lifecycle events such as opening, assigning, starting, finishing, canceling, and closing tasks.",
                "Filtering and reporting on tasks by status, priority, deadlines, and other attributes for project management oversight."
            ]
        },
        "zt_taskspec": {
            "business_purpose": "The zt_taskspec table represents versioned specifications or definitions for tasks. Each record defines a specific version of a task's specification, including its name, estimated start date, and deadline. This allows tracking changes to a task's details over time, supporting version control for task specifications.",
            "key_fields": [
                "task",
                "version",
                "name",
                "estStarted",
                "deadline"
            ],
            "potential_relationships": [
                "One-to-many: Each task (identified by 'task') can have multiple versions (distinguished by 'version'), indicating a one-to-many relationship between a task and its specifications.",
                "Potential foreign key: The 'task' field likely references a unique task entity elsewhere, but this is not enforced in the current schema."
            ],
            "business_operations": [
                "Creating new versions of a task's specification when requirements or details change.",
                "Retrieving the current or historical specifications for a given task.",
                "Auditing or reviewing changes to task definitions over time.",
                "Reporting on planned start dates and deadlines for different versions of tasks."
            ]
        },
        "zt_team": {
            "business_purpose": "The zt_team table represents the assignment and participation of individuals (accounts) in various work entities such as projects, tasks, or executions. It tracks each member's role, position, time allocation, and progress within a specific context (project, task, or execution), supporting resource management and workload tracking.",
            "key_fields": [
                "id",
                "root",
                "type",
                "account",
                "role",
                "position",
                "limited",
                "join",
                "days",
                "hours",
                "estimate",
                "consumed",
                "left",
                "order"
            ],
            "potential_relationships": [
                "Many-to-one: Each record links an account to a specific root entity (project, task, or execution), suggesting a many-to-one relationship with the entity identified by 'root' and 'type'.",
                "One-to-many: A single root entity (project/task/execution) can have multiple team members (records) associated with it.",
                "One-to-one: Each record represents a unique assignment of an account to a root entity with a specific role and position."
            ],
            "business_operations": [
                "Assigning team members to projects, tasks, or executions.",
                "Tracking team member roles, positions, and participation status.",
                "Recording and updating time estimates, time consumed, and remaining work for each team member.",
                "Managing team composition, including joining date and workload limits.",
                "Generating reports on resource allocation, workload, and progress at the individual or team level.",
                "Ordering or prioritizing team members within a project/task/execution context."
            ]
        },
        "zt_testresult": {
            "business_purpose": "The zt_testresult table represents the results of test executions, likely in a software testing or quality assurance context. Each record captures the outcome of running a specific test case (potentially as part of a test run, job, or deployment), including details such as the result, steps, runner, timing, and related metadata. This table is designed to store granular information about individual test executions for tracking, reporting, and analysis purposes.",
            "key_fields": [
                "id",
                "run",
                "case",
                "version",
                "job",
                "compile",
                "caseResult",
                "stepResults",
                "ZTFResult",
                "lastRunner",
                "date",
                "duration",
                "deploy"
            ],
            "potential_relationships": [
                "Many-to-one relationship to a test run entity (via 'run')",
                "Many-to-one relationship to a test case entity (via 'case')",
                "Many-to-one relationship to a version entity (via 'version')",
                "Many-to-one relationship to a job entity (via 'job')",
                "Many-to-one relationship to a compile/build entity (via 'compile')",
                "Many-to-one relationship to a deployment entity (via 'deploy')",
                "Possible association with a node or environment entity (via 'node')"
            ],
            "business_operations": [
                "Recording the results of executed test cases",
                "Querying and reporting on test execution outcomes",
                "Analyzing test performance and duration",
                "Auditing who ran tests and when",
                "Reviewing detailed step-by-step test results",
                "Aggregating results for quality assurance metrics",
                "Tracking test results across different runs, jobs, versions, and deployments"
            ]
        },
        "zt_testrun": {
            "business_purpose": "The zt_testrun table represents the execution or tracking of test cases as part of a testing process, likely within a quality assurance or software testing workflow. Each record logs a specific instance of a test case being run as part of a testing task, including assignment, execution details, and results.",
            "key_fields": [
                "id",
                "task",
                "case",
                "version",
                "assignedTo",
                "lastRunner",
                "lastRunDate",
                "lastRunResult",
                "status"
            ],
            "potential_relationships": [
                "Many-to-one relationship to a 'task' entity, where multiple test runs are associated with a single task.",
                "Many-to-one relationship to a 'case' entity, where each test run is linked to a specific test case.",
                "Possible versioning relationship, where the 'version' field tracks which version of the test case was executed.",
                "Assignment relationship, where 'assignedTo' and 'lastRunner' reference individuals responsible for or who executed the test run."
            ],
            "business_operations": [
                "Assigning test runs to testers or team members.",
                "Recording the execution of test cases as part of a testing task.",
                "Tracking the status and results of test runs for reporting and quality assurance.",
                "Auditing who executed a test run and when it was last run.",
                "Filtering or querying test runs by task, case, assigned user, status, or result for management and analysis."
            ]
        },
        "zt_testtask": {
            "business_purpose": "The zt_testtask table represents a test task management entity, likely used to track, assign, and monitor the progress of testing activities within a project or product lifecycle. It is designed to capture details about individual test tasks, including their association with projects, products, builds, execution cycles, ownership, scheduling, status, and reporting. This table supports the organization and workflow of software testing processes.",
            "key_fields": [
                "id",
                "project",
                "product",
                "name",
                "execution",
                "build",
                "type",
                "owner",
                "pri",
                "begin",
                "end",
                "status",
                "testreport",
                "createdBy",
                "createdDate",
                "deleted"
            ],
            "potential_relationships": [
                "Many-to-one relationship to a project entity (via 'project')",
                "Many-to-one relationship to a product entity (via 'product')",
                "Many-to-one relationship to an execution or test cycle entity (via 'execution')",
                "Many-to-one relationship to a build entity (via 'build')",
                "Many-to-one relationship to a test report entity (via 'testreport')"
            ],
            "business_operations": [
                "Creating and assigning new test tasks",
                "Tracking the progress and status of test tasks",
                "Scheduling and planning test activities (using begin/end dates)",
                "Recording actual start and finish times for test tasks",
                "Documenting test task descriptions and reports",
                "Managing ownership and team members for test tasks",
                "Filtering and reporting on test tasks by status, priority, or owner",
                "Soft-deleting test tasks (using the 'deleted' flag)"
            ]
        },
        "zt_user": {
            "business_purpose": "The zt_user table represents a comprehensive user profile and account management entity within an organization. It is designed to store authentication credentials, personal details, contact information, organizational roles, and system usage metrics for individuals who interact with a business platform. The table supports both internal and possibly external users, tracks their status, and manages their access and activity within the system.",
            "key_fields": [
                "id",
                "account",
                "password",
                "company",
                "dept",
                "role",
                "realname",
                "email",
                "type",
                "deleted",
                "clientStatus",
                "score",
                "scoreLevel",
                "resetToken"
            ],
            "potential_relationships": [
                "Belongs-to relationship with a company (via 'company' field)",
                "Belongs-to relationship with a department (via 'dept' field)",
                "Self-referential or hierarchical relationship (via 'superior' field, which may reference another user's account)",
                "May be referenced by audit, activity, or access log tables (via 'id' or 'account')",
                "May be linked to communication or messaging modules (via contact fields like 'email', 'skype', 'weixin', etc.)"
            ],
            "business_operations": [
                "User registration and onboarding",
                "Authentication and login management",
                "User profile management and updates",
                "Role and permission assignment",
                "Tracking user activity and login attempts",
                "Password reset and account recovery",
                "User status monitoring (online, offline, busy, etc.)",
                "Internal communication and contact lookup",
                "User scoring, ranking, or gamification features",
                "Soft deletion and user lifecycle management"
            ]
        },
        "zt_usergroup": {
            "business_purpose": "This table represents the association between user accounts and groups, potentially within the context of specific projects. It is designed to map which users belong to which groups, and optionally, which projects this association applies to. This structure is typical for managing permissions, roles, or access control within an application.",
            "key_fields": [
                "account",
                "group",
                "project"
            ],
            "potential_relationships": [
                "Many-to-many relationship between accounts and groups, as each account can belong to multiple groups and each group can have multiple accounts.",
                "Optional association with projects, indicating that the user-group relationship may be scoped or filtered by project context."
            ],
            "business_operations": [
                "Assigning users to groups for permission or role management.",
                "Querying which groups a user belongs to, possibly within a specific project.",
                "Determining all users in a particular group, optionally filtered by project.",
                "Managing or auditing access control by reviewing user-group-project associations.",
                "Removing or updating user-group associations, especially when project assignments change."
            ]
        },
        "zt_userview": {
            "business_purpose": "The zt_userview table represents a user's personalized view or access configuration for various business entities such as programs, products, projects, and sprints. Each record defines which specific items (likely by ID or serialized list) a particular account can see or interact with, supporting user-specific filtering or access control.",
            "key_fields": [
                "id",
                "account",
                "programs",
                "products",
                "projects",
                "sprints"
            ],
            "potential_relationships": [
                "One-to-one or one-to-many relationship between a user account and their view configuration",
                "Potential indirect relationships to entities such as programs, products, projects, and sprints, as referenced in the corresponding fields (likely by storing their IDs or serialized data)"
            ],
            "business_operations": [
                "Retrieving a user's allowed or preferred set of programs, products, projects, or sprints for display or access control",
                "Updating a user's view configuration when their access rights or preferences change",
                "Filtering data shown to a user based on their personalized view settings",
                "Auditing or reporting on user-specific access or visibility settings"
            ]
        },
        "zt_weeklyreport": {
            "business_purpose": "The zt_weeklyreport table represents weekly project performance reports, capturing key project management metrics and qualitative updates for a specific project and week. It is designed to track and evaluate project progress, resource allocation, and performance over time on a weekly basis.",
            "key_fields": [
                "id",
                "project",
                "weekStart",
                "pv",
                "ev",
                "ac",
                "sv",
                "cv",
                "staff",
                "progress",
                "workload"
            ],
            "potential_relationships": [
                "Many-to-one relationship to a project entity (each report is for one project, but a project can have many reports)",
                "Potential aggregation or reporting relationships (e.g., summarizing weekly data over time)",
                "Temporal relationship (tracking changes week by week for the same project)"
            ],
            "business_operations": [
                "Recording weekly project status and performance metrics",
                "Generating project progress and performance reports",
                "Analyzing project trends and variances over time",
                "Monitoring resource allocation and workload distribution",
                "Supporting project management reviews and decision-making"
            ]
        },
        "zt_workflowdatasource": {
            "business_purpose": "The zt_workflowdatasource table defines and manages data sources used within a workflow system. Each record represents a configurable data source that can supply data to workflow components, such as dropdowns, lookups, or dynamic fields. The data sources can be of various types (system, SQL, function, option, language, category), and are described with metadata to enable dynamic data retrieval and display within workflow processes.",
            "key_fields": [
                "id",
                "type",
                "name",
                "code",
                "datasource",
                "keyField",
                "valueField",
                "buildin",
                "vision",
                "createdBy",
                "createdDate",
                "editedBy",
                "editedDate"
            ],
            "potential_relationships": [
                "Referenced by workflow configuration tables to supply selectable options or data for workflow fields",
                "May be linked to workflow step definitions to provide dynamic data at runtime",
                "Could be used by workflow UI components to populate lists or dropdowns based on the datasource definition"
            ],
            "business_operations": [
                "Defining new data sources for use in workflow forms or automation steps",
                "Editing existing data source definitions to update their logic or data retrieval methods",
                "Retrieving data source definitions to dynamically populate workflow UI elements",
                "Auditing changes to data sources via createdBy/createdDate and editedBy/editedDate fields",
                "Filtering or displaying data sources based on type, vision, or buildin status"
            ]
        },
        "zt_workflowgroup": {
            "business_purpose": "The zt_workflowgroup table represents a grouping or configuration entity for workflows, likely used to define, organize, and manage sets of workflow rules, templates, or processes within a project or system. It allows for categorization by type, project model, and project type, and includes metadata for status, exclusivity, and module enablement, supporting workflow management and customization.",
            "key_fields": [
                "id",
                "type",
                "projectModel",
                "projectType",
                "name",
                "code",
                "status",
                "main",
                "exclusive",
                "disabledModules",
                "vision",
                "createdBy",
                "createdDate",
                "editedBy",
                "editedDate",
                "deleted"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as a parent entity for workflow definitions, steps, or instances, with other tables referencing its id.",
                "Many-to-one: It may be grouped or categorized by higher-level entities such as workflow types or project models (as indicated by the type, projectModel, and projectType fields).",
                "Self-referencing: The main and exclusive fields suggest possible hierarchical or exclusive relationships among workflow groups."
            ],
            "business_operations": [
                "Creating and configuring new workflow groups for different project models or types.",
                "Enabling or disabling specific modules within a workflow group.",
                "Managing the status (e.g., activating, deactivating, or archiving) of workflow groups.",
                "Auditing creation and modification history for workflow groups.",
                "Filtering or selecting workflow groups based on type, project model, or status for use in workflow execution or reporting.",
                "Marking workflow groups as deleted (soft delete) for retention and recovery purposes."
            ]
        },
        "zt_workflowrule": {
            "business_purpose": "The zt_workflowrule table represents a set of rules used within a workflow system. Each record defines a specific rule that can be applied to workflow processes, such as validation, automation, or conditional logic. The rules can be of different types (system-defined, regular expression-based, or function-based), and are likely used to control or validate workflow steps or data.",
            "key_fields": [
                "id",
                "type",
                "name",
                "rule",
                "createdBy",
                "createdDate",
                "editedBy",
                "editedDate"
            ],
            "potential_relationships": [
                "One-to-many: This table could be referenced by workflow process or step tables, where multiple rules may be associated with a single workflow or step.",
                "Many-to-many: It could participate in a junction table to associate multiple rules with multiple workflow entities.",
                "Self-referencing: There could be hierarchical or dependency relationships between rules, though not explicitly defined here."
            ],
            "business_operations": [
                "Defining new workflow rules for process automation or validation.",
                "Editing existing rules to update workflow logic.",
                "Auditing rule creation and modification for compliance or troubleshooting.",
                "Applying rules during workflow execution to enforce business logic.",
                "Listing or searching rules for workflow configuration or management."
            ]
        },
        "zt_zoutput": {
            "business_purpose": "The zt_zoutput table appears to represent outputs or deliverables associated with a specific activity or process step. Each record defines an output item, including its name, content, status, and metadata about its creation and modification. The table is likely used to track, manage, and document the results or artifacts produced by activities within a business workflow or project.",
            "key_fields": [
                "id",
                "activity",
                "name",
                "content",
                "status",
                "createdBy",
                "createdDate",
                "editedBy",
                "editedDate",
                "deleted"
            ],
            "potential_relationships": [
                "Many-to-one: Each output is linked to a single activity (via the 'activity' field), suggesting that multiple outputs can be associated with one activity.",
                "Self-contained: The table includes fields for tracking creation and modification, indicating it may be referenced in audit or history tracking processes.",
                "Soft-delete: The 'deleted' field allows for logical deletion, supporting relationships with processes that require data retention or recovery."
            ],
            "business_operations": [
                "Creating and recording new outputs or deliverables for an activity.",
                "Editing or updating the details and content of an output.",
                "Tracking the status and history of outputs, including who created or modified them and when.",
                "Ordering outputs (using the 'order' field) for display or process sequencing.",
                "Soft-deleting outputs to retain historical data without physical removal.",
                "Filtering or reporting on outputs by activity, status, or creator."
            ]
        },
        "ztv_dayactions": {
            "business_purpose": "This table appears to represent a daily aggregation of actions or events, where each record logs the total number of actions that occurred on a specific day. It is likely used for tracking, reporting, or analyzing activity volume over time.",
            "key_fields": [
                "actions",
                "day"
            ],
            "potential_relationships": [
                "Could serve as a fact or summary table in a time-series analysis",
                "Might be referenced by reporting or analytics modules for trend analysis",
                "Could be joined with other tables containing more granular or categorized action data if such tables exist"
            ],
            "business_operations": [
                "Generating daily activity reports",
                "Analyzing trends in actions over time",
                "Monitoring system or user engagement on a daily basis",
                "Supporting dashboards or visualizations that display daily action counts"
            ]
        },
        "ztv_daybugopen": {
            "business_purpose": "This table represents a daily summary or record of the number of bugs that were opened on each specific day. It is likely used for tracking, reporting, or analyzing the volume of new bugs reported over time.",
            "key_fields": [
                "bugopen",
                "day"
            ],
            "potential_relationships": [
                "Could serve as a fact or summary table in reporting contexts, potentially relating to more detailed bug or event records by date, or being joined with other time-based metrics for trend analysis."
            ],
            "business_operations": [
                "Generating daily bug open trend reports",
                "Monitoring software quality or issue influx over time",
                "Supporting dashboards that visualize bug activity by day",
                "Triggering alerts or actions if the number of opened bugs exceeds certain thresholds on a given day"
            ]
        },
        "ztv_daybugresolve": {
            "business_purpose": "This table appears to track the number of bug resolutions that occur on a specific day. Each record represents the total count of bugs resolved (bugresolve) for a given date (day). It is likely used for reporting, monitoring, or analyzing bug resolution activity over time.",
            "key_fields": [
                "bugresolve",
                "day"
            ],
            "potential_relationships": [
                "Could serve as a summary or aggregation table related to detailed bug resolution records",
                "Might be linked to time-based reporting or analytics modules",
                "Could be referenced by dashboards or reporting tools for trend analysis"
            ],
            "business_operations": [
                "Generating daily bug resolution reports",
                "Analyzing trends in bug resolution over time",
                "Monitoring team or system performance in resolving bugs",
                "Supporting business decisions based on bug resolution metrics"
            ]
        },
        "ztv_dayeffort": {
            "business_purpose": "The ztv_dayeffort table is designed to record the amount of effort (likely in hours or another unit) expended on a particular day. It serves as a log or tracking mechanism for daily effort, which could be used for time tracking, productivity analysis, or resource management purposes.",
            "key_fields": [
                "consumed",
                "date"
            ],
            "potential_relationships": [
                "This table could serve as a detail or fact table in a time-tracking or effort-logging system, potentially relating to entities such as projects, tasks, or resources, but no such relationships are defined in the current structure."
            ],
            "business_operations": [
                "Recording daily effort values",
                "Querying effort consumed on specific dates",
                "Aggregating effort over time periods for reporting or analysis",
                "Auditing or reviewing historical effort data"
            ]
        },
        "ztv_daystoryopen": {
            "business_purpose": "This table appears to track the number of times a 'story' is opened or viewed on a daily basis. Each record represents the total count of story opens for a specific day, likely for reporting, analytics, or monitoring user engagement with stories over time.",
            "key_fields": [
                "storyopen",
                "day"
            ],
            "potential_relationships": [
                "Could serve as a fact or summary table in a reporting or analytics context, potentially relating to more detailed event or log tables (e.g., individual story open events) or to dimension tables (e.g., types of stories, if such context existed).",
                "May be joined with other date-based tables for time series analysis or trend reporting."
            ],
            "business_operations": [
                "Generating daily reports on story engagement or popularity.",
                "Analyzing trends in story opens over time.",
                "Monitoring daily activity for operational or business intelligence dashboards.",
                "Supporting data-driven decisions regarding content strategy based on user engagement."
            ]
        },
        "ztv_daytaskfinish": {
            "business_purpose": "This table records the number of tasks finished on a specific day. It is likely used to track daily task completion metrics, possibly for reporting, monitoring, or performance analysis purposes.",
            "key_fields": [
                "taskfinish",
                "day"
            ],
            "potential_relationships": [
                "Could serve as a fact or summary table in a reporting context, potentially relating to more detailed task or event records by date. It may be referenced by other tables that analyze or aggregate daily performance data."
            ],
            "business_operations": [
                "Generating daily reports on task completion",
                "Monitoring trends in task completion over time",
                "Analyzing productivity or operational throughput by day",
                "Supporting dashboards or visualizations of daily task metrics"
            ]
        },
        "ztv_daytaskopen": {
            "business_purpose": "This table appears to track the number of 'open tasks' (possibly unresolved or pending tasks) for each specific day. It is likely used for daily reporting, monitoring, or analytics related to task management or workflow processes.",
            "key_fields": [
                "taskopen",
                "day"
            ],
            "potential_relationships": [
                "Could serve as a fact or summary table in a reporting or analytics context, potentially relating to a more detailed task or event table via the 'day' field.",
                "Might be referenced by other tables that require daily task statistics or aggregates."
            ],
            "business_operations": [
                "Generating daily reports on open tasks.",
                "Monitoring trends in task backlog or workload over time.",
                "Supporting dashboards or visualizations that display daily task status.",
                "Triggering alerts or actions if the number of open tasks exceeds certain thresholds on a given day."
            ]
        },
        "ztv_dayuserlogin": {
            "business_purpose": "This table records daily login activity for individual user accounts. Each record represents a login event for a specific user on a specific day, allowing tracking of user engagement or activity over time.",
            "key_fields": [
                "userlogin",
                "day"
            ],
            "potential_relationships": [
                "One-to-many: Each unique userlogin value may be associated with multiple day entries, representing multiple days the user logged in.",
                "Many-to-one: Multiple records for the same day may exist, each for a different userlogin, indicating which users logged in on a given day."
            ],
            "business_operations": [
                "Tracking daily active users by counting distinct userlogin values per day.",
                "Analyzing user retention by checking login patterns over multiple days.",
                "Generating reports on user engagement and login frequency.",
                "Identifying trends in user activity over time."
            ]
        },
        "ztv_executionsummary": {
            "business_purpose": "The ztv_executionsummary table appears to represent a summary of execution metrics for a specific process, task, or project execution. It is designed to track estimated effort, actual effort consumed, remaining effort, the number of items or units involved, undone work, and the total real effort. This table is likely used for monitoring, reporting, and analyzing the progress and performance of executions within a business process, such as project management, task tracking, or operational workflows.",
            "key_fields": [
                "execution",
                "estimate",
                "consumed",
                "left",
                "number",
                "undone",
                "totalReal"
            ],
            "potential_relationships": [
                "One-to-one or one-to-many relationship with a table representing executions or processes (using the 'execution' field as a reference).",
                "Aggregation or summary relationship, where this table summarizes detailed records from another table."
            ],
            "business_operations": [
                "Tracking and updating execution progress and performance metrics.",
                "Generating reports on estimated vs. actual effort and remaining work.",
                "Analyzing efficiency and identifying undone or outstanding work.",
                "Supporting decision-making for resource allocation and project management."
            ]
        },
        "ztv_normalproduct": {
            "business_purpose": "The ztv_normalproduct table represents a 'product' entity within a project or program management context, likely for software or product development lifecycle tracking. It stores detailed information about each product, including its association with a program, status, access control, responsible roles, and aggregated counts of related work items such as epics, requirements, stories, bugs, plans, and releases. The table is designed to support tracking, reporting, and management of products and their progress through various stages of development and release.",
            "key_fields": [
                "id",
                "program",
                "name",
                "code",
                "status",
                "type",
                "PO",
                "QD",
                "RD",
                "workflowGroup",
                "acl",
                "draftEpics",
                "activeEpics",
                "finishedEpics",
                "totalEpics",
                "draftRequirements",
                "activeRequirements",
                "totalRequirements",
                "draftStories",
                "activeStories",
                "totalStories",
                "unresolvedBugs",
                "closedBugs",
                "fixedBugs",
                "totalBugs",
                "plans",
                "releases",
                "createdBy",
                "createdDate",
                "deleted"
            ],
            "potential_relationships": [
                "Belongs to a program (via 'program' field, likely referencing a program entity)",
                "May be associated with workflow groups (via 'workflowGroup')",
                "May have relationships to users or roles (PO, QD, RD, createdBy, reviewer), though these are stored as text/varchar and not as foreign keys",
                "Aggregates or summarizes related work items such as epics, requirements, stories, bugs, plans, and releases (as indicated by the count fields), suggesting one-to-many relationships with those entities if they exist"
            ],
            "business_operations": [
                "Creating and registering new products within a program",
                "Tracking and updating product status, type, and lifecycle stage",
                "Assigning and managing responsible roles (PO, QD, RD, workflowGroup)",
                "Controlling access and permissions to product information (via acl, groups, whitelist)",
                "Aggregating and reporting on progress and quality metrics (epics, requirements, stories, bugs, plans, releases)",
                "Auditing product creation, updates, and closure (createdBy, createdDate, closedDate, deleted)",
                "Managing product documentation and descriptions"
            ]
        },
        "ztv_productbugs": {
            "business_purpose": "This table represents aggregated bug tracking statistics for different products. Each record summarizes the total number of bugs, resolutions, and serious bugs associated with a specific product. It is likely used for reporting, monitoring, or dashboarding the quality and issue status of products.",
            "key_fields": [
                "product",
                "bugs",
                "resolutions",
                "seriousBugs"
            ],
            "potential_relationships": [
                "One-to-many: Each product (identified by the 'product' field) may have multiple bug records in a more detailed bug table, but here it is summarized per product.",
                "One-to-one or many-to-one: This table may relate to a product master table via the 'product' field, serving as a foreign key reference to a product entity."
            ],
            "business_operations": [
                "Generating product quality reports",
                "Monitoring bug resolution rates for products",
                "Identifying products with high numbers of serious bugs",
                "Supporting dashboards or KPIs for product management or QA teams"
            ]
        },
        "ztv_productstories": {
            "business_purpose": "This table appears to track the association between products and their related 'stories', likely representing requirements, features, or tasks linked to each product. It also records a count or value of 'undone' stories, which may indicate outstanding or incomplete work items for each product.",
            "key_fields": [
                "product",
                "stories",
                "undone"
            ],
            "potential_relationships": [
                "One-to-many or many-to-one relationship between products and stories, where each row aggregates data about stories for a specific product",
                "Possible aggregation or summary relationship, where this table summarizes the number of stories and undone stories per product"
            ],
            "business_operations": [
                "Reporting on the number of stories associated with each product",
                "Tracking progress or completion status of stories for each product",
                "Generating dashboards or summaries of outstanding work per product",
                "Supporting project management or product development tracking by monitoring undone stories"
            ]
        },
        "ztv_projectbugs": {
            "business_purpose": "This table appears to represent aggregated bug tracking metrics for specific executions or runs of a project, likely within a software development or quality assurance context. Each record summarizes the number of bugs, resolutions, and serious bugs associated with a particular execution instance.",
            "key_fields": [
                "execution",
                "bugs",
                "resolutions",
                "seriousBugs"
            ],
            "potential_relationships": [
                "One-to-many or many-to-one relationship with an 'execution' entity, where each execution has associated bug statistics.",
                "Could serve as a summary or reporting table linked to more detailed bug or execution records."
            ],
            "business_operations": [
                "Generating reports on bug counts and severity for specific executions.",
                "Monitoring quality metrics and tracking resolution rates over time.",
                "Supporting dashboards or analytics for project health and progress.",
                "Auditing or compliance checks related to software quality."
            ]
        },
        "ztv_projectstories": {
            "business_purpose": "This table appears to track the association between an 'execution' (likely representing a project phase, sprint, or work session) and 'stories' (which could represent work items, tasks, or user stories) within a project management or tracking context. The 'undone' field likely records the number or status of stories that are not yet completed for a given execution.",
            "key_fields": [
                "execution",
                "stories",
                "undone"
            ],
            "potential_relationships": [
                "Many-to-one or many-to-many relationships between executions and stories, where each record links a specific execution to a set of stories and tracks their completion status.",
                "Possible aggregation or reporting relationships, where this table summarizes the status of stories within executions."
            ],
            "business_operations": [
                "Tracking the progress of stories within a specific execution.",
                "Reporting on the number of undone stories for a given execution.",
                "Analyzing project or sprint completion rates based on undone stories.",
                "Updating the status of stories as work progresses within an execution."
            ]
        },
        "ztv_projectsummary": {
            "business_purpose": "The ztv_projectsummary table represents a summary of project progress and resource utilization. It is designed to track key metrics for individual projects, such as estimated effort, actual effort consumed, remaining effort, the number of items or tasks, undone work, and total realized effort. This table is likely used for project management, monitoring, and reporting purposes, providing a high-level overview of project status and performance.",
            "key_fields": [
                "project",
                "estimate",
                "consumed",
                "left",
                "number",
                "undone",
                "totalReal"
            ],
            "potential_relationships": [
                "One-to-one or one-to-many relationship with a project details table (project as a reference key)",
                "Aggregated relationship with lower-level task or work item tables (summarizing their data)",
                "Potential use as a reporting or summary table for dashboards or analytics"
            ],
            "business_operations": [
                "Project progress tracking and reporting",
                "Resource and effort estimation versus actual analysis",
                "Monitoring undone or outstanding work",
                "Generating project summary reports for management",
                "Supporting project status dashboards"
            ]
        },
        "ztv_projectteams": {
            "business_purpose": "The ztv_projectteams table appears to represent the association between two entities: 'execution' and 'teams'. It likely serves as a mapping or junction table to link specific executions (possibly projects, tasks, or initiatives) with teams assigned to them. This structure is commonly used to manage many-to-many relationships, where multiple teams can be associated with multiple executions.",
            "key_fields": [
                "execution",
                "teams"
            ],
            "potential_relationships": [
                "Many-to-many relationship between executions and teams",
                "Acts as a bridge or mapping table connecting two distinct entities"
            ],
            "business_operations": [
                "Assigning teams to specific executions",
                "Querying which teams are involved in a particular execution",
                "Listing all executions a team is participating in",
                "Managing or updating team assignments for executions"
            ]
        }
    },
    "relationships": [
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_bug",
            "to_column": "story",
            "condition": "tmp_case_getDevStories.story = zt_bug.story",
            "confidence": "high",
            "reasoning": "Both tables have a column named 'story' with the same data type (mediumint unsigned). In tmp_case_getDevStories, 'story' is the key field representing a unique story identifier, and in zt_bug, 'story' links each bug to a story. The business logic suggests that tmp_case_getDevStories aggregates case counts per story, while zt_bug tracks bugs associated with stories. This is a common pattern where a summary/aggregation table is related to a detail/transaction table via a shared key.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_bug t2 ON t1.story = t2.story LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_case",
            "to_column": "story",
            "condition": "tmp_case_getDevStories.story = zt_case.story",
            "confidence": "high",
            "reasoning": "Both tables have a column named 'story' with the same data type (mediumint unsigned). In tmp_case_getDevStories, 'story' represents a unique story identifier associated with a count of cases, while in zt_case, 'story' links each test case to a specific story. The business logic suggests that tmp_case_getDevStories is an aggregation of case counts per story, which directly relates to the individual cases in zt_case. This is a common pattern where a summary table is joined to a detail table on the grouping key.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_case t2 ON t1.story = t2.story LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_projectstory",
            "to_column": "story",
            "condition": "tmp_case_getDevStories.story = zt_projectstory.story",
            "confidence": "high",
            "reasoning": "Both tables have a 'story' column of the same data type (mediumint unsigned) and similar naming. The business purpose of tmp_case_getDevStories is to aggregate case counts per story, while zt_projectstory associates stories with projects. It is logical to join these tables on 'story' to analyze, for example, how many cases are associated with each story in the context of its project assignments.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_projectstory t2 ON t1.story = t2.story LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_storyreview",
            "to_column": "story",
            "condition": "tmp_case_getDevStories.story = zt_storyreview.story",
            "confidence": "high",
            "reasoning": "Both tables have a 'story' column with compatible data types (mediumint/mediumint unsigned) and naming conventions. The business logic suggests that 'tmp_case_getDevStories' aggregates case counts per story, while 'zt_storyreview' records reviews for each story (and version). It is logical to join these tables on 'story' to, for example, analyze review activity in relation to case counts per story.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_storyreview t2 ON t1.story = t2.story LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_storyspec",
            "to_column": "story",
            "condition": "tmp_case_getDevStories.story = zt_storyspec.story",
            "confidence": "high",
            "reasoning": "Both tables have a 'story' field with compatible data types (mediumint/mediumint unsigned) and naming conventions. The business logic suggests that 'tmp_case_getDevStories' aggregates case counts per story, while 'zt_storyspec' stores specifications for each story (potentially with multiple versions). It is logical to join these tables on 'story' to enrich case count summaries with story specification details or to analyze case distribution across different stories.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_storyspec t2 ON t1.story = t2.story LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_story",
            "to_column": "id",
            "condition": "tmp_case_getDevStories.story = zt_story.id",
            "confidence": "high",
            "reasoning": "The 'story' field in tmp_case_getDevStories is a mediumint unsigned and is likely referencing the 'id' field in zt_story, which is also a mediumint unsigned and serves as the primary key. The business purpose of tmp_case_getDevStories is to aggregate case counts per story, and zt_story contains the master list of stories. This is a common pattern where a summary or temporary table references the main entity table by its primary key.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_story t2 ON t1.story = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_task",
            "to_column": "story",
            "condition": "tmp_case_getDevStories.story = zt_task.story",
            "confidence": "high",
            "reasoning": "Both tables have a column named 'story' with the same data type (mediumint unsigned), and the business logic suggests that 'tmp_case_getDevStories' aggregates case counts per story, while 'zt_task' links tasks to stories. This is a common pattern where a summary/aggregation table references a detail table via a shared key. The 'story' field in both tables is likely intended to represent the same entity (a story or requirement), making this a logical join for reporting or analytics.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_task t2 ON t1.story = t2.story LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_action",
            "to_column": "project",
            "condition": "tmp_task_getProjectTasks.project = zt_action.project",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project' field of the same data type (mediumint unsigned), and both use it to reference projects. In tmp_task_getProjectTasks, 'project' groups resource consumption by project, while in zt_action, 'project' logs actions related to a project. This suggests a logical relationship where actions can be joined to resource consumption by project, supporting reporting or auditing at the project level.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_action t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 67,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_build",
            "to_column": "project",
            "condition": "tmp_task_getProjectTasks.project = zt_build.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned) and naming convention, and both fields represent a project identifier. The business purposes align: tmp_task_getProjectTasks aggregates resource consumption per project, while zt_build records builds associated with projects. This suggests a logical relationship where tasks/resources consumed (from tmp_task_getProjectTasks) can be associated with builds (from zt_build) under the same project.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_build t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_bug",
            "to_column": "project",
            "condition": "tmp_task_getProjectTasks.project = zt_bug.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and both use it to reference a project context. In tmp_task_getProjectTasks, 'project' groups resource consumption by project, while in zt_bug, 'project' associates bugs with a project. This is a standard pattern for relating project-level data across tables. Although no explicit foreign key is defined, the naming, type, and business logic strongly suggest a relationship.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_bug t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_effort",
            "to_column": "project",
            "condition": "tmp_task_getProjectTasks.project = zt_effort.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned) and similar naming. The business purposes align: tmp_task_getProjectTasks aggregates or stages effort data per project, while zt_effort records individual effort logs per project. This suggests that tmp_task_getProjectTasks.project references the same project as zt_effort.project, enabling aggregation or reporting of effort data at the project level.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_effort t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_projectcase",
            "to_column": "project",
            "condition": "tmp_task_getProjectTasks.project = zt_projectcase.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned) and naming convention, and both use it as a key field. The business purposes align: tmp_task_getProjectTasks aggregates resource consumption per project, while zt_projectcase associates test cases with projects. It is logical to join these tables on 'project' to analyze resource consumption in the context of project test cases.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_projectcase t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_projectproduct",
            "to_column": "project",
            "condition": "tmp_task_getProjectTasks.project = zt_projectproduct.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned) and naming convention. The business purposes align: tmp_task_getProjectTasks aggregates resource consumption per project, while zt_projectproduct associates projects with products and planning details. It is logical to join these tables on 'project' to analyze resource consumption in the context of project-product associations.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_projectproduct t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_project",
            "to_column": "id",
            "condition": "tmp_task_getProjectTasks.project = zt_project.id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of compatible types (mediumint unsigned), and the 'id' field in zt_project is the primary key. The business purpose of tmp_task_getProjectTasks is to aggregate or stage task consumption data per project, and the 'project' field is likely a foreign key referencing the main project entity in zt_project. This is a common pattern in project management systems.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_project t2 ON t1.project = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_projectstory",
            "to_column": "project",
            "condition": "tmp_task_getProjectTasks.project = zt_projectstory.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned) and naming convention. The business purposes align: tmp_task_getProjectTasks aggregates resource consumption per project, while zt_projectstory associates stories with projects. It is logical to join these tables on 'project' to analyze resource consumption in the context of project stories.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_projectstory t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_task",
            "to_column": "project",
            "condition": "tmp_task_getProjectTasks.project = zt_task.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned) and naming convention, indicating that they refer to the same project entity. The business purpose of tmp_task_getProjectTasks is to aggregate or stage task data by project, while zt_task contains detailed task records, each associated with a project. This suggests a logical relationship where tmp_task_getProjectTasks summarizes or references tasks from zt_task at the project level.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_task t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_testtask",
            "to_column": "project",
            "condition": "tmp_task_getProjectTasks.project = zt_testtask.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and both use it to reference a project context. The tmp_task_getProjectTasks table aggregates or tracks resource consumption per project, while zt_testtask contains test tasks associated with projects. It is logical to join these tables on the 'project' field to analyze or report on test tasks and their associated resource consumption at the project level.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_testtask t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_team",
            "to_column": "root",
            "condition": "tmp_task_getProjectTasks.project = zt_team.root AND zt_team.type = 'project'",
            "confidence": "high",
            "reasoning": "Both tables use a mediumint unsigned field ('project' in tmp_task_getProjectTasks and 'root' in zt_team) to reference a project entity. The business purpose of tmp_task_getProjectTasks is to aggregate resource consumption per project, while zt_team tracks team members assigned to projects, tasks, or executions. The 'type' field in zt_team distinguishes the context of 'root'; when type = 'project', 'root' refers to a project. This suggests a logical and business-driven relationship where project-level resource consumption can be joined with team assignments for the same project.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_team t2 ON t1.project = t2.root AND t2.type = 'project' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_weeklyreport",
            "to_column": "project",
            "condition": "tmp_task_getProjectTasks.project = zt_weeklyreport.project",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project' field of the same data type (mediumint unsigned) and naming convention, which strongly suggests they refer to the same project entity. The business purposes align: tmp_task_getProjectTasks aggregates resource consumption per project, while zt_weeklyreport tracks weekly project performance. It is common in project management systems to relate task/resource data to project-level reporting via a shared project identifier.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_weeklyreport t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "ztv_projectsummary",
            "to_column": "project",
            "condition": "tmp_task_getProjectTasks.project = ztv_projectsummary.project",
            "confidence": "high",
            "reasoning": "Both tables share a column named 'project' with identical data types (mediumint unsigned). The business purposes align: tmp_task_getProjectTasks aggregates or stages task-level consumption data per project, while ztv_projectsummary summarizes project-level metrics, including consumed effort. It is a common pattern to join detailed or temporary task data to a project summary table using the project identifier. This relationship enables analysis such as comparing detailed task consumption with project-level summaries.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN ztv_projectsummary t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_acl",
            "from_column": "['objectType', 'objectID']",
            "to_table": "zt_action",
            "to_column": "['objectType', 'objectID']",
            "condition": "zt_acl.objectType = zt_action.objectType AND zt_acl.objectID = zt_action.objectID",
            "confidence": "high",
            "reasoning": "Both tables use the fields 'objectType' and 'objectID' to reference business objects. In zt_acl, these fields define which object an account has access to; in zt_action, they define which object an action was performed on. The data types are compatible (char/varchar(30) for objectType, mediumint for objectID), and the business logic aligns: permissions (zt_acl) are likely to be relevant to actions (zt_action) performed on the same objects. This is a common pattern in systems with ACLs and audit logs.",
            "test_sql": "SELECT COUNT(*) FROM zt_acl t1 JOIN zt_action t2 ON t1.objectType = t2.objectType AND t1.objectID = t2.objectID LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_acl",
            "from_column": "account",
            "to_table": "zt_effort",
            "to_column": "account",
            "condition": "zt_acl.account = zt_effort.account",
            "confidence": "high",
            "reasoning": "Both tables use an 'account' field of similar type and length to represent a user or account identifier. It is logical that access control (zt_acl) and effort logging (zt_effort) would both reference the same account entities, allowing for queries such as 'which efforts are performed by accounts with certain permissions.'",
            "test_sql": "SELECT COUNT(*) FROM zt_acl t1 JOIN zt_effort t2 ON t1.account = t2.account LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_acl",
            "from_column": "account",
            "to_table": "zt_projectadmin",
            "to_column": "account",
            "condition": "zt_acl.account = zt_projectadmin.account",
            "confidence": "high",
            "reasoning": "Both tables use the 'account' field with the same data type and length (char(30)), and both represent user accounts. In zt_acl, 'account' is the subject of access control, while in zt_projectadmin, 'account' is the subject of administrative assignment. It is logical to join on 'account' to analyze or enforce permissions and administrative rights for the same user.",
            "test_sql": "SELECT COUNT(*) FROM zt_acl t1 JOIN zt_projectadmin t2 ON t1.account = t2.account LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_acl",
            "from_column": "['objectType', 'objectID']",
            "to_table": "zt_searchindex",
            "to_column": "['objectType', 'objectID']",
            "condition": "zt_acl.objectType = zt_searchindex.objectType AND zt_acl.objectID = zt_searchindex.objectID",
            "confidence": "high",
            "reasoning": "Both tables use the fields objectType and objectID to reference business objects. In zt_acl, these fields specify which object an account has access to; in zt_searchindex, they specify which object is being indexed for search. The matching names, data types, and business purposes strongly suggest that these fields refer to the same set of business objects, making this a logical join for determining which indexed objects a user has access to, or which ACLs apply to a search result.",
            "test_sql": "SELECT COUNT(*) FROM zt_acl t1 JOIN zt_searchindex t2 ON t1.objectType = t2.objectType AND t1.objectID = t2.objectID LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_acl",
            "from_column": "account",
            "to_table": "zt_team",
            "to_column": "account",
            "condition": "zt_acl.account = zt_team.account",
            "confidence": "high",
            "reasoning": "Both tables use the 'account' field with the same data type and length (char(30)), and both represent user or account identifiers. In zt_acl, 'account' is the subject of the permission, while in zt_team, 'account' is the team member assigned to a project/task/execution. It is logical to join these tables on 'account' to analyze permissions of team members or to correlate team assignments with access control.",
            "test_sql": "SELECT COUNT(*) FROM zt_acl t1 JOIN zt_team t2 ON t1.account = t2.account LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_acl",
            "from_column": "account",
            "to_table": "zt_usergroup",
            "to_column": "account",
            "condition": "zt_acl.account = zt_usergroup.account",
            "confidence": "high",
            "reasoning": "Both tables use the 'account' field as a key identifier for users. In zt_acl, 'account' specifies which user the ACL entry applies to, while in zt_usergroup, 'account' identifies the user in the user-group association. This is a common pattern for linking user permissions (ACL) to group memberships, enabling queries such as 'which groups does a user with certain ACL permissions belong to?' or 'what permissions do members of a group have?'. The data types and naming conventions match exactly.",
            "test_sql": "SELECT COUNT(*) FROM zt_acl t1 JOIN zt_usergroup t2 ON t1.account = t2.account LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_acl",
            "from_column": "account",
            "to_table": "zt_userview",
            "to_column": "account",
            "condition": "zt_acl.account = zt_userview.account",
            "confidence": "high",
            "reasoning": "Both tables use the 'account' field as a char(30) NOT NULL identifier for a user. In zt_acl, 'account' specifies which user the ACL entry applies to; in zt_userview, 'account' specifies which user's view configuration is being stored. It is logical to join these tables on 'account' to correlate a user's access control entries with their personalized view settings. The data types and naming conventions match exactly, and this is a common pattern in access control and user configuration systems.",
            "test_sql": "SELECT COUNT(*) FROM zt_acl t1 JOIN zt_userview t2 ON t1.account = t2.account LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_acl",
            "from_column": "account",
            "to_table": "zt_user",
            "to_column": "account",
            "condition": "zt_acl.account = zt_user.account",
            "confidence": "high",
            "reasoning": "Both tables have an 'account' field of the same data type and length (char(30)), and the business logic suggests that zt_acl assigns permissions to user accounts, which are uniquely defined in zt_user. This is a common pattern where an ACL references user accounts by a unique identifier.",
            "test_sql": "SELECT COUNT(*) FROM zt_acl t1 JOIN zt_user t2 ON t1.account = t2.account LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectType, objectID, actor, action, date",
            "to_table": "zt_actionrecent",
            "to_column": "objectType, objectID, actor, action, date",
            "condition": "zt_action.objectType = zt_actionrecent.objectType AND zt_action.objectID = zt_actionrecent.objectID AND zt_action.actor = zt_actionrecent.actor AND zt_action.action = zt_actionrecent.action AND zt_action.date = zt_actionrecent.date",
            "confidence": "high",
            "reasoning": "Both tables have nearly identical schemas and business purposes, tracking actions on business objects. The most likely relationship is that zt_actionrecent is a subset or a denormalized view of recent records from zt_action. Matching on objectType, objectID, actor, action, and date would uniquely identify the same action in both tables, supporting business logic for recent activity feeds.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_actionrecent t2 ON t1.objectType = t2.objectType AND t1.objectID = t2.objectID AND t1.actor = t2.actor AND t1.action = t2.action AND t1.date = t2.date LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectID",
            "to_table": "zt_case",
            "to_column": "id",
            "condition": "zt_action.objectType = 'case' AND zt_action.objectID = zt_case.id",
            "confidence": "high",
            "reasoning": "The zt_action table is designed to log actions on various business objects, with objectType indicating the type of object and objectID storing the object's ID. Since zt_case.id is the primary key for test cases, and 'case' is a likely value for objectType, this join would retrieve all actions performed on test cases.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_case t2 ON t1.objectType = 'case' AND t1.objectID = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 22,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectID",
            "to_table": "zt_bug",
            "to_column": "id",
            "condition": "zt_action.objectType = 'bug' AND zt_action.objectID = zt_bug.id",
            "confidence": "high",
            "reasoning": "The zt_action table is designed to log actions on various business objects, with objectType indicating the type of object and objectID storing the object's ID. Since zt_bug's primary key is id, and 'bug' is a likely value for objectType, this is a standard pattern for logging actions on bugs. Data types are compatible (objectID is mediumint unsigned, id is mediumint).",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_bug t2 ON t1.objectType = 'bug' AND t1.objectID = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "id",
            "to_table": "zt_history",
            "to_column": "action",
            "condition": "zt_action.id = zt_history.action",
            "confidence": "high",
            "reasoning": "The zt_history table has an 'action' column (mediumint unsigned, indexed) that appears to reference the 'id' column (primary key) of zt_action. The business logic supports this: each action (zt_action) can have multiple field-level changes (zt_history), and each history record is linked to the action that triggered it. This is a classic one-to-many (parent-child) relationship, commonly used for audit trails and change tracking.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_history t2 ON t1.id = t2.action LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 50,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "['objectType', 'objectID']",
            "to_table": "zt_effort",
            "to_column": "['objectType', 'objectID']",
            "condition": "zt_action.objectType = zt_effort.objectType AND zt_action.objectID = zt_effort.objectID",
            "confidence": "high",
            "reasoning": "Both tables use the same naming and data types for objectType (varchar(30)) and objectID (mediumint unsigned), and both fields are used to reference business objects (such as tasks, bugs, requirements, etc.). The business purpose of both tables is to track activities or efforts related to these objects. This suggests a strong logical relationship where actions and efforts are both associated with the same business object, enabling meaningful joins for reporting or auditing.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_effort t2 ON t1.objectType = t2.objectType AND t1.objectID = t2.objectID LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 11,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectType, objectID",
            "to_table": "zt_productplan",
            "to_column": "id",
            "condition": "zt_action.objectType = 'productplan' AND zt_action.objectID = zt_productplan.id",
            "confidence": "high",
            "reasoning": "The zt_action table is designed to log actions on various business objects, identified by objectType and objectID. If objectType is 'productplan', then objectID should reference the id of a product plan in zt_productplan. This is a common audit log pattern, and the naming and data types are compatible.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_productplan t2 ON t1.objectType = 'productplan' AND t1.objectID = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectID",
            "to_table": "zt_product",
            "to_column": "id",
            "condition": "zt_action.objectType = 'product' AND zt_action.objectID = zt_product.id",
            "confidence": "high",
            "reasoning": "The zt_action table is designed to log actions on various business objects, with objectType indicating the type of object and objectID storing the object's unique identifier. The zt_product table's primary key is id. It is a common pattern in audit/action log tables to reference the target object by type and ID. Therefore, when objectType = 'product', objectID should match zt_product.id, representing actions performed on products.",
            "test_sql": "SELECT COUNT(*) FROM zt_action a JOIN zt_product p ON a.objectType = 'product' AND a.objectID = p.id LIMIT 1;",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_projectstory",
            "to_column": "project",
            "condition": "zt_action.project = zt_projectstory.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and both use it to reference a project context. In zt_action, 'project' indicates the project associated with an action, while in zt_projectstory, 'project' is part of the primary key and links stories to projects. This suggests a logical relationship where actions can be joined to project-story associations via the project they reference.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_projectstory t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 268,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectType, objectID, vision",
            "to_table": "zt_searchindex",
            "to_column": "objectType, objectID, vision",
            "condition": "zt_action.objectType = zt_searchindex.objectType AND zt_action.objectID = zt_searchindex.objectID AND zt_action.vision = zt_searchindex.vision",
            "confidence": "high",
            "reasoning": "Both tables use the fields objectType and objectID (and vision) to reference business objects in a polymorphic way. zt_action logs actions performed on these objects, while zt_searchindex indexes their searchable content. The matching field names, types, and business purposes strongly suggest that actions are performed on the same objects that are indexed for search, and the vision field further scopes the context. This is a common pattern in systems with audit trails and search indexes.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_searchindex t2 ON t1.objectType = t2.objectType AND t1.objectID = t2.objectID AND t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 90,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_project",
            "to_column": "id",
            "condition": "zt_action.project = zt_project.id",
            "confidence": "high",
            "reasoning": "The 'project' field in zt_action is a mediumint unsigned and is indexed, matching the primary key 'id' in zt_project (also mediumint unsigned, auto_increment). The business logic of zt_action indicates that actions are logged against specific projects, and the 'project' field is the most direct way to associate an action with a project record. This is a common pattern in audit/activity log tables.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_project t2 ON t1.project = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 67,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectID",
            "to_table": "zt_story",
            "to_column": "id",
            "condition": "zt_action.objectType = 'story' AND zt_action.objectID = zt_story.id",
            "confidence": "high",
            "reasoning": "The zt_action table is designed to log actions on various business objects, with the objectType field indicating the type of object and objectID referencing the object's primary key. Since zt_story's primary key is id, and 'story' is a likely value for objectType, it is logical that actions related to stories would have objectType = 'story' and objectID = zt_story.id. This is a common audit log pattern.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_story t2 ON t1.objectType = 'story' AND t1.objectID = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 20,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectType, objectID",
            "to_table": "zt_testtask",
            "to_column": "id",
            "condition": "zt_action.objectType = 'testtask' AND zt_action.objectID = zt_testtask.id",
            "confidence": "high",
            "reasoning": "The zt_action table is designed to log actions on various business objects, with objectType indicating the type of object and objectID referencing the object's primary key. The zt_testtask table's primary key is id, and its business purpose is to represent test tasks. It is logical and common in audit log designs for actions on test tasks to be recorded in zt_action with objectType = 'testtask' and objectID = zt_testtask.id.",
            "test_sql": "SELECT COUNT(*) FROM zt_action a JOIN zt_testtask t ON a.objectType = 'testtask' AND a.objectID = t.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectID",
            "to_table": "zt_task",
            "to_column": "id",
            "condition": "zt_action.objectType = 'task' AND zt_action.objectID = zt_task.id",
            "confidence": "high",
            "reasoning": "The zt_action table is designed to log actions on various business objects, with objectType indicating the type of object and objectID storing the object's ID. Since zt_task.id is the primary key for tasks, and 'task' is a likely value for objectType, this suggests a direct relationship where actions are logged for specific tasks.",
            "test_sql": "SELECT COUNT(*) FROM zt_action a JOIN zt_task t ON a.objectType = 'task' AND a.objectID = t.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "actor",
            "to_table": "zt_user",
            "to_column": "account",
            "condition": "zt_action.actor = zt_user.account",
            "confidence": "high",
            "reasoning": "The 'actor' field in zt_action is a varchar(100) and represents the user or system entity performing the action. The 'account' field in zt_user is a char(30) and is unique, representing the user's login or identifier. It is a common pattern for audit/action tables to reference users by their account or username. The data types are compatible (both string types), and the business logic aligns: actions are performed by users, and users are uniquely identified by their account.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_user t2 ON t1.actor = t2.account LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 23,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_weeklyreport",
            "to_column": "project",
            "condition": "zt_action.project = zt_weeklyreport.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and both fields represent a project entity. In zt_action, 'project' identifies the project associated with an action, while in zt_weeklyreport, 'project' identifies the project for which the weekly report is generated. This suggests a logical and business relationship where actions can be linked to the weekly reports of the same project.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_weeklyreport t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 67,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "execution",
            "to_table": "ztv_executionsummary",
            "to_column": "execution",
            "condition": "zt_action.execution = ztv_executionsummary.execution",
            "confidence": "high",
            "reasoning": "Both tables have a field named 'execution' with the same data type (mediumint unsigned). In zt_action, 'execution' represents the execution context for an action, while in ztv_executionsummary, 'execution' is the primary identifier for the summary metrics. It is logical to infer that actions performed within a specific execution context (zt_action.execution) can be related to the summary of that execution (ztv_executionsummary.execution). This is a common pattern in audit/activity log tables referencing summary or master records.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN ztv_executionsummary t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 54,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "execution",
            "to_table": "ztv_projectbugs",
            "to_column": "execution",
            "condition": "zt_action.execution = ztv_projectbugs.execution",
            "confidence": "high",
            "reasoning": "Both tables contain an 'execution' field of the same data type (mediumint unsigned), and both use it in the context of project or process tracking. In zt_action, 'execution' identifies the execution context for an action, while in ztv_projectbugs, it aggregates bug statistics for a specific execution. This suggests a logical and likely business relationship where actions can be joined to bug statistics for the same execution instance.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN ztv_projectbugs t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 54,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "execution",
            "to_table": "ztv_projectstories",
            "to_column": "execution",
            "condition": "zt_action.execution = ztv_projectstories.execution",
            "confidence": "high",
            "reasoning": "Both tables contain an 'execution' field of the same data type (mediumint unsigned), and the business purposes suggest that 'execution' represents a project phase, sprint, or work session. In zt_action, actions are logged against an execution, while in ztv_projectstories, stories are tracked per execution. This makes it highly likely that actions can be joined to the stories of the same execution for reporting or analysis.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN ztv_projectstories t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 54,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectID",
            "to_table": "ztv_normalproduct",
            "to_column": "id",
            "condition": "zt_action.objectType = 'product' AND zt_action.objectID = ztv_normalproduct.id",
            "confidence": "high",
            "reasoning": "The zt_action table is designed to log actions on various business objects, with objectType indicating the type of object and objectID storing the object's ID. The ztv_normalproduct table represents products, with id as its primary key. It is a common pattern for an action log to reference the primary key of the entity it is tracking. The data types (mediumint unsigned) are compatible, and the business logic aligns: actions on products would be logged with objectType = 'product' and objectID = ztv_normalproduct.id.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN ztv_normalproduct t2 ON t1.objectType = 'product' AND t1.objectID = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "ztv_projectsummary",
            "to_column": "project",
            "condition": "zt_action.project = ztv_projectsummary.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and the business logic aligns: zt_action logs actions related to projects, while ztv_projectsummary summarizes project metrics. It is logical to join actions performed on a project with its summary data for reporting, auditing, or analytics.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN ztv_projectsummary t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 67,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "execution",
            "to_table": "ztv_projectteams",
            "to_column": "execution",
            "condition": "zt_action.execution = ztv_projectteams.execution",
            "confidence": "high",
            "reasoning": "Both tables contain an 'execution' field of the same data type (mediumint unsigned). In zt_action, 'execution' represents the execution context of an action, while in ztv_projectteams, it represents the execution entity associated with teams. It is logical to infer that actions performed within a specific execution context can be related to the teams assigned to that execution. This is a common business logic pattern where actions are tracked per execution, and teams are mapped to executions.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN ztv_projectteams t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 55,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_actionrecent",
            "from_column": "actor",
            "to_table": "zt_user",
            "to_column": "account",
            "condition": "zt_actionrecent.actor = zt_user.account",
            "confidence": "high",
            "reasoning": "The 'actor' field in zt_actionrecent represents the user or process that performed an action. In zt_user, 'account' is the unique identifier for a user. Both are varchar/char fields of similar length, and the business logic of tracking which user performed an action aligns with joining these fields. This is a common audit log pattern.",
            "test_sql": "SELECT COUNT(*) FROM zt_actionrecent t1 JOIN zt_user t2 ON t1.actor = t2.account LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_activity",
            "from_column": "process",
            "to_table": "zt_process",
            "to_column": "id",
            "condition": "zt_activity.process = zt_process.id",
            "confidence": "high",
            "reasoning": "The 'process' field in 'zt_activity' is a mediumint that matches the type and likely business meaning of the 'id' field in 'zt_process'. The naming convention and business logic both suggest that each activity belongs to a process, and the 'process' field in 'zt_activity' is intended to reference the primary key of 'zt_process'. This is a common foreign key pattern in workflow and process management systems.",
            "test_sql": "SELECT COUNT(*) FROM zt_activity t1 JOIN zt_process t2 ON t1.process = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 320,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_activity",
            "from_column": "id",
            "to_table": "zt_zoutput",
            "to_column": "activity",
            "condition": "zt_activity.id = zt_zoutput.activity",
            "confidence": "high",
            "reasoning": "The 'activity' field in zt_zoutput is a mediumint that matches the type and likely purpose of the 'id' field in zt_activity. The business logic and naming conventions strongly suggest that each output (zt_zoutput) is associated with a specific activity (zt_activity), forming a one-to-many relationship. This is a common pattern where outputs or deliverables are linked to the activities that produce them.",
            "test_sql": "SELECT COUNT(*) FROM zt_activity t1 JOIN zt_zoutput t2 ON t1.id = t2.activity LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 490,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_ai_miniprogram",
            "from_column": "id",
            "to_table": "zt_ai_miniprogramfield",
            "to_column": "appID",
            "condition": "zt_ai_miniprogram.id = zt_ai_miniprogramfield.appID",
            "confidence": "high",
            "reasoning": "The zt_ai_miniprogramfield table contains an appID column of the same type as the id column in zt_ai_miniprogram. The business logic and naming convention strongly suggest that appID is intended to reference the id of a mini-program, establishing a one-to-many relationship where each mini-program can have multiple associated fields. This is a common database design pattern for associating form fields with a parent application or entity.",
            "test_sql": "SELECT COUNT(*) FROM zt_ai_miniprogram t1 JOIN zt_ai_miniprogramfield t2 ON t1.id = t2.appID LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 65,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_approvalflow",
            "from_column": "id",
            "to_table": "zt_approvalflowobject",
            "to_column": "flow",
            "condition": "zt_approvalflow.id = zt_approvalflowobject.flow",
            "confidence": "high",
            "reasoning": "The 'flow' field in zt_approvalflowobject is an integer and, by naming convention and business logic, likely references the 'id' field in zt_approvalflow, which uniquely identifies an approval flow. This is a common pattern for associating objects with a specific workflow definition. The business purpose of zt_approvalflowobject is to link approval flows to business objects, which requires a reference to the approval flow definition.",
            "test_sql": "SELECT COUNT(*) FROM zt_approvalflow t1 JOIN zt_approvalflowobject t2 ON t1.id = t2.flow LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_approvalflow",
            "from_column": "id",
            "to_table": "zt_approvalflowspec",
            "to_column": "flow",
            "condition": "zt_approvalflow.id = zt_approvalflowspec.flow",
            "confidence": "high",
            "reasoning": "The 'flow' field in zt_approvalflowspec is a mediumint and matches the data type and naming convention of the 'id' primary key in zt_approvalflow. Business logic and common design patterns suggest that zt_approvalflowspec stores specifications for each approval flow defined in zt_approvalflow, with potentially multiple versions per flow. This is a typical one-to-many relationship where zt_approvalflow is the parent and zt_approvalflowspec is the child.",
            "test_sql": "SELECT COUNT(*) FROM zt_approvalflow t1 JOIN zt_approvalflowspec t2 ON t1.id = t2.flow LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "account",
            "to_table": "zt_user",
            "to_column": "account",
            "condition": "zt_block.account = zt_user.account",
            "confidence": "high",
            "reasoning": "Both tables have an 'account' field of the same data type and length (char(30)), and the business logic indicates that zt_block stores dashboard blocks for individual user accounts, while zt_user stores user profiles. It is highly likely that zt_block.account references zt_user.account, establishing a one-to-many relationship where each user can have multiple dashboard blocks.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_user t2 ON t1.account = t2.account LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 37,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "account",
            "to_table": "zt_userview",
            "to_column": "account",
            "condition": "zt_block.account = zt_userview.account",
            "confidence": "high",
            "reasoning": "Both tables use the 'account' field as a non-null, fixed-length character column to identify a user. The business purposes of both tables are user-centric: zt_block stores dashboard/widget configurations per user, and zt_userview stores view/access configurations per user. It is logical that dashboard blocks for a user would be related to that user's view configuration. The data types and naming conventions match exactly, and this is a common pattern in user-personalization features.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_userview t2 ON t1.account = t2.account LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 37,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "execution",
            "to_table": "zt_burn",
            "to_column": "execution",
            "condition": "zt_bug.execution = zt_burn.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same data type (mediumint unsigned), and both use it to represent the context of a project phase, sprint, or iteration. In zt_bug, 'execution' links a bug to a specific execution context, while in zt_burn, it tracks burn-down data for that execution. This is a common business logic relationship in project management systems.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_burn t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 12,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "project",
            "to_table": "zt_build",
            "to_column": "project",
            "condition": "zt_bug.project = zt_build.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of compatible types (mediumint unsigned) and business logic suggests that bugs and builds are both associated with the same project entity. This is a common pattern in project management systems, where bugs are tracked per project and builds are created per project.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_build t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "product",
            "to_table": "zt_build",
            "to_column": "product",
            "condition": "zt_bug.product = zt_build.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field (mediumint unsigned) and the business context indicates that bugs and builds are tracked per product. This is a standard relationship in systems that manage multiple products.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_build t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "module",
            "to_table": "zt_module",
            "to_column": "id",
            "condition": "zt_bug.module = zt_module.id",
            "confidence": "high",
            "reasoning": "The 'module' field in zt_bug is a mediumint unsigned, matching the primary key 'id' in zt_module. The business logic of bug tracking systems commonly associates each bug with a specific module/component. Naming conventions and data types are compatible, and this is a standard foreign key pattern even though not explicitly defined.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_module t2 ON t1.module = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "product",
            "to_table": "zt_product",
            "to_column": "id",
            "condition": "zt_bug.product = zt_product.id",
            "confidence": "high",
            "reasoning": "The zt_bug table has a 'product' field of type mediumint unsigned, which matches the primary key 'id' of zt_product. The business logic and naming convention strongly suggest that each bug is associated with a specific product. This is a classic one-to-many relationship where each product can have multiple bugs, but each bug belongs to one product.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_product t2 ON t1.product = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "project",
            "to_table": "zt_project",
            "to_column": "id",
            "condition": "zt_bug.project = zt_project.id",
            "confidence": "high",
            "reasoning": "The zt_bug table has a 'project' field (mediumint unsigned) that is not nullable and is indexed (MUL), which strongly suggests it is intended to reference the primary key 'id' of the zt_project table (also mediumint unsigned, primary key). This aligns with standard database design patterns where bugs are associated with a specific project. The business logic also supports this, as bugs are typically tracked within the context of a project.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_project t2 ON t1.project = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "project, product, branch",
            "to_table": "zt_projectproduct",
            "to_column": "project, product, branch",
            "condition": "zt_bug.project = zt_projectproduct.project AND zt_bug.product = zt_projectproduct.product AND zt_bug.branch = zt_projectproduct.branch",
            "confidence": "high",
            "reasoning": "All three fields (project, product, branch) exist in both tables with matching data types and naming conventions. The business logic suggests that each bug is associated with a specific project, product, and branch, while zt_projectproduct defines valid project-product-branch combinations. This is a common pattern for enforcing referential integrity and context for records like bugs.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_projectproduct t2 ON t1.project = t2.project AND t1.product = t2.product AND t1.branch = t2.branch LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "id",
            "to_table": "zt_searchindex",
            "to_column": "objectID",
            "condition": "zt_bug.id = zt_searchindex.objectID AND zt_searchindex.objectType = 'bug'",
            "confidence": "high",
            "reasoning": "The zt_searchindex table is designed as a polymorphic search index for various business objects. The objectType field indicates the type of object being indexed, and objectID is the identifier of that object. Given the business purpose and naming conventions, it is highly likely that when objectType = 'bug', objectID refers to the id field in zt_bug. This allows bug records to be indexed and searched via zt_searchindex.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_searchindex t2 ON t1.id = t2.objectID WHERE t2.objectType = 'bug';",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "project",
            "to_table": "zt_projectcase",
            "to_column": "project",
            "condition": "zt_bug.project = zt_projectcase.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type and naming convention, representing the project context. Bugs are tracked per project, and test cases are assigned per project, so it is logical to relate bugs and project-case associations via the project.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_projectcase t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "story",
            "to_table": "zt_storyspec",
            "to_column": "story",
            "condition": "zt_bug.story = zt_storyspec.story AND zt_bug.storyVersion = zt_storyspec.version",
            "confidence": "high",
            "reasoning": "Both tables have a 'story' field of the same data type (mediumint), and zt_bug has a 'storyVersion' field (smallint) that matches zt_storyspec's 'version' field. The business logic suggests that each bug can be linked to a specific version of a story specification, allowing traceability of bugs to the exact requirements version they relate to. This is a common pattern in requirements and defect management systems.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_storyspec t2 ON t1.story = t2.story AND t1.storyVersion = t2.version LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "project",
            "to_table": "zt_projectstory",
            "to_column": "project",
            "condition": "zt_bug.project = zt_projectstory.project",
            "confidence": "high",
            "reasoning": "Both tables use the 'project' field as a key, and both fields are of the same data type (mediumint unsigned). The business logic indicates that bugs are tracked within the context of a project, and stories are assigned to projects. Therefore, joining on 'project' is logical and likely to yield meaningful associations.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_projectstory t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "story",
            "to_table": "zt_projectstory",
            "to_column": "story",
            "condition": "zt_bug.story = zt_projectstory.story",
            "confidence": "high",
            "reasoning": "Both tables have a 'story' field of the same data type (mediumint unsigned). In the bug table, 'story' likely refers to the requirement or feature the bug is related to, while in the projectstory table, 'story' is a primary key component. This suggests a direct logical relationship between bugs and the stories they affect.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_projectstory t2 ON t1.story = t2.story LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "project, story",
            "to_table": "zt_projectstory",
            "to_column": "project, story",
            "condition": "zt_bug.project = zt_projectstory.project AND zt_bug.story = zt_projectstory.story",
            "confidence": "high",
            "reasoning": "The combination of 'project' and 'story' in both tables provides a more precise relationship, indicating which bugs are associated with which stories within a specific project. This is reinforced by the fact that 'project' and 'story' together form the primary key in zt_projectstory.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_projectstory t2 ON t1.project = t2.project AND t1.story = t2.story LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "story",
            "to_table": "zt_storyreview",
            "to_column": "story",
            "condition": "zt_bug.story = zt_storyreview.story",
            "confidence": "high",
            "reasoning": "Both tables have a 'story' field of the same data type (mediumint), and the business logic suggests that bugs can be linked to stories, while story reviews are performed on stories. This is a common pattern in ALM systems where bugs are associated with user stories, and stories are reviewed. Thus, it is logical to join bugs to the reviews of the same story.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_storyreview t2 ON t1.story = t2.story LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "task",
            "to_table": "zt_task",
            "to_column": "id",
            "condition": "zt_bug.task = zt_task.id",
            "confidence": "high",
            "reasoning": "The zt_bug table has a 'task' field (mediumint unsigned) that likely references the primary key 'id' of zt_task. This is a common pattern in bug tracking/project management systems, where a bug can be linked to a specific task it affects or was discovered during. The data types are compatible, and the naming convention strongly suggests a foreign key relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_task t2 ON t1.task = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "project",
            "to_table": "zt_weeklyreport",
            "to_column": "project",
            "condition": "zt_bug.project = zt_weeklyreport.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and both use it to reference the project context for their records. In zt_bug, 'project' identifies the project to which a bug belongs; in zt_weeklyreport, 'project' identifies the project for which the weekly report is generated. This is a standard pattern for relating transactional/project data to reporting/summary data.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_weeklyreport t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "story",
            "to_table": "zt_story",
            "to_column": "id",
            "condition": "zt_bug.story = zt_story.id",
            "confidence": "high",
            "reasoning": "The zt_bug table has a 'story' field (mediumint unsigned) and the zt_story table has an 'id' field (mediumint unsigned, primary key). The business logic of bug tracking systems often links bugs to user stories or requirements, and the naming and data types match. This is a classic foreign key relationship, even though not explicitly defined.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_story t2 ON t1.story = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "execution",
            "to_table": "ztv_executionsummary",
            "to_column": "execution",
            "condition": "zt_bug.execution = ztv_executionsummary.execution",
            "confidence": "high",
            "reasoning": "Both tables have a column named 'execution' with the same data type (mediumint unsigned). In zt_bug, 'execution' likely refers to an execution context or instance for a bug, while ztv_executionsummary summarizes metrics for a specific execution. This suggests a logical relationship where each bug is associated with an execution, and ztv_executionsummary provides aggregate data for that execution. This is a common pattern in project management and bug tracking systems.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN ztv_executionsummary t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "product",
            "to_table": "ztv_productbugs",
            "to_column": "product",
            "condition": "zt_bug.product = ztv_productbugs.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same data type (mediumint unsigned) and naming convention. The business logic indicates that ztv_productbugs aggregates bug statistics per product, while zt_bug contains detailed bug records, each associated with a product. This is a classic one-to-many (ztv_productbugs to zt_bug) or aggregation relationship, where ztv_productbugs summarizes data from zt_bug grouped by product.",
            "test_sql": "SELECT t2.product, COUNT(t1.id) AS bug_count, t2.bugs FROM zt_bug t1 JOIN ztv_productbugs t2 ON t1.product = t2.product GROUP BY t2.product LIMIT 10;",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "product",
            "to_table": "ztv_normalproduct",
            "to_column": "id",
            "condition": "zt_bug.product = ztv_normalproduct.id",
            "confidence": "high",
            "reasoning": "The 'product' field in zt_bug is a mediumint unsigned and likely references the 'id' field in ztv_normalproduct, which is also a mediumint unsigned. The business purpose of zt_bug is to track bugs for a specific product, and ztv_normalproduct represents products. This is a standard foreign key pattern in bug tracking systems.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN ztv_normalproduct t2 ON t1.product = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "product",
            "to_table": "ztv_productstories",
            "to_column": "product",
            "condition": "zt_bug.product = ztv_productstories.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same data type (mediumint unsigned), and both are used to associate records with a specific product. In zt_bug, 'product' identifies the product related to a bug, while in ztv_productstories, 'product' aggregates stories for a product. This is a standard pattern for relating transactional and summary/aggregation tables by a shared entity key.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN ztv_productstories t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "execution",
            "to_table": "ztv_projectbugs",
            "to_column": "execution",
            "condition": "zt_bug.execution = ztv_projectbugs.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same data type (mediumint unsigned). In zt_bug, 'execution' represents the execution context for a bug, while in ztv_projectbugs, 'execution' is the key for aggregated bug statistics. The business logic suggests that ztv_projectbugs summarizes bug data for each execution, and zt_bug contains the detailed records. This is a common pattern where a summary table is linked to a detail table via a shared key.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN ztv_projectbugs t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "project",
            "to_table": "ztv_projectsummary",
            "to_column": "project",
            "condition": "zt_bug.project = ztv_projectsummary.project",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project' field of the same data type (mediumint unsigned), and the business purposes align: zt_bug tracks bugs for a project, while ztv_projectsummary summarizes project-level metrics. It is logical to join bugs to their project's summary using this field.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN ztv_projectsummary t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "execution",
            "to_table": "ztv_projectteams",
            "to_column": "execution",
            "condition": "zt_bug.execution = ztv_projectteams.execution",
            "confidence": "high",
            "reasoning": "Both tables have a column named 'execution' with the same data type (mediumint unsigned). In zt_bug, 'execution' represents the context or phase in which a bug was found or is being tracked. In ztv_projectteams, 'execution' is used to associate teams with a specific execution. This suggests that bugs can be linked to the teams working on the same execution, enabling queries such as 'which teams are responsible for the executions where this bug was reported.' This is a common business logic relationship in project management and bug tracking systems.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN ztv_projectteams t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "execution",
            "to_table": "ztv_projectstories",
            "to_column": "execution",
            "condition": "zt_bug.execution = ztv_projectstories.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same data type (mediumint unsigned). In zt_bug, 'execution' represents the context in which a bug was found or is being tracked, while in ztv_projectstories, 'execution' links to a set of stories. It is logical to relate bugs to the stories being tracked in the same execution context, supporting reporting and analysis of bugs per execution/sprint.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN ztv_projectstories t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "execution",
            "to_table": "zt_burn",
            "to_column": "execution",
            "condition": "zt_build.execution = zt_burn.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same type (mediumint unsigned), and both use it to represent an execution context (such as a sprint, iteration, or project phase). In zt_build, 'execution' groups builds under a specific execution context, while in zt_burn, it groups burn-down records under the same context. This is a common pattern in project management systems, where builds and task progress are tracked per execution.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_burn t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "project",
            "to_table": "zt_effort",
            "to_column": "project",
            "condition": "zt_build.project = zt_effort.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned) and business context. In both schemas, 'project' represents the project context for builds and efforts, respectively. It is common in project management systems to relate builds and efforts by their project association.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_effort t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "execution",
            "to_table": "zt_effort",
            "to_column": "execution",
            "condition": "zt_build.execution = zt_effort.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same data type (mediumint unsigned) and business context. 'execution' likely refers to a sprint, iteration, or phase within a project. Relating builds and efforts by execution is a standard practice in project tracking and reporting.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_effort t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "project",
            "to_table": "zt_doclib",
            "to_column": "project",
            "condition": "zt_build.project = zt_doclib.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and both are used to associate records with a specific project. It is common in business logic for builds and document libraries to be grouped or filtered by project, suggesting a logical relationship for reporting or filtering.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_doclib t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "product",
            "to_table": "zt_doclib",
            "to_column": "product",
            "condition": "zt_build.product = zt_doclib.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same data type (mediumint unsigned), and both are used to associate records with a specific product. This is a standard pattern for linking builds and document libraries to the same product context.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_doclib t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "execution",
            "to_table": "zt_doclib",
            "to_column": "execution",
            "condition": "zt_build.execution = zt_doclib.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same data type (mediumint unsigned), and both are used to associate records with a specific execution context. This is a common way to relate builds and document libraries to the same execution or iteration.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_doclib t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "product",
            "to_table": "zt_case",
            "to_column": "product",
            "condition": "zt_build.product = zt_case.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field (mediumint unsigned, not null) and are indexed. The business purpose of both tables involves associating records with a product, suggesting a logical relationship for filtering or joining by product.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_case t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "project",
            "to_table": "zt_project",
            "to_column": "id",
            "condition": "zt_build.project = zt_project.id",
            "confidence": "high",
            "reasoning": "The zt_build table has a 'project' field (mediumint unsigned, not null) that likely references the primary key 'id' of zt_project (mediumint unsigned, primary key). The business purpose of zt_build is to track builds within a project context, and the naming and data types strongly suggest a foreign key relationship. This is a common pattern in project management and ALM systems.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_project t2 ON t1.project = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "product",
            "to_table": "zt_product",
            "to_column": "id",
            "condition": "zt_build.product = zt_product.id",
            "confidence": "high",
            "reasoning": "The 'product' field in zt_build and the 'id' field in zt_product share the same data type (mediumint unsigned) and naming convention. The business logic of a build being associated with a specific product is standard in software development lifecycle systems. This is a classic foreign key relationship, even though it is not explicitly defined in the schema.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_product t2 ON t1.product = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "product",
            "to_table": "zt_productplan",
            "to_column": "product",
            "condition": "zt_build.product = zt_productplan.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same data type (mediumint unsigned), and both use it to reference the same business entity (a product). Builds are associated with products, and product plans are also associated with products. This is a standard pattern in software development databases, where builds are tracked per product and plans are created per product.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_productplan t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "product, branch",
            "to_table": "zt_productplan",
            "to_column": "product, branch",
            "condition": "zt_build.product = zt_productplan.product AND zt_build.branch = zt_productplan.branch",
            "confidence": "high",
            "reasoning": "Combining both 'product' and 'branch' fields provides a more granular and likely accurate relationship, as builds and product plans are often organized by both product and branch/version. This composite relationship is common in systems tracking releases and plans per product branch.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_productplan t2 ON t1.product = t2.product AND t1.branch = t2.branch LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "project",
            "to_table": "zt_projectcase",
            "to_column": "project",
            "condition": "zt_build.project = zt_projectcase.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and both use it to represent the project context. In zt_build, 'project' identifies the project associated with a build; in zt_projectcase, it identifies the project to which a test case is assigned. It is common in project management and QA systems to relate builds and test cases through their shared project context. This relationship allows analysis of which builds are associated with which test cases via their common project.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_projectcase t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "project",
            "to_table": "zt_projectstory",
            "to_column": "project",
            "condition": "zt_build.project = zt_projectstory.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and both use it to represent the project context. In zt_build, it identifies the project a build belongs to; in zt_projectstory, it identifies the project to which a story is assigned. This is a standard business logic relationship in project management systems, where builds are associated with projects and projects are associated with stories.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_projectstory t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "system",
            "to_table": "zt_system",
            "to_column": "id",
            "condition": "zt_build.system = zt_system.id",
            "confidence": "high",
            "reasoning": "The zt_build table contains a 'system' field of type mediumint unsigned, which matches the primary key 'id' of zt_system. The business purpose of zt_build is to track builds, and each build is associated with a system. The 'system' field is also indexed (MUL), suggesting frequent lookups or joins. This is a classic foreign key pattern, even though not explicitly defined.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_system t2 ON t1.system = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "project",
            "to_table": "zt_task",
            "to_column": "project",
            "condition": "zt_build.project = zt_task.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and both represent entities (builds and tasks) that are associated with a project. It is a common business logic and database design pattern to relate records by their project context.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_task t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "execution",
            "to_table": "zt_task",
            "to_column": "execution",
            "condition": "zt_build.execution = zt_task.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same data type (mediumint unsigned), and both are designed to track entities within an execution context (such as a sprint, iteration, or phase). This is a standard way to relate builds and tasks that occur within the same execution phase.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_task t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "project",
            "to_table": "zt_weeklyreport",
            "to_column": "project",
            "condition": "zt_build.project = zt_weeklyreport.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned) and naming convention, and both are used to associate records with a specific project. In zt_build, 'project' links a build to a project, while in zt_weeklyreport, 'project' links a weekly report to a project. This is a standard pattern for relating different entities to the same project context.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_weeklyreport t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "project",
            "to_table": "zt_testtask",
            "to_column": "project",
            "condition": "zt_build.project = zt_testtask.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same type and name, and both are used to associate records with a project. This is a standard pattern in project management systems, allowing for filtering or joining records by project context. However, this is not a direct foreign key relationship between the two tables, but rather a logical grouping.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_testtask t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "product",
            "to_table": "zt_testtask",
            "to_column": "product",
            "condition": "zt_build.product = zt_testtask.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same type and name, which is a common way to associate records with a product entity. This allows for filtering or joining records by product context. Like 'project', this is a logical relationship rather than a direct foreign key between the two tables.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_testtask t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "execution",
            "to_table": "zt_testtask",
            "to_column": "execution",
            "condition": "zt_build.execution = zt_testtask.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same type and name, likely referring to an execution context or cycle. This is a standard way to relate records that are part of the same execution or sprint. This is a logical relationship for filtering or reporting, not a direct foreign key between the two tables.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_testtask t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "product",
            "to_table": "ztv_productbugs",
            "to_column": "product",
            "condition": "zt_build.product = ztv_productbugs.product",
            "confidence": "high",
            "reasoning": "Both tables contain a 'product' field of the same data type (mediumint unsigned), and the business logic aligns: zt_build records builds for a product, while ztv_productbugs aggregates bug statistics for a product. Joining on 'product' allows analysis of builds in the context of product-level bug statistics, which is a common reporting and analytical use case.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN ztv_productbugs t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "execution",
            "to_table": "ztv_executionsummary",
            "to_column": "execution",
            "condition": "zt_build.execution = ztv_executionsummary.execution",
            "confidence": "high",
            "reasoning": "Both tables contain a field named 'execution' of the same data type (mediumint unsigned). In zt_build, 'execution' represents the execution context for a build, while in ztv_executionsummary, 'execution' is the primary identifier for execution summary metrics. It is logical to infer that ztv_executionsummary provides summary metrics for the execution context referenced by zt_build. This is a common pattern where a detail table (zt_build) references a summary or master table (ztv_executionsummary) via a shared key.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN ztv_executionsummary t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "product",
            "to_table": "ztv_productstories",
            "to_column": "product",
            "condition": "zt_build.product = ztv_productstories.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same data type (mediumint unsigned), and both are used to associate records with a specific product. In zt_build, 'product' links a build to a product, while in ztv_productstories, 'product' aggregates stories for a product. This suggests a logical relationship where builds can be joined to product story summaries via the product ID.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN ztv_productstories t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "product",
            "to_table": "ztv_normalproduct",
            "to_column": "id",
            "condition": "zt_build.product = ztv_normalproduct.id",
            "confidence": "high",
            "reasoning": "Both tables have a field named 'product' (zt_build) and 'id' (ztv_normalproduct) with the same data type (mediumint unsigned). The business purpose of zt_build is to track builds for a specific product, and ztv_normalproduct represents products. It is a common database design pattern for a build to reference its parent product by product ID. This is the only clear and logical relationship between the two tables based on the provided schemas.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN ztv_normalproduct t2 ON t1.product = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "execution",
            "to_table": "ztv_projectbugs",
            "to_column": "execution",
            "condition": "zt_build.execution = ztv_projectbugs.execution",
            "confidence": "high",
            "reasoning": "Both tables contain an 'execution' field of the same data type (mediumint unsigned), and both use it in a context related to software development lifecycle events. In zt_build, 'execution' identifies the context or run for a build, while in ztv_projectbugs, it aggregates bug statistics for a specific execution. This suggests a logical and likely business relationship where builds and their associated bug metrics are linked by the same execution instance.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN ztv_projectbugs t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "execution",
            "to_table": "ztv_projectstories",
            "to_column": "execution",
            "condition": "zt_build.execution = ztv_projectstories.execution",
            "confidence": "high",
            "reasoning": "Both tables contain an 'execution' field of the same data type (mediumint unsigned), and both use it in a context that suggests it represents a project phase, sprint, or work session. In zt_build, 'execution' links a build to its execution context, while in ztv_projectstories, 'execution' links stories to the same context. This makes it highly likely that these fields refer to the same entity, supporting a logical join for reporting or traceability between builds and the stories associated with their execution.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN ztv_projectstories t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "execution",
            "to_table": "ztv_projectteams",
            "to_column": "execution",
            "condition": "zt_build.execution = ztv_projectteams.execution",
            "confidence": "high",
            "reasoning": "Both tables contain an 'execution' field of the same data type (mediumint unsigned), and the business logic suggests that builds are associated with an execution context, while ztv_projectteams maps teams to executions. This implies that builds can be linked to the teams working on the same execution via the shared 'execution' field. This is a common pattern in project management systems, where builds are tied to a specific execution (e.g., sprint, phase, or project instance), and teams are assigned to those executions.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN ztv_projectteams t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "project",
            "to_table": "ztv_projectsummary",
            "to_column": "project",
            "condition": "zt_build.project = ztv_projectsummary.project",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project' field of the same data type (mediumint unsigned), and the business purposes align: zt_build records builds for a project, while ztv_projectsummary summarizes project-level metrics. It is logical to join builds to their corresponding project summary using the project ID.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN ztv_projectsummary t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "execution",
            "to_table": "zt_effort",
            "to_column": "execution",
            "condition": "zt_burn.execution = zt_effort.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same type (mediumint unsigned), and both use it to represent the context of work (e.g., sprint, iteration, or project phase). This is a standard way to relate progress tracking (zt_burn) and effort logging (zt_effort) within the same execution context.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN zt_effort t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "execution",
            "to_table": "zt_project",
            "to_column": "id",
            "condition": "zt_burn.execution = zt_project.id",
            "confidence": "high",
            "reasoning": "The 'execution' field in zt_burn is a mediumint unsigned and is the primary key (or part of the composite primary key) in zt_burn. The 'id' field in zt_project is the primary key and also a mediumint unsigned. The business purpose of zt_burn is to track progress for a specific execution, which, in agile/project management systems, often maps to a project, sprint, or phase entity. Given the naming and data type match, it is highly likely that 'execution' in zt_burn refers to the 'id' of a project or execution phase in zt_project.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN zt_project t2 ON t1.execution = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "execution",
            "to_table": "ztv_executionsummary",
            "to_column": "execution",
            "condition": "zt_burn.execution = ztv_executionsummary.execution",
            "confidence": "high",
            "reasoning": "Both tables contain an 'execution' field of the same data type (mediumint unsigned) and business context. In zt_burn, 'execution' identifies the context (such as a sprint or project phase) for each task's daily burn record. In ztv_executionsummary, 'execution' summarizes metrics for that same context. This is a classic detail-to-summary (one-to-many) relationship, where zt_burn holds granular records and ztv_executionsummary holds aggregated data for each execution.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN ztv_executionsummary t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "execution",
            "to_table": "ztv_projectbugs",
            "to_column": "execution",
            "condition": "zt_burn.execution = ztv_projectbugs.execution",
            "confidence": "high",
            "reasoning": "Both tables contain an 'execution' field of the same data type (mediumint unsigned), and both use it to represent the context of a project phase, sprint, or iteration. The business purposes align: zt_burn tracks task progress within an execution, while ztv_projectbugs aggregates bug metrics for the same execution. This suggests a logical relationship where burn-down data and bug statistics can be joined on the execution context for reporting or analysis.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN ztv_projectbugs t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "execution",
            "to_table": "ztv_projectstories",
            "to_column": "execution",
            "condition": "zt_burn.execution = ztv_projectstories.execution",
            "confidence": "high",
            "reasoning": "Both tables use the 'execution' field with the same data type and business meaning (representing a project phase, sprint, or iteration). The 'zt_burn' table tracks task progress within an execution, while 'ztv_projectstories' tracks stories associated with an execution. Joining on 'execution' allows analysis of burn-down data alongside story completion status for the same execution.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN ztv_projectstories t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "execution",
            "to_table": "ztv_projectteams",
            "to_column": "execution",
            "condition": "zt_burn.execution = ztv_projectteams.execution",
            "confidence": "high",
            "reasoning": "Both tables contain an 'execution' field of the same data type (mediumint unsigned), and the business purposes indicate that 'execution' represents a common entity (such as a project, sprint, or phase). In zt_burn, 'execution' identifies the context for task progress tracking, while in ztv_projectteams, it identifies the context for team assignments. This suggests a logical relationship where you can join task progress records to the teams assigned to the same execution.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN ztv_projectteams t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "id",
            "to_table": "zt_casestep",
            "to_column": "case",
            "condition": "zt_case.id = zt_casestep.case",
            "confidence": "high",
            "reasoning": "The 'case' field in zt_casestep matches the primary key 'id' in zt_case by both naming convention and data type. Business logic dictates that test steps (zt_casestep) belong to a specific test case (zt_case). This is a standard parent-child (one-to-many) relationship in test management systems.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_casestep t2 ON t1.id = t2.case LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "version",
            "to_table": "zt_casestep",
            "to_column": "version",
            "condition": "zt_case.version = zt_casestep.version",
            "confidence": "high",
            "reasoning": "Both tables have a 'version' field, and in the context of test case management, steps are often versioned along with their parent test case. This allows retrieving the correct set of steps for a specific version of a test case. The data types are compatible and the business logic supports this relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_casestep t2 ON t1.id = t2.case AND t1.version = t2.version LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "project",
            "to_table": "zt_group",
            "to_column": "project",
            "condition": "zt_case.project = zt_group.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and both use it to associate their records with a specific project. In zt_case, 'project' links a test case to a project, while in zt_group, 'project' links a group to a project. This suggests a logical relationship where test cases and groups are both scoped to the same project, enabling queries such as 'find all groups related to the project of a given test case' or 'find all test cases for projects with certain group characteristics.'",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_group t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 80,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "product",
            "to_table": "zt_product",
            "to_column": "id",
            "condition": "zt_case.product = zt_product.id",
            "confidence": "high",
            "reasoning": "The 'product' field in zt_case is a mediumint unsigned and is indexed (MUL), matching the primary key 'id' in zt_product. The business logic and naming convention strongly suggest that each test case is associated with a specific product, making this a classic foreign key relationship, even though it is not explicitly defined in the schema.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_product t2 ON t1.product = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "product",
            "to_table": "zt_productplan",
            "to_column": "product",
            "condition": "zt_case.product = zt_productplan.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same data type (mediumint unsigned), and both are used to associate records with a specific product. In zt_case, 'product' links a test case to a product, while in zt_productplan, 'product' links a product plan to a product. This is a common pattern in systems where test cases are associated with the products they test, and product plans are associated with the products they plan for. This relationship allows for analysis of which test cases are relevant to which product plans, or for aggregating test coverage by product plan.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_productplan t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "id",
            "to_table": "zt_projectcase",
            "to_column": "case",
            "condition": "zt_case.id = zt_projectcase.case",
            "confidence": "high",
            "reasoning": "The 'id' field in zt_case is the primary key representing a unique test case. The 'case' field in zt_projectcase is used to reference a test case assigned to a project. Both fields are of the same data type (mediumint unsigned) and naming convention, and the business logic of assigning test cases to projects supports this relationship. This is a classic foreign key pattern, even though the foreign key is not explicitly defined.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_projectcase t2 ON t1.id = t2.case LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "id",
            "to_table": "zt_searchindex",
            "to_column": "objectID",
            "condition": "zt_case.id = zt_searchindex.objectID AND zt_searchindex.objectType = 'case'",
            "confidence": "high",
            "reasoning": "The zt_searchindex table is designed as a polymorphic search index, where objectType indicates the type of object being indexed and objectID is the unique identifier of that object. Given the business purpose and naming conventions, it is highly likely that test cases from zt_case are indexed in zt_searchindex with objectType = 'case' and objectID matching zt_case.id. This is a common pattern for implementing full-text search across multiple business entities.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_searchindex t2 ON t1.id = t2.objectID AND t2.objectType = 'case';",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "story",
            "to_table": "zt_story",
            "to_column": "id",
            "condition": "zt_case.story = zt_story.id",
            "confidence": "high",
            "reasoning": "The 'story' field in zt_case is a mediumint unsigned and is indexed (MUL), matching the primary key 'id' in zt_story. The business logic and naming convention strongly suggest that each test case can be linked to a specific story (requirement) it is meant to verify or validate. This is a common pattern in test management systems, where test cases are traced to requirements or user stories.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_story t2 ON t1.story = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "story",
            "to_table": "zt_storyreview",
            "to_column": "story",
            "condition": "zt_case.story = zt_storyreview.story",
            "confidence": "high",
            "reasoning": "Both tables have a 'story' field of compatible data types (mediumint), and the business logic indicates that test cases (zt_case) are associated with requirements or user stories, which are reviewed in zt_storyreview. This suggests a logical link where test cases are tied to stories that undergo review.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_storyreview t2 ON t1.story = t2.story LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "storyVersion",
            "to_table": "zt_storyreview",
            "to_column": "version",
            "condition": "zt_case.story = zt_storyreview.story AND zt_case.storyVersion = zt_storyreview.version",
            "confidence": "high",
            "reasoning": "zt_case has both 'story' and 'storyVersion' fields, while zt_storyreview uses 'story' and 'version' as a composite key. This strongly suggests that a test case is linked to a specific version of a story, and reviews are also versioned. This is a common pattern in requirements/test management systems.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_storyreview t2 ON t1.story = t2.story AND t1.storyVersion = t2.version LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "story, storyVersion",
            "to_table": "zt_storyspec",
            "to_column": "story, version",
            "condition": "zt_case.story = zt_storyspec.story AND zt_case.storyVersion = zt_storyspec.version",
            "confidence": "high",
            "reasoning": "The zt_case table has fields 'story' and 'storyVersion', which closely match the 'story' and 'version' fields in zt_storyspec. The business logic suggests that each test case is associated with a specific version of a story (requirement), and zt_storyspec holds the specification for each version of a story. The data types are compatible (mediumint/smallint), and this is a common pattern in requirements/test management systems.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_storyspec t2 ON t1.story = t2.story AND t1.storyVersion = t2.version LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "story",
            "to_table": "zt_projectstory",
            "to_column": "story",
            "condition": "zt_case.story = zt_projectstory.story",
            "confidence": "high",
            "reasoning": "Both tables have a 'story' field of the same type and business meaning. Test cases are often linked to requirements or stories, and zt_projectstory links stories to projects. This join allows finding which project-story associations are relevant to a test case.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_projectstory t2 ON t1.story = t2.story LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "product",
            "to_table": "zt_testtask",
            "to_column": "product",
            "condition": "zt_case.product = zt_testtask.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same type and name, indicating the product under test. This allows for grouping or filtering test cases and test tasks by product, which is a standard practice in test management.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_testtask t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "id",
            "to_table": "zt_testrun",
            "to_column": "case",
            "condition": "zt_case.id = zt_testrun.case",
            "confidence": "high",
            "reasoning": "The zt_testrun table has a column named 'case' (same data type as zt_case.id), which by naming convention and business logic is highly likely to reference the primary key of zt_case. This is a standard pattern in test management systems, where each test run is an execution of a specific test case.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_testrun t2 ON t1.id = t2.case LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "id",
            "to_table": "zt_testresult",
            "to_column": "case",
            "condition": "zt_case.id = zt_testresult.case",
            "confidence": "high",
            "reasoning": "The 'case' field in zt_testresult is a mediumint unsigned and matches the data type and naming convention of the primary key 'id' in zt_case. The business logic also supports this: zt_testresult records the results of executing a specific test case, so each test result should reference a test case by its ID.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_testresult t2 ON t1.id = t2.case LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "story",
            "to_table": "zt_task",
            "to_column": "story",
            "condition": "zt_case.story = zt_task.story",
            "confidence": "high",
            "reasoning": "Both tables have a 'story' field of the same type and name, likely referencing a requirement or user story. This enables joining test cases and tasks that are related to the same requirement, which is a common practice in requirements traceability and coverage analysis.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_task t2 ON t1.story = t2.story LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "product",
            "to_table": "ztv_productbugs",
            "to_column": "product",
            "condition": "zt_case.product = ztv_productbugs.product",
            "confidence": "high",
            "reasoning": "Both tables contain a 'product' field of the same data type (mediumint unsigned), and the business logic aligns: zt_case test cases are associated with products, while ztv_productbugs aggregates bug statistics per product. This suggests a logical relationship where test cases can be joined to product-level bug statistics for reporting or analysis.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN ztv_productbugs t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "product",
            "to_table": "ztv_productstories",
            "to_column": "product",
            "condition": "zt_case.product = ztv_productstories.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same data type (mediumint unsigned) and business context. In zt_case, 'product' identifies the product associated with a test case. In ztv_productstories, 'product' identifies the product for which stories are aggregated. This suggests a logical relationship where test cases can be joined to product story summaries via the product they belong to.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN ztv_productstories t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "product",
            "to_table": "ztv_normalproduct",
            "to_column": "id",
            "condition": "zt_case.product = ztv_normalproduct.id",
            "confidence": "high",
            "reasoning": "The 'product' field in zt_case and the 'id' field in ztv_normalproduct are both mediumint unsigned and likely represent the same product entity. The business purpose of zt_case is to track test cases for products, and ztv_normalproduct represents products. This is a standard foreign key pattern, even though not explicitly defined.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN ztv_normalproduct t2 ON t1.product = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_casestep",
            "from_column": "case",
            "to_table": "zt_projectcase",
            "to_column": "case",
            "condition": "zt_casestep.case = zt_projectcase.case",
            "confidence": "high",
            "reasoning": "Both tables have a 'case' field of the same data type (mediumint unsigned), and the business logic suggests that zt_casestep defines the steps for a test case, while zt_projectcase associates test cases with projects. Joining on 'case' allows retrieval of all steps for test cases assigned to projects, which is a common pattern in test management systems.",
            "test_sql": "SELECT COUNT(*) FROM zt_casestep t1 JOIN zt_projectcase t2 ON t1.case = t2.case LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 14,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_casestep",
            "from_column": "case",
            "to_table": "zt_testresult",
            "to_column": "case",
            "condition": "zt_casestep.case = zt_testresult.case AND zt_casestep.version = zt_testresult.version",
            "confidence": "high",
            "reasoning": "Both tables have 'case' and 'version' fields with matching names and compatible data types. Business logic suggests that zt_casestep defines the steps for a specific test case and version, while zt_testresult records the results of executing that test case and version. This is a common pattern in test management systems, where test results are linked to the definition of the test case and its steps for a particular version.",
            "test_sql": "SELECT COUNT(*) FROM zt_casestep t1 JOIN zt_testresult t2 ON t1.case = t2.case AND t1.version = t2.version LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_casestep",
            "from_column": "case",
            "to_table": "zt_testrun",
            "to_column": "case",
            "condition": "zt_casestep.case = zt_testrun.case",
            "confidence": "high",
            "reasoning": "Both tables have a 'case' field of the same data type (mediumint unsigned), and both are described as relating to test cases: zt_casestep defines the steps of a test case, while zt_testrun records the execution of a test case. It is a common pattern for test run records to reference the test case they are executing, and for test steps to be associated with the same test case. This relationship allows retrieval of all steps for a test case that is being executed in a test run.",
            "test_sql": "SELECT COUNT(*) FROM zt_casestep t1 JOIN zt_testrun t2 ON t1.case = t2.case LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_casestep",
            "from_column": "case, version",
            "to_table": "zt_testrun",
            "to_column": "case, version",
            "condition": "zt_casestep.case = zt_testrun.case AND zt_casestep.version = zt_testrun.version",
            "confidence": "high",
            "reasoning": "Both tables have 'case' and 'version' fields, and both are used to track versions of test cases and their steps. This join ensures that the steps retrieved correspond to the specific version of the test case that was executed in the test run, which is critical in versioned test management systems.",
            "test_sql": "SELECT COUNT(*) FROM zt_casestep t1 JOIN zt_testrun t2 ON t1.case = t2.case AND t1.version = t2.version LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_chart",
            "from_column": "dimension",
            "to_table": "zt_dimension",
            "to_column": "id",
            "condition": "zt_chart.dimension = zt_dimension.id",
            "confidence": "high",
            "reasoning": "The 'dimension' field in zt_chart is a mediumint unsigned, matching the primary key 'id' in zt_dimension. The business purpose of zt_chart is to define charts, and zt_dimension defines analytical axes or categories. It is a common BI pattern for a chart to reference a dimension by ID, making this a likely foreign key relationship, even though it is not explicitly declared.",
            "test_sql": "SELECT COUNT(*) FROM zt_chart t1 JOIN zt_dimension t2 ON t1.dimension = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 182,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "view_datasource_4",
            "to_column": "id",
            "condition": "tmp_case_getDevStories.story = view_datasource_4.id",
            "confidence": "high",
            "reasoning": "Both 'story' (in tmp_case_getDevStories) and 'id' (in view_datasource_4) are of the same numeric type (mediumint unsigned), and 'story' is the only candidate in tmp_case_getDevStories that could reference an entity in another table. The business purpose of tmp_case_getDevStories is to aggregate case counts per 'story', and view_datasource_4 appears to be a catalog of entities with titles, which could plausibly represent 'stories'. However, there is no explicit naming or business logic directly linking these fields, so the relationship is inferred based on data type compatibility and common database design patterns.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN view_datasource_4 t2 ON t1.story = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "view_datasource_41",
            "to_column": "id",
            "condition": "tmp_case_getDevStories.story = view_datasource_41.id",
            "confidence": "high",
            "reasoning": "Both 'story' (in tmp_case_getDevStories) and 'id' (in view_datasource_41) are of the same data type (mediumint unsigned) and serve as unique identifiers in their respective tables. The business purpose of tmp_case_getDevStories is to aggregate case counts per 'story', and view_datasource_41 appears to catalog entities by 'id' and 'title'. It is plausible that 'story' refers to an entity listed in view_datasource_41, making this a potential foreign key or reference relationship. However, the lack of explicit foreign key constraints and the generic naming of view_datasource_41 reduce the confidence to medium.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN view_datasource_41 t2 ON t1.story = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "view_datasource_12",
            "to_column": "id",
            "condition": "tmp_case_getDevStories.story = view_datasource_12.id",
            "confidence": "high",
            "reasoning": "Both 'story' (in tmp_case_getDevStories) and 'id' (in view_datasource_12) are of the same data type (mediumint unsigned) and serve as unique identifiers in their respective tables. The 'story' field is likely a reference to a story entity, and 'view_datasource_12' appears to be a catalog of such entities. The naming is not identical, but the data types and business purposes suggest a possible foreign key or lookup relationship, where 'story' refers to an 'id' in the catalog.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN view_datasource_12 t2 ON t1.story = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_action",
            "to_column": "objectID",
            "condition": "tmp_case_getDevStories.story = zt_action.objectID AND zt_action.objectType = 'story'",
            "confidence": "high",
            "reasoning": "The 'story' field in tmp_case_getDevStories and the 'objectID' field in zt_action are both of type mediumint unsigned, suggesting data type compatibility. The business purpose of tmp_case_getDevStories is to aggregate case counts per 'story', while zt_action logs actions on various business objects, identified by objectType and objectID. If zt_action.objectType = 'story', then objectID likely refers to a story entity, which could correspond to tmp_case_getDevStories.story. This relationship is not enforced by a foreign key, but is a common pattern in audit/action logging tables.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_action t2 ON t1.story = t2.objectID AND t2.objectType = 'story' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 17,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "view_datasource_6",
            "to_column": "id",
            "condition": "tmp_case_getDevStories.story = view_datasource_6.id",
            "confidence": "high",
            "reasoning": "Both 'story' (in tmp_case_getDevStories) and 'id' (in view_datasource_6) are numeric fields of similar type and likely represent unique identifiers. The business purpose of tmp_case_getDevStories is to aggregate case counts per 'story', and view_datasource_6 appears to catalog entities by 'id' and 'title'. It is plausible that 'story' refers to an entity listed in view_datasource_6, making this a potential foreign key or lookup relationship. However, there is no explicit foreign key or naming convention directly linking them, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN view_datasource_6 t2 ON t1.story = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_build",
            "to_column": "stories",
            "condition": "FIND_IN_SET(tmp_case_getDevStories.story, REPLACE(zt_build.stories, ' ', '')) > 0",
            "confidence": "high",
            "reasoning": "The 'story' field in tmp_case_getDevStories is a numeric identifier, and zt_build has a 'stories' field of type TEXT, which likely contains a comma-separated list of story IDs associated with each build. Although there is no explicit foreign key, the business logic suggests that builds are linked to stories, and the naming and data types are compatible for such a relationship. The use of FIND_IN_SET is necessary due to the denormalized storage of story IDs in the 'stories' field.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_build t2 ON FIND_IN_SET(t1.story, REPLACE(t2.stories, ' ', '')) > 0 LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_casestep",
            "to_column": "case",
            "condition": "tmp_case_getDevStories.story = zt_casestep.case",
            "confidence": "high",
            "reasoning": "Both 'story' (in tmp_case_getDevStories) and 'case' (in zt_casestep) are of the same data type (mediumint unsigned) and likely represent identifiers for related entities. The business purpose of tmp_case_getDevStories is to aggregate case counts per 'story', while zt_casestep details steps for a 'case'. If 'story' in tmp_case_getDevStories actually refers to a 'case' (despite the naming), this would be a direct relationship. However, due to the naming difference and lack of explicit foreign key, confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_casestep t2 ON t1.story = t2.case LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_projectcase",
            "to_column": "case",
            "condition": "tmp_case_getDevStories.story = zt_projectcase.case",
            "confidence": "high",
            "reasoning": "Both 'story' (in tmp_case_getDevStories) and 'case' (in zt_projectcase) are of the same data type (mediumint unsigned) and likely represent identifiers for entities that could be related in a business context. The 'story' field in the temporary table appears to aggregate case counts, and the 'case' field in zt_projectcase represents individual test cases assigned to projects. While the naming is not identical, in some business domains, 'story' and 'case' can be related (e.g., a user story may have associated test cases). However, without explicit foreign keys or more context, this relationship is inferred based on naming similarity and data type compatibility.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_projectcase t2 ON t1.story = t2.case LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_searchindex",
            "to_column": "objectID",
            "condition": "tmp_case_getDevStories.story = zt_searchindex.objectID AND zt_searchindex.objectType = 'story'",
            "confidence": "high",
            "reasoning": "The 'story' field in tmp_case_getDevStories is a numeric identifier representing a 'story', and zt_searchindex uses a polymorphic pattern with objectType/objectID to reference various business objects. It is reasonable to infer that when objectType = 'story', objectID refers to a story's unique ID, which could match the 'story' field in tmp_case_getDevStories. This relationship is not enforced by foreign keys but is a common business logic pattern in search indexing.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_searchindex t2 ON t1.story = t2.objectID AND t2.objectType = 'story';",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_testrun",
            "to_column": "case",
            "condition": "tmp_case_getDevStories.story = zt_testrun.case",
            "confidence": "high",
            "reasoning": "Both 'story' (in tmp_case_getDevStories) and 'case' (in zt_testrun) are of the same data type (mediumint unsigned) and likely represent identifiers for entities that could be related in a test management or QA context. The business purpose of tmp_case_getDevStories is to aggregate case counts per 'story', and zt_testrun tracks test runs per 'case'. It is plausible that 'story' in the temporary table refers to the same entity as 'case' in the test run table, especially if the temporary table is summarizing test case activity. However, the naming difference ('story' vs 'case') introduces some uncertainty, so the confidence is set to medium.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_testrun t2 ON t1.story = t2.case LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_testresult",
            "to_column": "case",
            "condition": "tmp_case_getDevStories.story = zt_testresult.case",
            "confidence": "high",
            "reasoning": "Both 'story' (in tmp_case_getDevStories) and 'case' (in zt_testresult) are of the same data type (mediumint unsigned) and likely represent identifiers for test cases or user stories. The business purpose of tmp_case_getDevStories is to aggregate case counts per 'story', while zt_testresult records results for individual 'case' executions. It is plausible that 'story' in the temporary table corresponds to 'case' in the test results table, especially if 'story' is used as a synonym for 'case' in the business domain or reporting context. However, the naming difference introduces some uncertainty.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_testresult t2 ON t1.story = t2.case LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "ztv_projectstories",
            "to_column": "stories",
            "condition": "tmp_case_getDevStories.story = ztv_projectstories.stories",
            "confidence": "high",
            "reasoning": "The 'story' field in tmp_case_getDevStories and the 'stories' field in ztv_projectstories are both numeric and likely represent story identifiers. The naming convention and business context suggest that 'story' in the first table could correspond to 'stories' in the second table, potentially allowing aggregation of case counts per story alongside their association with executions. However, the lack of explicit foreign keys and the difference in data types (mediumint unsigned vs bigint) slightly reduce confidence.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN ztv_projectstories t2 ON t1.story = t2.stories LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "view_datasource_11",
            "to_column": "id",
            "condition": "tmp_task_getProjectTasks.project = view_datasource_11.id",
            "confidence": "high",
            "reasoning": "Both fields ('project' and 'id') share the same data type (mediumint unsigned) and are likely to represent identifiers. The 'project' field in tmp_task_getProjectTasks is used to group or reference projects, while 'id' in view_datasource_11 uniquely identifies named entities. Although the table name 'view_datasource_11' is generic and does not explicitly indicate it stores project data, it is plausible that it serves as a lookup for project names or similar entities. However, due to the lack of explicit naming alignment and foreign key constraints, the confidence is set to medium.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN view_datasource_11 t2 ON t1.project = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "view_datasource_4",
            "to_column": "id",
            "condition": "tmp_task_getProjectTasks.project = view_datasource_4.id",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and likely represent identifiers. The 'project' field in tmp_task_getProjectTasks could reference an entity cataloged in view_datasource_4 via its 'id' field. However, there is no explicit foreign key or naming convention directly linking them, and the business purposes are only loosely compatible (project vs. generic catalog), so the relationship is plausible but not certain.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN view_datasource_4 t2 ON t1.project = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "view_datasource_41",
            "to_column": "id",
            "condition": "tmp_task_getProjectTasks.project = view_datasource_41.id",
            "confidence": "high",
            "reasoning": "Both fields ('project' and 'id') share the same data type (mediumint unsigned) and naming conventions suggest that 'project' in the task table could reference an entity identified by 'id' in the catalog table. This is a common pattern where a transactional or fact table references a lookup or dimension table for descriptive information. However, without explicit foreign key constraints or more context, the relationship is inferred based on schema and business logic.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN view_datasource_41 t2 ON t1.project = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_doclib",
            "to_column": "project",
            "condition": "tmp_task_getProjectTasks.project = zt_doclib.project",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project' field of the same data type (mediumint unsigned), and both fields represent a project identifier. In tmp_task_getProjectTasks, 'project' groups resource consumption by project, while in zt_doclib, 'project' associates a document library with a project. This suggests a logical relationship where task/resource data can be linked to document libraries relevant to the same project. However, since 'project' is not a primary or unique key in zt_doclib, and there may be multiple document libraries per project, this is not a strict foreign key relationship but a business logic association.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_doclib t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_metriclib",
            "to_column": "project",
            "condition": "CAST(tmp_task_getProjectTasks.project AS CHAR) = zt_metriclib.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field, which likely represents a project identifier. However, the data types differ: 'tmp_task_getProjectTasks.project' is a numeric (mediumint unsigned), while 'zt_metriclib.project' is a char(30). This suggests that, if the numeric project ID is stored as a string in 'zt_metriclib', a join is possible by casting. The business logic also aligns: 'tmp_task_getProjectTasks' aggregates resource consumption per project, while 'zt_metriclib' stores metrics per project. This relationship would allow analysis of resource consumption alongside other project metrics.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_metriclib t2 ON CAST(t1.project AS CHAR) = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 50,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_product",
            "to_column": "id",
            "condition": "tmp_task_getProjectTasks.project = zt_product.id",
            "confidence": "high",
            "reasoning": "The 'project' field in tmp_task_getProjectTasks and the 'id' field in zt_product are both of type mediumint unsigned, and 'project' is a key in tmp_task_getProjectTasks. While the naming is not a direct match ('project' vs 'product'), in some project management systems, a 'project' may be closely associated with or even represented by a 'product' entity, especially if the system uses 'product' as the main organizational unit for tasks and resource tracking. There is no explicit foreign key, but the data types and business context suggest a possible relationship for reporting or aggregation purposes.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_product t2 ON t1.project = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "ztv_normalproduct",
            "to_column": "id",
            "condition": "tmp_task_getProjectTasks.project = ztv_normalproduct.id",
            "confidence": "high",
            "reasoning": "Both fields ('project' in tmp_task_getProjectTasks and 'id' in ztv_normalproduct) are of compatible numeric types (mediumint unsigned). The 'project' field in tmp_task_getProjectTasks likely refers to a project or product entity, and 'id' is the primary identifier for ztv_normalproduct. While the naming is not an exact match, in many project management schemas, tasks are often linked to a product or project entity by an ID. However, there is no explicit foreign key or naming convention that guarantees this relationship, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN ztv_normalproduct t2 ON t1.project = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_10",
            "from_column": "id",
            "to_table": "zt_chart",
            "to_column": "dimension",
            "condition": "view_datasource_10.id = zt_chart.dimension",
            "confidence": "high",
            "reasoning": "Both fields are of type mediumint unsigned and the 'dimension' field in zt_chart likely refers to a reference or lookup value. Given that view_datasource_10 appears to be a lookup table of named entities, it is plausible that zt_chart.dimension references an id from view_datasource_10 to describe the dimension of a chart. However, there is no explicit foreign key or naming convention directly linking them, so this is an inferred business logic relationship.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_10 t1 JOIN zt_chart t2 ON t1.id = t2.dimension LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 120,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_10",
            "from_column": "id",
            "to_table": "zt_metriclib",
            "to_column": "metricID",
            "condition": "view_datasource_10.id = zt_metriclib.metricID",
            "confidence": "high",
            "reasoning": "The 'id' field in view_datasource_10 and the 'metricID' field in zt_metriclib are both of integer types (mediumint unsigned vs. mediumint). The business purpose of view_datasource_10 as a reference or lookup table and zt_metriclib as a metric repository suggests that metricID could reference a named entity from view_datasource_10. However, there is no explicit foreign key or naming convention directly linking them, so this is an inferred relationship based on common database design patterns and field compatibility.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_10 t1 JOIN zt_metriclib t2 ON t1.id = t2.metricID LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_10",
            "from_column": "id",
            "to_table": "zt_pivot",
            "to_column": "dimension",
            "condition": "view_datasource_10.id = zt_pivot.dimension",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and the 'dimension' field in zt_pivot likely refers to a reference or lookup entity. The business purpose of view_datasource_10 is to provide a list of named entities, which could serve as dimensions for pivots/reports. While there is no explicit foreign key, this is a common pattern in reporting systems.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_10 t1 JOIN zt_pivot t2 ON t1.id = t2.dimension LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_10",
            "from_column": "id",
            "to_table": "zt_screen",
            "to_column": "dimension",
            "condition": "view_datasource_10.id = zt_screen.dimension",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and the 'dimension' field in zt_screen is likely a reference to a lookup or reference entity. Given that view_datasource_10 appears to be a reference table of named items, it is plausible that zt_screen.dimension refers to an entry in view_datasource_10, possibly representing a type, category, or grouping for the screen. However, there is no explicit foreign key or naming convention directly linking the two, so this is an inferred relationship based on data type compatibility and common design patterns.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_10 t1 JOIN zt_screen t2 ON t1.id = t2.dimension LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_10",
            "from_column": "id",
            "to_table": "ztv_productstories",
            "to_column": "product",
            "condition": "view_datasource_10.id = ztv_productstories.product",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_10) and 'product' (ztv_productstories) are of type 'mediumint unsigned' and likely represent identifiers for entities. Given that view_datasource_10 appears to be a lookup/reference table and ztv_productstories tracks data per 'product', it is plausible that 'product' refers to an 'id' in view_datasource_10. This would be a common pattern where a fact/summary table references a dimension/lookup table for descriptive information.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_10 t1 JOIN ztv_productstories t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_10",
            "from_column": "id",
            "to_table": "ztv_productbugs",
            "to_column": "product",
            "condition": "view_datasource_10.id = ztv_productbugs.product",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_10) and 'product' (ztv_productbugs) are of type 'mediumint unsigned' and are not nullable, suggesting they may represent the same domain of entities. The business purpose of view_datasource_10 as a reference or lookup table for named entities aligns with the use of 'product' as an identifier in ztv_productbugs, which aggregates bug statistics per product. This is a common pattern where a lookup table provides descriptive names for codes used in a fact or summary table. However, the lack of explicit foreign key constraints and the generic naming of view_datasource_10 reduce the confidence to medium.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_10 t1 JOIN ztv_productbugs t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "zt_ai_miniprogramfield",
            "to_column": "appID",
            "condition": "view_datasource_11.id = zt_ai_miniprogramfield.appID",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and non-nullable. The 'appID' in zt_ai_miniprogramfield likely references an entity representing a mini-program or application. If view_datasource_11 is used as a lookup/reference table for such entities, it is plausible that its 'id' serves as the source for 'appID'. However, the table name 'view_datasource_11' is generic and does not explicitly indicate it represents mini-programs or applications, so the relationship is not certain.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_ai_miniprogramfield t2 ON t1.id = t2.appID LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 44,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "zt_chart",
            "to_column": "dimension",
            "condition": "view_datasource_11.id = zt_chart.dimension",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and the 'dimension' field in zt_chart likely refers to a dimension entity, which could be represented by the reference/lookup table view_datasource_11. This is a common pattern in analytics/reporting systems, where charts reference dimension definitions by ID. However, there is no explicit foreign key or naming convention directly linking them, so the confidence is not high.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_chart t2 ON t1.id = t2.dimension LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 182,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "zt_metriclib",
            "to_column": "metricID",
            "condition": "view_datasource_11.id = zt_metriclib.metricID",
            "confidence": "high",
            "reasoning": "The 'id' field in view_datasource_11 and the 'metricID' field in zt_metriclib are both integer types and could represent a mapping between a metric definition (in view_datasource_11) and metric values (in zt_metriclib). The naming convention suggests that 'metricID' may reference an external metric definition, and view_datasource_11 could serve as such a lookup table. However, there is no explicit foreign key or strong naming match, so this is an inferred relationship based on common database design patterns.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_metriclib t2 ON t1.id = t2.metricID LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "zt_pivot",
            "to_column": "dimension",
            "condition": "view_datasource_11.id = zt_pivot.dimension",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and the 'dimension' field in zt_pivot is likely intended to reference an external entity. Given that view_datasource_11 is a lookup/reference table with an 'id' and 'name', it is plausible that zt_pivot.dimension could reference view_datasource_11.id to associate a pivot/report with a specific named dimension or data source. However, there is no explicit foreign key or naming convention directly linking them, so this is an inferred relationship based on data type compatibility and common design patterns.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_pivot t2 ON t1.id = t2.dimension LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 29,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "zt_productplan",
            "to_column": "product",
            "condition": "view_datasource_11.id = zt_productplan.product",
            "confidence": "high",
            "reasoning": "Both 'view_datasource_11.id' and 'zt_productplan.product' are of type 'mediumint unsigned' and likely represent identifiers for entities. The business purpose of 'view_datasource_11' as a lookup/reference table and the 'product' field in 'zt_productplan' suggest a possible relationship where 'zt_productplan.product' references a product or entity listed in 'view_datasource_11'. However, the lack of explicit naming alignment (e.g., 'product' vs. 'id') and the generic name of 'view_datasource_11' reduce confidence. This is a common database pattern where a plan references a product/entity by ID.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_productplan t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "zt_screen",
            "to_column": "dimension",
            "condition": "view_datasource_11.id = zt_screen.dimension",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and the 'dimension' field in zt_screen is likely to reference a lookup or reference table. The business purpose of view_datasource_11 as a list of named entities fits the pattern of a dimension or category reference. However, there is no explicit foreign key or naming convention directly linking them, so this is an inferred relationship based on data type compatibility and common design patterns.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_screen t2 ON t1.id = t2.dimension LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "zt_usergroup",
            "to_column": "group",
            "condition": "view_datasource_11.id = zt_usergroup.group",
            "confidence": "high",
            "reasoning": "Both 'view_datasource_11.id' and 'zt_usergroup.group' are of type 'mediumint unsigned', and the 'group' field in 'zt_usergroup' likely refers to a group identifier. 'view_datasource_11' appears to be a lookup/reference table, possibly for group names or types. While there is no explicit foreign key, it is a common pattern for a user-group mapping table to reference a group definition table by ID. However, the generic name 'view_datasource_11' and lack of explicit naming alignment reduce confidence.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_usergroup t2 ON t1.id = t2.group LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "zt_zoutput",
            "to_column": "activity",
            "condition": "view_datasource_11.id = zt_zoutput.activity",
            "confidence": "high",
            "reasoning": "Both 'view_datasource_11.id' and 'zt_zoutput.activity' are of compatible integer types (mediumint), and the business logic suggests that 'view_datasource_11' could represent a list of named entities or activities, while 'zt_zoutput' stores outputs associated with an activity. Although there is no explicit foreign key, it is common for an 'activity' field to reference an 'id' in a lookup or reference table. The naming is not a perfect match, but the data types and business purposes align with a potential foreign key relationship.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_zoutput t2 ON t1.id = t2.activity LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 109,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "ztv_productbugs",
            "to_column": "product",
            "condition": "view_datasource_11.id = ztv_productbugs.product",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_11) and 'product' (ztv_productbugs) share the same data type (mediumint unsigned) and are likely to represent unique identifiers for entities. The business purpose of view_datasource_11 as a lookup/reference table for named entities aligns with ztv_productbugs aggregating bug statistics per product, where 'product' could reference the 'id' of a product in a lookup table. However, the table names do not explicitly confirm this relationship, so the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN ztv_productbugs t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "ztv_projectsummary",
            "to_column": "project",
            "condition": "view_datasource_11.id = ztv_projectsummary.project",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_11) and 'project' (ztv_projectsummary) are of type 'mediumint unsigned' and are non-nullable with default 0. The business purpose of view_datasource_11 as a lookup/reference table and ztv_projectsummary as a project summary table suggests that 'project' could reference an entity in view_datasource_11. However, the table/view naming ('view_datasource_11') is generic and does not explicitly indicate it stores projects, so the relationship is plausible but not certain.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN ztv_projectsummary t2 ON t1.id = t2.project LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "ztv_productstories",
            "to_column": "product",
            "condition": "view_datasource_11.id = ztv_productstories.product",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_11) and 'product' (ztv_productstories) are of type 'mediumint unsigned' and are non-nullable with default 0. The business purpose of view_datasource_11 is to provide a list of named entities, which could represent products. ztv_productstories tracks stories per product, and the 'product' field likely references a product identifier. The naming and data type alignment suggest a possible foreign key or lookup relationship, where 'product' in ztv_productstories refers to 'id' in view_datasource_11. However, the lack of explicit foreign key constraints and generic table/view naming reduces confidence.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN ztv_productstories t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "zt_metriclib",
            "to_column": "metricID",
            "condition": "view_datasource_12.id = zt_metriclib.metricID",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field of similar type (mediumint unsigned in view_datasource_12 and mediumint in zt_metriclib as 'metricID'). The business purpose of view_datasource_12 is to act as a catalog or lookup, while zt_metriclib stores metric values with a 'metricID' that likely references a catalog of metrics. This suggests a possible foreign key or lookup relationship where zt_metriclib.metricID refers to view_datasource_12.id.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN zt_metriclib t2 ON t1.id = t2.metricID LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "zt_pivot",
            "to_column": "dimension",
            "condition": "view_datasource_12.id = zt_pivot.dimension",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and the 'dimension' field in zt_pivot likely references an external entity or catalog. Given that view_datasource_12 is a catalog-like table with unique IDs, it is plausible that zt_pivot.dimension could reference view_datasource_12.id to indicate which catalog entry (e.g., data source, dimension, or entity) the pivot/report is associated with. However, there is no explicit foreign key or naming convention directly linking them, so this is an inferred relationship based on data type compatibility and business logic.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN zt_pivot t2 ON t1.id = t2.dimension LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "zt_productplan",
            "to_column": "product",
            "condition": "view_datasource_12.id = zt_productplan.product",
            "confidence": "high",
            "reasoning": "Both fields are of type mediumint unsigned and the 'product' field in zt_productplan is likely to reference a catalog of products. While the table name 'view_datasource_12' is generic, its schema (id, title) matches a typical lookup/reference table, which could serve as a product catalog. This is a common database design pattern, though not explicitly enforced by a foreign key.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN zt_productplan t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "ztv_productbugs",
            "to_column": "product",
            "condition": "view_datasource_12.id = ztv_productbugs.product",
            "confidence": "high",
            "reasoning": "Both 'id' in view_datasource_12 and 'product' in ztv_productbugs are of type mediumint unsigned and likely represent unique identifiers for entities. Given the business purposes, it is plausible that view_datasource_12 is a catalog of products or entities, and ztv_productbugs aggregates bug statistics per product. The naming convention ('product') and data type compatibility support this inferred relationship, though there is no explicit foreign key or product-specific naming in view_datasource_12, so confidence is not high.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN ztv_productbugs t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "ztv_productstories",
            "to_column": "product",
            "condition": "view_datasource_12.id = ztv_productstories.product",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_12) and 'product' (ztv_productstories) are of type 'mediumint unsigned' and likely represent unique identifiers for entities. Given that 'ztv_productstories' tracks stories per product and 'view_datasource_12' is a catalog of entities, it is plausible that 'product' refers to an entry in 'view_datasource_12'. However, the lack of explicit foreign keys and the generic naming of 'view_datasource_12' reduce confidence.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN ztv_productstories t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "id",
            "to_table": "zt_metriclib",
            "to_column": "metricID",
            "condition": "view_datasource_4.id = zt_metriclib.metricID",
            "confidence": "high",
            "reasoning": "Both fields are numeric and could represent a reference relationship: 'view_datasource_4.id' is a catalog of entities, and 'zt_metriclib.metricID' is a non-primary key field that may be used to categorize or identify the type of metric. The naming convention ('metricID') suggests it could reference an external catalog, and 'view_datasource_4' could serve as such a catalog. However, there is no explicit foreign key or clear business logic tying these together, so confidence is not high.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN zt_metriclib t2 ON t1.id = t2.metricID LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "id",
            "to_table": "zt_pivot",
            "to_column": "dimension",
            "condition": "view_datasource_4.id = zt_pivot.dimension",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and the 'dimension' field in zt_pivot likely refers to a reference entity. Given that view_datasource_4 appears to be a catalog or registry table, it is plausible that zt_pivot.dimension could reference view_datasource_4.id as a foreign key or lookup. However, there is no explicit foreign key constraint or naming convention directly linking them, so the relationship is inferred based on data type compatibility and business logic.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN zt_pivot t2 ON t1.id = t2.dimension LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 29,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "id",
            "to_table": "ztv_productbugs",
            "to_column": "product",
            "condition": "view_datasource_4.id = ztv_productbugs.product",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_4) and 'product' (ztv_productbugs) are of type 'mediumint unsigned' and are likely to represent unique identifiers for entities. The business purpose of view_datasource_4 as a catalog/registry and ztv_productbugs as a product bug summary table suggests that 'product' could reference an entity listed in view_datasource_4. However, there is no explicit foreign key or naming convention directly linking them, so this is an inferred relationship based on data type compatibility and common design patterns.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN ztv_productbugs t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "id",
            "to_table": "ztv_productstories",
            "to_column": "product",
            "condition": "view_datasource_4.id = ztv_productstories.product",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_4) and 'product' (ztv_productstories) are of type 'mediumint unsigned' and are likely to represent unique identifiers for entities. Given that 'ztv_productstories' tracks stories per product, and 'view_datasource_4' is a catalog of entities, it is plausible that 'product' references an entry in 'view_datasource_4'. However, the table and column names do not provide a direct semantic link (e.g., 'product' vs. 'id'), so the relationship is inferred based on data type compatibility and common design patterns.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN ztv_productstories t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "zt_metriclib",
            "to_column": "metricID",
            "condition": "view_datasource_41.id = zt_metriclib.metricID",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field (view_datasource_41.id) and a 'metricID' field (zt_metriclib.metricID) of compatible numeric types (mediumint unsigned vs mediumint). The business purpose of view_datasource_41 as a catalog/listing and zt_metriclib as a metric repository suggests that metricID in zt_metriclib could reference an entry in view_datasource_41, possibly describing the type or definition of the metric being recorded. However, there is no explicit foreign key or naming convention directly linking the two, so this is an inferred relationship based on common database design patterns.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN zt_metriclib t2 ON t1.id = t2.metricID LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "zt_pivot",
            "to_column": "dimension",
            "condition": "view_datasource_41.id = zt_pivot.dimension",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and the naming suggests that 'dimension' in zt_pivot could reference an entity or concept cataloged in view_datasource_41. This is a common pattern where a pivot/report references a dimension definition by ID. However, there is no explicit foreign key or naming convention directly linking the two, so the relationship is inferred based on data type compatibility and business logic.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN zt_pivot t2 ON t1.id = t2.dimension LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 29,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "zt_productplan",
            "to_column": "product",
            "condition": "view_datasource_41.id = zt_productplan.product",
            "confidence": "high",
            "reasoning": "Both fields are of type mediumint unsigned and likely represent unique identifiers. The 'product' field in zt_productplan is intended to reference a product entity, and view_datasource_41 could serve as a lookup or catalog of such entities. However, there is no explicit foreign key or naming convention directly linking them, so this is an inferred relationship based on data type compatibility and common business logic.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN zt_productplan t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "zt_weeklyreport",
            "to_column": "project",
            "condition": "view_datasource_41.id = zt_weeklyreport.project",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and could represent a relationship where 'view_datasource_41' acts as a catalog of projects or entities, and 'zt_weeklyreport.project' references the entity being reported on. However, there is no explicit foreign key or naming convention directly linking them, so this is an inferred relationship based on data type compatibility and common database design patterns.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN zt_weeklyreport t2 ON t1.id = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "ztv_productstories",
            "to_column": "product",
            "condition": "view_datasource_41.id = ztv_productstories.product",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_41) and 'product' (ztv_productstories) are of type 'mediumint unsigned' and likely represent unique identifiers for entities. Given the business purposes, it is plausible that 'view_datasource_41' catalogs products or entities, and 'ztv_productstories' tracks stories associated with those products. The naming convention and data type compatibility support this as a potential foreign key or reference relationship, even though no explicit foreign key is defined.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN ztv_productstories t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "ztv_productbugs",
            "to_column": "product",
            "condition": "view_datasource_41.id = ztv_productbugs.product",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_41) and 'product' (ztv_productbugs) are of type 'mediumint unsigned' and likely represent unique identifiers for entities. The business purpose of view_datasource_41 is to catalog entities (possibly products), while ztv_productbugs aggregates bug statistics per product. The most plausible relationship is that 'product' in ztv_productbugs refers to the 'id' in view_datasource_41, treating view_datasource_41 as a product reference table. However, the lack of explicit naming alignment (e.g., 'product' vs. 'id') and absence of foreign key constraints reduces confidence to medium.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN ztv_productbugs t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "ztv_projectsummary",
            "to_column": "project",
            "condition": "view_datasource_41.id = ztv_projectsummary.project",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_41) and 'project' (ztv_projectsummary) are of type 'mediumint unsigned' and are not nullable, suggesting they may represent the same domain (project or entity identifier). The business purpose of view_datasource_41 as a catalog/list and ztv_projectsummary as a project summary table supports the possibility that ztv_projectsummary.project references an entity in view_datasource_41. However, the lack of explicit foreign keys and the generic naming of view_datasource_41 prevent a high confidence level.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN ztv_projectsummary t2 ON t1.id = t2.project LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_5",
            "from_column": "id",
            "to_table": "zt_pivot",
            "to_column": "dimension",
            "condition": "view_datasource_5.id = zt_pivot.dimension",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and the 'dimension' field in zt_pivot is likely intended to reference an external entity. Given that view_datasource_5 is a lookup/reference table, it is plausible that zt_pivot.dimension could reference view_datasource_5.id to indicate the data source or dimension for the pivot/report. However, there is no explicit foreign key or naming convention directly linking them, so this is an inferred relationship based on data type compatibility and business logic.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_5 t1 JOIN zt_pivot t2 ON t1.id = t2.dimension LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 29,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_5",
            "from_column": "id",
            "to_table": "ztv_productstories",
            "to_column": "product",
            "condition": "view_datasource_5.id = ztv_productstories.product",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_5) and 'product' (ztv_productstories) are of type 'mediumint unsigned' and are likely to represent unique identifiers for entities. Given that 'ztv_productstories' tracks stories per product, and 'view_datasource_5' is a lookup/reference table, it is plausible that 'product' in 'ztv_productstories' refers to an entry in 'view_datasource_5'. However, the lack of explicit naming alignment (e.g., 'product' vs. 'id') and no foreign key constraints reduces confidence to medium.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_5 t1 JOIN ztv_productstories t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_5",
            "from_column": "id",
            "to_table": "ztv_productbugs",
            "to_column": "product",
            "condition": "view_datasource_5.id = ztv_productbugs.product",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_5) and 'product' (ztv_productbugs) are of compatible numeric types (mediumint unsigned) and serve as identifiers. The business purpose of view_datasource_5 as a reference/lookup table and ztv_productbugs as a product-level summary table suggests that 'product' could reference an entity in view_datasource_5. However, there is no explicit naming or schema evidence that 'id' and 'product' refer to the same domain, so the relationship is plausible but not certain.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_5 t1 JOIN ztv_productbugs t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "zt_metriclib",
            "to_column": "metricID",
            "condition": "view_datasource_6.id = zt_metriclib.metricID",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field of type mediumint (view_datasource_6.id and zt_metriclib.metricID). The business purpose of view_datasource_6 is to act as a catalog or lookup, while zt_metriclib stores metric values with a 'metricID' that likely references a catalog of metrics. This suggests a possible foreign key or lookup relationship where zt_metriclib.metricID refers to view_datasource_6.id. However, the relationship is not explicitly defined, and the naming is generic, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN zt_metriclib t2 ON t1.id = t2.metricID LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "zt_pivot",
            "to_column": "dimension",
            "condition": "view_datasource_6.id = zt_pivot.dimension",
            "confidence": "high",
            "reasoning": "Both fields are of compatible integer types (mediumint), and the 'dimension' field in zt_pivot likely refers to a dimension or entity definition. Given that view_datasource_6 appears to be a catalog or lookup table, it is plausible that zt_pivot.dimension references an entry in view_datasource_6. However, there is no explicit foreign key or naming convention directly linking them, so this is an inferred business logic relationship.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN zt_pivot t2 ON t1.id = t2.dimension LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 29,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "zt_productplan",
            "to_column": "product",
            "condition": "view_datasource_6.id = zt_productplan.product",
            "confidence": "high",
            "reasoning": "The 'id' field in view_datasource_6 and the 'product' field in zt_productplan are both of mediumint type and likely represent unique identifiers for entities. Given that zt_productplan's 'product' field is used to associate a plan with a product, and view_datasource_6 appears to be a catalog or lookup table, it is plausible that view_datasource_6 contains product definitions referenced by zt_productplan. However, the lack of explicit foreign keys and the generic naming of view_datasource_6 reduce confidence.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN zt_productplan t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "zt_searchindex",
            "to_column": "objectID",
            "condition": "view_datasource_6.id = zt_searchindex.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of compatible numeric types (mediumint), and zt_searchindex is designed to index various objects by their IDs. While objectType is present to distinguish between different object sources, with only these two tables provided, the most plausible relationship is that zt_searchindex.objectID could reference view_datasource_6.id for a specific objectType value. However, without knowing the value of objectType that would correspond to view_datasource_6, the relationship is inferred but not certain.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN zt_searchindex t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 25,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "zt_zoutput",
            "to_column": "activity",
            "condition": "view_datasource_6.id = zt_zoutput.activity",
            "confidence": "high",
            "reasoning": "Both fields are of compatible numeric types (mediumint), and the business purpose of view_datasource_6 as a catalog/list aligns with zt_zoutput.activity potentially referencing a type or category. While there is no explicit foreign key, it is common for an 'activity' field to reference an external catalog of activities or types. However, the lack of explicit naming alignment or foreign key constraint reduces confidence.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN zt_zoutput t2 ON t1.id = t2.activity LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "ztv_productstories",
            "to_column": "product",
            "condition": "view_datasource_6.id = ztv_productstories.product",
            "confidence": "high",
            "reasoning": "Both tables use a mediumint type for their respective fields ('id' in view_datasource_6 and 'product' in ztv_productstories). The business purpose of view_datasource_6 is to act as a catalog or reference list, which aligns with the likely use of 'product' as a reference to a product entity in ztv_productstories. This suggests a possible foreign key or lookup relationship, where ztv_productstories.product references view_datasource_6.id to associate stories with a specific product.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN ztv_productstories t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "ztv_productbugs",
            "to_column": "product",
            "condition": "view_datasource_6.id = ztv_productbugs.product",
            "confidence": "high",
            "reasoning": "Both tables have numeric fields ('id' in view_datasource_6 and 'product' in ztv_productbugs) of compatible types (mediumint and mediumint unsigned). The business purpose of view_datasource_6 as a catalog/list and ztv_productbugs as product-level bug statistics suggests that 'id' could represent a product/entity referenced by 'product' in the bug stats table. However, there is no explicit foreign key or naming convention directly linking them, so this is an inferred relationship based on common database design patterns and business logic.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN ztv_productbugs t2 ON t1.id = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "vision",
            "to_table": "zt_block",
            "to_column": "vision",
            "condition": "zt_action.vision = zt_block.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field of the same type and default value. While the business purposes differ (actions log events, blocks define dashboard widgets), the 'vision' field may represent a shared context or product line, allowing filtering or grouping of actions and blocks by the same vision. This is a logical/business logic relationship rather than a strict foreign key.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_block t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2376,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "execution",
            "to_table": "zt_burn",
            "to_column": "execution",
            "condition": "zt_action.execution = zt_burn.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same data type (mediumint unsigned), and both use it in a project management context. In zt_action, 'execution' represents the context of the action (e.g., a sprint or iteration), while in zt_burn, it identifies the execution for which burn data is tracked. This suggests a logical relationship where actions can be associated with the same execution as burn records.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_burn t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 162,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_build",
            "to_column": "project",
            "condition": "zt_action.project = zt_build.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and both are used to associate records with a project. It is common in project management systems for actions and builds to be linked to the same project entity. However, this relationship is not unique and may be too broad for direct foreign key usage, but it is logical for reporting or filtering actions and builds by project.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_build t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 67,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "execution",
            "to_table": "zt_build",
            "to_column": "execution",
            "condition": "zt_action.execution = zt_build.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same data type (mediumint unsigned), likely representing a phase or context within a project. Actions and builds may be grouped or filtered by execution context, making this a logical join for analysis or reporting, though not a strict foreign key relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_build t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 54,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "vision",
            "to_table": "zt_config",
            "to_column": "vision",
            "condition": "zt_action.vision = zt_config.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field of type varchar(10). In zt_action, 'vision' likely represents a context or scope for the action (e.g., product line, business unit, or application area). In zt_config, 'vision' is used to scope configuration settings. It is plausible that actions and configuration settings are grouped or filtered by the same 'vision' value, allowing for business logic joins (e.g., retrieving configuration relevant to the context of an action). However, there is no explicit foreign key or guarantee that the values are always aligned, so the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_config t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 297,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_bug",
            "to_column": "project",
            "condition": "zt_action.project = zt_bug.project AND zt_action.project != 0",
            "confidence": "high",
            "reasoning": "Both tables have a project field of the same type (mediumint unsigned), likely referencing the same project entity. This allows for analysis of all actions and bugs within the same project, though it is not a direct foreign key relationship between the two tables.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_bug t2 ON t1.project = t2.project AND t1.project != 0 LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 268,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "execution",
            "to_table": "zt_bug",
            "to_column": "execution",
            "condition": "zt_action.execution = zt_bug.execution AND zt_action.execution != 0",
            "confidence": "high",
            "reasoning": "Both tables have an execution field (mediumint unsigned), which likely refers to the same execution context (e.g., sprint, iteration). This enables correlation of actions and bugs within the same execution, but is not a direct object-to-object relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_bug t2 ON t1.execution = t2.execution AND t1.execution != 0 LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 216,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_group",
            "to_column": "project",
            "condition": "zt_action.project = zt_group.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and both use it to associate records with a specific project. In zt_action, 'project' identifies the project context of an action; in zt_group, it identifies the project to which a group belongs. This suggests a logical relationship where actions and groups can be linked by their shared project context, such as retrieving all groups relevant to actions within a project or vice versa. However, there is no explicit foreign key or direct business operation linking actions to groups, so the relationship is inferred based on shared context.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_group t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 640,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "execution",
            "to_table": "zt_kanbanlane",
            "to_column": "execution",
            "condition": "zt_action.execution = zt_kanbanlane.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of compatible types (mediumint unsigned vs mediumint). In zt_action, 'execution' represents the context in which an action occurred, while in zt_kanbanlane, it represents the Kanban board or workflow context to which the lane belongs. It is reasonable to infer that actions may be associated with a specific Kanban execution, and lanes are defined within the same execution context. However, there is no explicit foreign key or further evidence that these refer to the exact same entity, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_kanbanlane t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 165,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_effort",
            "to_column": "project",
            "condition": "zt_action.project = zt_effort.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same type (mediumint unsigned), and both are used to associate records with a project context. While this does not uniquely identify a record, it allows for grouping or filtering actions and efforts by project, which is a common reporting requirement.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_effort t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 201,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "execution",
            "to_table": "zt_effort",
            "to_column": "execution",
            "condition": "zt_action.execution = zt_effort.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field (mediumint unsigned) that likely refers to a phase or sprint within a project. This allows for correlating actions and efforts within the same execution context, which is useful for time tracking and progress analysis.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_effort t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 162,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_metriclib",
            "to_column": "project",
            "condition": "CAST(zt_action.project AS CHAR) = zt_metriclib.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field, which likely refers to the same business concept (a project entity). However, the data types differ: zt_action.project is a mediumint unsigned, while zt_metriclib.project is a char(30). This suggests that project IDs may be stored as numeric in one table and as strings in the other, or that the string field may contain numeric IDs. The relationship is plausible if the values are compatible, but this requires verification.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_metriclib t2 ON CAST(t1.project AS CHAR) = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3350,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "execution",
            "to_table": "zt_metriclib",
            "to_column": "execution",
            "condition": "CAST(zt_action.execution AS CHAR) = zt_metriclib.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field, which likely refers to the same business concept (an execution entity or phase). As with 'project', the data types differ (mediumint unsigned vs char(30)), but if the values are compatible, a relationship is plausible.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_metriclib t2 ON CAST(t1.execution AS CHAR) = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1836,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_projectproduct",
            "to_column": "project",
            "condition": "zt_action.project = zt_projectproduct.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned). In zt_action, 'project' identifies the project associated with an action; in zt_projectproduct, it is part of the composite primary key linking projects to products and branches. While this does not guarantee a direct foreign key relationship, it is logical to infer that actions related to a project could be joined to the project-product-branch associations for reporting or filtering purposes.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_projectproduct t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 134,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_projectcase",
            "to_column": "project",
            "condition": "zt_action.project = zt_projectcase.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and both are related to project-based activities. In zt_action, 'project' identifies the project associated with an action, while in zt_projectcase, 'project' identifies the project to which a test case is assigned. This suggests a logical relationship where actions may be filtered or analyzed in the context of project-case assignments.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_projectcase t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 268,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectType, objectID",
            "to_table": "zt_project",
            "to_column": "id",
            "condition": "zt_action.objectType = 'project' AND zt_action.objectID = zt_project.id",
            "confidence": "high",
            "reasoning": "The zt_action table is designed to log actions on various object types, with 'objectType' indicating the type and 'objectID' the specific object. If 'objectType' is 'project', then 'objectID' likely refers to zt_project.id. This is a common polymorphic association pattern in audit tables, but the actual values of 'objectType' are not enforced by schema, so this is inferred from naming and business logic.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_project t2 ON t1.objectType = 'project' AND t1.objectID = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "actor",
            "to_table": "zt_projectadmin",
            "to_column": "account",
            "condition": "zt_action.actor = zt_projectadmin.account",
            "confidence": "high",
            "reasoning": "Both fields represent user identifiers (actor/account) and are of compatible types (varchar(100) vs char(30)). It is plausible that actions are performed by users who may also be project administrators. However, there is no guarantee that all actors are admins or vice versa, and no explicit foreign key exists.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_projectadmin t2 ON t1.actor = t2.account LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 72,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectType, objectID",
            "to_table": "zt_storyreview",
            "to_column": "story",
            "condition": "zt_action.objectType = 'story' AND zt_action.objectID = zt_storyreview.story",
            "confidence": "high",
            "reasoning": "The zt_action table is a generic action log for various business objects, identified by objectType and objectID. The zt_storyreview table tracks reviews for stories, where 'story' is a likely business object. If zt_action.objectType is 'story', then objectID may correspond to zt_storyreview.story. This is a common pattern in audit logging for business objects. However, there is no explicit foreign key or version/reviewer linkage, so the relationship is inferred based on naming and business logic.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_storyreview t2 ON t1.objectType = 'story' AND t1.objectID = t2.story LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 20,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectID",
            "to_table": "zt_storyspec",
            "to_column": "story",
            "condition": "zt_action.objectType = 'story' AND zt_action.objectID = zt_storyspec.story",
            "confidence": "high",
            "reasoning": "The zt_action table logs actions on various business objects, identified by objectType and objectID. The zt_storyspec table contains versioned specifications for stories, with 'story' as the identifier. It is reasonable to infer that when zt_action.objectType = 'story', objectID refers to a story, which could correspond to zt_storyspec.story. However, there is no explicit foreign key or version linkage, so the relationship is inferred based on naming conventions and business logic.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_storyspec t2 ON t1.objectType = 'story' AND t1.objectID = t2.story LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 20,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectID",
            "to_table": "zt_taskspec",
            "to_column": "task",
            "condition": "zt_action.objectType = 'task' AND zt_action.objectID = zt_taskspec.task",
            "confidence": "high",
            "reasoning": "The zt_action table logs actions on various business objects, with objectType indicating the type of object and objectID as its identifier. The zt_taskspec table uses 'task' as its primary key. If objectType is set to 'task', then objectID likely refers to a task, which could correspond to zt_taskspec.task. This is a common pattern for generic action/audit tables referencing multiple object types.",
            "test_sql": "SELECT COUNT(*) FROM zt_action a JOIN zt_taskspec s ON a.objectType = 'task' AND a.objectID = s.task LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "actor",
            "to_table": "zt_team",
            "to_column": "account",
            "condition": "zt_action.actor = zt_team.account",
            "confidence": "high",
            "reasoning": "Both 'actor' in zt_action and 'account' in zt_team represent user identifiers (likely usernames or account IDs). Actions are performed by actors, and team assignments are made to accounts. While there is no explicit foreign key, it is logical to infer that actions performed by a user (actor) could be related to their team assignments (account). However, without further constraints (such as matching project/task/execution context), this relationship is only partially reliable.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_team t2 ON t1.actor = t2.account LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 276,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_team",
            "to_column": "root",
            "condition": "zt_action.project = zt_team.root AND zt_team.type = 'project'",
            "confidence": "high",
            "reasoning": "The 'project' field in zt_action and the 'root' field in zt_team (when type is 'project') are both unsigned mediumint and likely refer to the same project entity. This suggests that actions performed on a project (zt_action.project) can be related to team members assigned to that project (zt_team.root, type='project').",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_team t2 ON t1.project = t2.root AND t2.type = 'project' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 201,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "execution",
            "to_table": "zt_team",
            "to_column": "root",
            "condition": "zt_action.execution = zt_team.root AND zt_team.type = 'execution'",
            "confidence": "high",
            "reasoning": "The 'execution' field in zt_action and the 'root' field in zt_team (when type is 'execution') are both unsigned mediumint and likely refer to the same execution entity. This suggests that actions performed on an execution (zt_action.execution) can be related to team members assigned to that execution (zt_team.root, type='execution').",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_team t2 ON t1.execution = t2.root AND t2.type = 'execution' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 165,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_testtask",
            "to_column": "project",
            "condition": "zt_action.project = zt_testtask.project",
            "confidence": "high",
            "reasoning": "Both tables have a project field of the same type, likely referencing the same project entity. While this does not directly link a specific action to a specific test task, it allows for correlation of actions and test tasks within the same project. This is a common pattern for filtering or aggregating data by project context.",
            "test_sql": "SELECT COUNT(*) FROM zt_action a JOIN zt_testtask t ON a.project = t.project LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 67,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "execution",
            "to_table": "zt_testtask",
            "to_column": "execution",
            "condition": "zt_action.execution = zt_testtask.execution",
            "confidence": "high",
            "reasoning": "Both tables have an execution field of the same type, likely referencing the same execution or test cycle entity. This allows for correlation of actions and test tasks within the same execution context, which is useful for reporting or filtering.",
            "test_sql": "SELECT COUNT(*) FROM zt_action a JOIN zt_testtask t ON a.execution = t.execution LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 54,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_task",
            "to_column": "project",
            "condition": "zt_action.project = zt_task.project AND zt_action.project != 0",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same type, likely referencing the same project entity. While this does not uniquely identify a task, it allows for grouping or filtering actions and tasks by project. This is a looser, associative relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_action a JOIN zt_task t ON a.project = t.project AND a.project != 0 LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 536,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "execution",
            "to_table": "zt_task",
            "to_column": "execution",
            "condition": "zt_action.execution = zt_task.execution AND zt_action.execution != 0",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same type, likely referencing the same execution phase or sprint. This allows for associating actions and tasks within the same execution context, though it does not uniquely identify a task.",
            "test_sql": "SELECT COUNT(*) FROM zt_action a JOIN zt_task t ON a.execution = t.execution AND a.execution != 0 LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 432,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "actor",
            "to_table": "zt_usergroup",
            "to_column": "account",
            "condition": "zt_action.actor = zt_usergroup.account",
            "confidence": "high",
            "reasoning": "The 'actor' field in zt_action likely represents the user account that performed the action, while 'account' in zt_usergroup represents a user account associated with groups. Both are character fields and likely store user identifiers. This suggests a logical relationship where actions can be joined to user-group associations via the user account.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_usergroup t2 ON t1.actor = t2.account LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 20,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "actor",
            "to_table": "zt_userview",
            "to_column": "account",
            "condition": "zt_action.actor = zt_userview.account",
            "confidence": "high",
            "reasoning": "The 'actor' field in zt_action represents the user or system entity performing an action, while the 'account' field in zt_userview represents a user account. Both are string types and likely refer to user identifiers. This suggests a possible business logic relationship where actions performed by a user (actor) can be joined to that user's view configuration (account). However, there is no explicit foreign key or guarantee that all actors have a corresponding userview record, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_userview t2 ON t1.actor = t2.account LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 95,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "date",
            "to_table": "ztv_daybugresolve",
            "to_column": "day",
            "condition": "DATE(zt_action.date) = ztv_daybugresolve.day",
            "confidence": "high",
            "reasoning": "The zt_action table logs actions with a datetime field ('date'), and ztv_daybugresolve aggregates bug resolutions per day ('day'). While there is no explicit bug-related field in zt_action, it is plausible that actions representing bug resolutions are recorded in zt_action, and ztv_daybugresolve summarizes these by date. The only possible join is on the date, using DATE(zt_action.date) to match ztv_daybugresolve.day. This relationship is statistical/analytical, not a strict foreign key.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN ztv_daybugresolve t2 ON DATE(t1.date) = t2.day LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 96,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "date",
            "to_table": "ztv_daytaskopen",
            "to_column": "day",
            "condition": "DATE(zt_action.date) = ztv_daytaskopen.day",
            "confidence": "high",
            "reasoning": "The 'date' field in zt_action records the datetime of an action, while 'day' in ztv_daytaskopen represents a specific date for daily open task counts. Although there is no direct foreign key or explicit link, it is common in reporting and analytics to aggregate or join event logs (zt_action) to daily summary tables (ztv_daytaskopen) using the date. This enables analysis of actions performed on days with certain open task counts, or correlating activity with workload. The data types are compatible (date vs. datetime), and the business logic supports such a relationship for reporting or analytics purposes.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN ztv_daytaskopen t2 ON DATE(t1.date) = t2.day LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 96,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_actionrecent",
            "from_column": "vision",
            "to_table": "zt_config",
            "to_column": "vision",
            "condition": "zt_actionrecent.vision = zt_config.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field of the same type and length. In zt_actionrecent, 'vision' appears to categorize or scope actions, while in zt_config, it scopes configuration settings. It is plausible that actions and configurations are grouped or filtered by the same 'vision' value, allowing for business logic joins (e.g., retrieving configuration relevant to the context of an action). However, there is no explicit foreign key or guarantee that the values are always aligned, so the relationship is inferred based on naming and business logic.",
            "test_sql": "SELECT COUNT(*) FROM zt_actionrecent t1 JOIN zt_config t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_actionrecent",
            "from_column": "project",
            "to_table": "zt_group",
            "to_column": "project",
            "condition": "zt_actionrecent.project = zt_group.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same data type (mediumint unsigned), and both use it to associate records with a project context. In zt_actionrecent, 'project' identifies the project related to the action, while in zt_group, 'project' identifies the project to which the group belongs. This suggests a logical relationship where actions can be filtered or grouped by the project and its associated groups, though there is no explicit foreign key constraint.",
            "test_sql": "SELECT COUNT(*) FROM zt_actionrecent t1 JOIN zt_group t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 60,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_actionrecent",
            "from_column": "vision",
            "to_table": "zt_lang",
            "to_column": "vision",
            "condition": "zt_actionrecent.vision = zt_lang.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field of the same type and default value ('rnd'). In both business contexts, 'vision' appears to represent an application context or deployment variant. While not a foreign key, this field could be used to filter or join records relevant to a specific application vision, supporting multi-vision deployments or context-specific data presentation.",
            "test_sql": "SELECT COUNT(*) FROM zt_actionrecent t1 JOIN zt_lang t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 99,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_actionrecent",
            "from_column": "actor",
            "to_table": "zt_userview",
            "to_column": "account",
            "condition": "zt_actionrecent.actor = zt_userview.account",
            "confidence": "high",
            "reasoning": "Both fields represent user identifiers: 'actor' in zt_actionrecent logs the user who performed an action, while 'account' in zt_userview represents a user account. The data types (varchar(100) vs char(30)) are compatible for string comparison. This relationship allows joining recent actions to the user's view configuration, which could be useful for filtering actions based on the user's allowed entities or for displaying personalized activity feeds.",
            "test_sql": "SELECT COUNT(*) FROM zt_actionrecent t1 JOIN zt_userview t2 ON t1.actor = t2.account LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_actionrecent",
            "from_column": "date",
            "to_table": "ztv_dayactions",
            "to_column": "day",
            "condition": "DATE(zt_actionrecent.date) = ztv_dayactions.day",
            "confidence": "high",
            "reasoning": "The zt_actionrecent table logs individual actions with a datetime field ('date'), while ztv_dayactions aggregates the total number of actions per day ('day'). By extracting the date part from zt_actionrecent.date and matching it to ztv_dayactions.day, we can relate detailed action records to their daily summary. This is a common pattern in analytics and reporting, where detailed logs are joined to summary tables for validation or drill-down analysis.",
            "test_sql": "SELECT COUNT(*) FROM zt_actionrecent t1 JOIN ztv_dayactions t2 ON DATE(t1.date) = t2.day LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_ai_miniprogram",
            "from_column": "id",
            "to_table": "ztv_normalproduct",
            "to_column": "program",
            "condition": "zt_ai_miniprogram.id = ztv_normalproduct.program",
            "confidence": "high",
            "reasoning": "The 'program' field in ztv_normalproduct is a mediumint unsigned and matches the data type and likely business meaning of the 'id' field in zt_ai_miniprogram. Given the business purposes, it is plausible that each product (ztv_normalproduct) is associated with a specific AI mini-program (zt_ai_miniprogram), treating the mini-program as a 'program' entity. However, the naming is not a perfect match, and there is no explicit foreign key, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM zt_ai_miniprogram t1 JOIN ztv_normalproduct t2 ON t1.id = t2.program LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_ai_miniprogramfield",
            "from_column": "appID",
            "to_table": "ztv_normalproduct",
            "to_column": "id",
            "condition": "zt_ai_miniprogramfield.appID = ztv_normalproduct.id",
            "confidence": "high",
            "reasoning": "The field zt_ai_miniprogramfield.appID and ztv_normalproduct.id are both mediumint unsigned and likely represent a linkage where each mini-program field configuration (zt_ai_miniprogramfield) is associated with a specific product (ztv_normalproduct). The business logic suggests that a mini-program (or application form) could be tied to a product entity, and the naming convention (appID) is commonly used to reference an application or product identifier. However, the lack of explicit foreign key constraints and the difference in naming (appID vs id) reduce the confidence to medium.",
            "test_sql": "SELECT COUNT(*) FROM zt_ai_miniprogramfield t1 JOIN ztv_normalproduct t2 ON t1.appID = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 13,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_ai_prompt",
            "from_column": "module",
            "to_table": "zt_config",
            "to_column": "module",
            "condition": "zt_ai_prompt.module = zt_config.module",
            "confidence": "high",
            "reasoning": "Both tables have a 'module' field of type varchar(30), likely representing the same application module or functional area. zt_ai_prompt uses 'module' to categorize prompts, while zt_config uses it to scope configuration settings. This suggests a logical relationship where prompts and their configurations are grouped by module.",
            "test_sql": "SELECT COUNT(*) FROM zt_ai_prompt t1 JOIN zt_config t2 ON t1.module = t2.module LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_ai_prompt",
            "from_column": "module",
            "to_table": "zt_grouppriv",
            "to_column": "module",
            "condition": "zt_ai_prompt.module = zt_grouppriv.module",
            "confidence": "high",
            "reasoning": "Both tables have a 'module' field of similar type and length (varchar(30)/char(30)), and both use 'module' to represent a functional area or component of the application. In zt_ai_prompt, 'module' indicates the application module associated with the AI prompt; in zt_grouppriv, it specifies the module for which a group has privileges. This suggests a logical relationship where prompts may be associated with modules that are also subject to access control. However, there is no explicit foreign key or guarantee that the values match exactly, so the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM zt_ai_prompt t1 JOIN zt_grouppriv t2 ON t1.module = t2.module LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2326,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_ai_prompt",
            "from_column": "module",
            "to_table": "zt_module",
            "to_column": "name",
            "condition": "zt_ai_prompt.module = zt_module.name",
            "confidence": "high",
            "reasoning": "The 'module' field in zt_ai_prompt likely refers to the name of a module in the system, which is represented by the 'name' field in zt_module. Both are string types and the business logic suggests prompts may be associated with specific modules. However, there is no explicit foreign key or enforced constraint, and the data types (varchar(30) vs char(60)) are compatible but not identical. This is a common pattern for loosely coupled relationships based on naming conventions.",
            "test_sql": "SELECT COUNT(*) FROM zt_ai_prompt t1 JOIN zt_module t2 ON t1.module = t2.name LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 12,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_approvalflow",
            "from_column": "version",
            "to_table": "zt_approvalflowspec",
            "to_column": "version",
            "condition": "zt_approvalflow.version = zt_approvalflowspec.version",
            "confidence": "high",
            "reasoning": "Both tables have a 'version' field of the same type, suggesting that versioning is tracked in both. However, version alone is not unique and only makes sense in combination with the flow/id relationship. This could be used to join on both flow/id and version to get a specific version of a flow's specification.",
            "test_sql": "SELECT COUNT(*) FROM zt_approvalflow t1 JOIN zt_approvalflowspec t2 ON t1.id = t2.flow AND t1.version = t2.version LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_approvalflowobject",
            "from_column": "flow",
            "to_table": "zt_approvalflowspec",
            "to_column": "flow",
            "condition": "zt_approvalflowobject.flow = zt_approvalflowspec.flow",
            "confidence": "high",
            "reasoning": "Both tables contain a 'flow' field of integer type, and both use it to reference an approval flow. In zt_approvalflowobject, 'flow' identifies which approval flow is associated with a business object; in zt_approvalflowspec, 'flow' identifies the approval flow being defined or versioned. This suggests a logical relationship where objects are linked to a flow, and the flow's specification is stored in the other table. However, there is no explicit foreign key or version linkage, so the relationship is at the flow level, not at the version or specification level.",
            "test_sql": "SELECT COUNT(*) FROM zt_approvalflowobject t1 JOIN zt_approvalflowspec t2 ON t1.flow = t2.flow LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "vision",
            "to_table": "zt_group",
            "to_column": "vision",
            "condition": "zt_block.vision = zt_group.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field of the same type and default value, likely representing a business context, product line, or application area. While this does not establish a strict foreign key, it is plausible that dashboard blocks and groups are segmented or filtered by the same vision context for reporting or access control purposes.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_group t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 351,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "module",
            "to_table": "zt_grouppriv",
            "to_column": "module",
            "condition": "zt_block.module = zt_grouppriv.module",
            "confidence": "high",
            "reasoning": "Both tables have a 'module' field of similar type and naming, representing a functional area or component of the system. In business logic, dashboard blocks (zt_block) are associated with modules, and group privileges (zt_grouppriv) are granted per module. This suggests a logical relationship where blocks may be filtered or displayed based on group access to modules.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_grouppriv t2 ON t1.module = t2.module LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7162,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "account",
            "to_table": "zt_config",
            "to_column": "owner",
            "condition": "zt_block.account = zt_config.owner",
            "confidence": "high",
            "reasoning": "Both 'account' in zt_block and 'owner' in zt_config are char(30) fields and likely represent user or entity identifiers. zt_block stores dashboard blocks per account, while zt_config stores configuration per owner. It is plausible that configuration settings in zt_config could apply to the same account referenced in zt_block, supporting user-specific dashboard or module settings.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_config t2 ON t1.account = t2.owner LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 444,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "module",
            "to_table": "zt_config",
            "to_column": "module",
            "condition": "zt_block.module = zt_config.module",
            "confidence": "high",
            "reasoning": "Both tables have a 'module' field (varchar(20) vs varchar(30)), likely representing the same application module or functional area. zt_block associates blocks with modules, and zt_config stores configuration per module. This suggests a logical relationship where blocks and configuration can be joined by module for module-specific settings or display.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_config t2 ON t1.module = t2.module LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 46,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "vision",
            "to_table": "zt_config",
            "to_column": "vision",
            "condition": "zt_block.vision = zt_config.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field (varchar(10)), which likely represents a product line, business context, or application area. This field could be used to scope both dashboard blocks and configuration settings, enabling filtering or joining by vision for context-specific customization.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_config t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 85,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "account, module, vision",
            "to_table": "zt_config",
            "to_column": "owner, module, vision",
            "condition": "zt_block.account = zt_config.owner AND zt_block.module = zt_config.module AND zt_block.vision = zt_config.vision",
            "confidence": "high",
            "reasoning": "Combining the above fields, it is plausible that configuration settings in zt_config could be scoped to a specific user (account/owner), module, and vision, matching the context of a dashboard block in zt_block. This composite join would allow retrieval of configuration settings relevant to a specific block's context.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_config t2 ON t1.account = t2.owner AND t1.module = t2.module AND t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 10,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "vision",
            "to_table": "zt_effort",
            "to_column": "vision",
            "condition": "zt_block.vision = zt_effort.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field of the same type and default value. This likely represents a product line, business area, or application context. Relating blocks and efforts by vision could be useful for filtering or aggregating data within the same business context.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_effort t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 72,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "vision",
            "to_table": "zt_lang",
            "to_column": "vision",
            "condition": "zt_block.vision = zt_lang.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field (varchar(10)), likely representing a product line, deployment context, or application area. This field could be used to filter or join data relevant to a specific vision, supporting multi-vision deployments.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_lang t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 792,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "vision",
            "to_table": "zt_project",
            "to_column": "vision",
            "condition": "zt_block.vision = zt_project.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field of the same type and default value ('rnd'). In business context, 'vision' likely represents a product line, business area, or application context. Dashboard blocks and projects may be filtered or grouped by the same 'vision', allowing users to see blocks and projects relevant to a particular business area. However, this is a logical grouping rather than a strict foreign key relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_project t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 96,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "vision",
            "to_table": "zt_product",
            "to_column": "vision",
            "condition": "zt_block.vision = zt_product.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field of the same type and default value ('rnd'). In business context, 'vision' likely represents a product line, business area, or application context. Dashboard blocks may be filtered or grouped by vision, and products are also categorized by vision. This suggests a logical grouping or filtering relationship, not a strict foreign key.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_product t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 48,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "vision",
            "to_table": "zt_story",
            "to_column": "vision",
            "condition": "zt_block.vision = zt_story.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field of the same type and default value. In both business contexts, 'vision' appears to represent a product line, application area, or context. While not a strict foreign key, it is plausible that dashboard blocks and stories are filtered or grouped by the same 'vision', supporting business logic such as displaying only relevant stories in a user's dashboard blocks.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_story t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 168,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "vision",
            "to_table": "zt_task",
            "to_column": "vision",
            "condition": "zt_block.vision = zt_task.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field of the same type and default value ('rnd'). While the business meaning of 'vision' is not fully clear from the schemas, it is plausible that both dashboard blocks and tasks are segmented or filtered by the same 'vision' (e.g., product line, business area, or application context). This could be used to display only relevant blocks and tasks for a given vision context.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_task t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 192,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "vision",
            "to_table": "ztv_normalproduct",
            "to_column": "vision",
            "condition": "zt_block.vision = ztv_normalproduct.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field of the same type and default value ('rnd'). In business context, 'vision' likely represents a product line, business area, or application context. Dashboard blocks (zt_block) may be filtered or grouped by vision, and products (ztv_normalproduct) may also be categorized by vision. This suggests a logical grouping or filtering relationship, though not a strict foreign key.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN ztv_normalproduct t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 48,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "project",
            "to_table": "zt_effort",
            "to_column": "project",
            "condition": "zt_bug.project = zt_effort.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of compatible types, and both are used to track entities within the context of a project. While this does not directly link a specific bug to a specific effort, it allows for aggregation or filtering of bugs and efforts within the same project. This is a common pattern for reporting or analytics, but not a strict foreign key relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_effort t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 12,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "execution",
            "to_table": "zt_effort",
            "to_column": "execution",
            "condition": "zt_bug.execution = zt_effort.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field, likely representing a phase or sprint within a project. This allows for grouping or joining bugs and efforts by execution context, which is useful for progress tracking and reporting. However, it does not represent a direct entity-to-entity relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_effort t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 12,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "execution",
            "to_table": "zt_build",
            "to_column": "execution",
            "condition": "zt_bug.execution = zt_build.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field (mediumint unsigned). In many ALM systems, 'execution' refers to a test run or sprint, and both bugs and builds may be associated with the same execution context. However, the exact semantics may vary, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_build t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "product",
            "to_table": "zt_doclib",
            "to_column": "product",
            "condition": "zt_bug.product = zt_doclib.product AND zt_bug.product != 0 AND zt_doclib.product != 0",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same data type (mediumint unsigned), and both use it to associate records with a product entity. While there is no explicit foreign key, it is common in business logic for bugs and document libraries to be associated with the same product. This allows for potential reporting or filtering of bugs and documentation by product.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_doclib t2 ON t1.product = t2.product WHERE t1.product != 0 AND t2.product != 0 LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "project",
            "to_table": "zt_doclib",
            "to_column": "project",
            "condition": "zt_bug.project = zt_doclib.project AND zt_bug.project != 0 AND zt_doclib.project != 0",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field (mediumint unsigned) that likely references the same project entity. Bugs are tracked per project, and document libraries can be organized per project. This relationship is logical for aggregating or correlating bugs and documentation within the same project context.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_doclib t2 ON t1.project = t2.project WHERE t1.project != 0 AND t2.project != 0 LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 12,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "execution",
            "to_table": "zt_doclib",
            "to_column": "execution",
            "condition": "zt_bug.execution = zt_doclib.execution AND zt_bug.execution != 0 AND zt_doclib.execution != 0",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field (mediumint unsigned), which likely refers to a specific execution or iteration within a project. Bugs and document libraries can both be associated with a particular execution, making this a plausible business logic relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_doclib t2 ON t1.execution = t2.execution WHERE t1.execution != 0 AND t2.execution != 0 LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "execution",
            "to_table": "zt_kanbanlane",
            "to_column": "execution",
            "condition": "zt_bug.execution = zt_kanbanlane.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of compatible data types (mediumint/mediumint unsigned). In the context of project management, 'execution' likely refers to a specific phase, sprint, or board instance. Bugs may be tracked within a particular execution context, and Kanban lanes are defined per execution. This suggests a logical grouping where bugs and Kanban lanes can be associated via the same execution context, though there is no explicit foreign key.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_kanbanlane t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 12,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "product",
            "to_table": "zt_productplan",
            "to_column": "product",
            "condition": "zt_bug.product = zt_productplan.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same type and name, suggesting that bugs and product plans are both associated with the same product entity. While this does not directly link a bug to a specific plan, it allows for grouping or filtering bugs and plans by product. This is a logical, but not a direct foreign key relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_productplan t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "project",
            "to_table": "zt_metriclib",
            "to_column": "project",
            "condition": "CAST(zt_bug.project AS CHAR) = zt_metriclib.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field, which likely refers to the same business entity (a project). However, the data types differ: zt_bug.project is a mediumint unsigned, while zt_metriclib.project is a char(30). This suggests that the project ID in zt_bug may be stored as a numeric value, while in zt_metriclib it is stored as a string (possibly the same numeric ID as a string, or a code). The naming and business context suggest a logical relationship, but the data type mismatch reduces confidence.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_metriclib t2 ON CAST(t1.project AS CHAR) = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 200,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "product",
            "to_table": "zt_metriclib",
            "to_column": "product",
            "condition": "CAST(zt_bug.product AS CHAR) = zt_metriclib.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field, which likely refers to the same business entity (a product). The data types differ (mediumint unsigned vs char(30)), but the field names and business context suggest a logical relationship. The data type mismatch reduces confidence.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_metriclib t2 ON CAST(t1.product AS CHAR) = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 128,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "execution",
            "to_table": "zt_metriclib",
            "to_column": "execution",
            "condition": "CAST(zt_bug.execution AS CHAR) = zt_metriclib.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field, which likely refers to the same business concept (an execution or run of a project or plan). The data types differ (mediumint unsigned vs char(30)), but the field names and business context suggest a logical relationship. The data type mismatch reduces confidence.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_metriclib t2 ON CAST(t1.execution AS CHAR) = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 136,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "project",
            "to_table": "zt_projectadmin",
            "to_column": "projects",
            "condition": "FIND_IN_SET(CAST(zt_bug.project AS CHAR), zt_projectadmin.projects) > 0",
            "confidence": "high",
            "reasoning": "The zt_bug table has a 'project' field (numeric ID) and zt_projectadmin has a 'projects' text field, which likely contains a comma-separated list of project IDs over which the admin has privileges. This suggests a logical relationship where a bug's project can be matched to an admin's scope. However, the relationship is not a direct foreign key and depends on the text format of 'projects'.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_projectadmin t2 ON FIND_IN_SET(CAST(t1.project AS CHAR), t2.projects) > 0 LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "branch",
            "to_table": "zt_projectstory",
            "to_column": "branch",
            "condition": "zt_bug.branch = zt_projectstory.branch",
            "confidence": "high",
            "reasoning": "Both tables have a 'branch' field of the same data type. While not a primary key in either table, it is plausible that bugs and stories are tracked per branch (e.g., feature or release branch). However, without more context, the direct business relationship is less certain.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_projectstory t2 ON t1.branch = t2.branch LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 32,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "product",
            "to_table": "zt_projectstory",
            "to_column": "product",
            "condition": "zt_bug.product = zt_projectstory.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same data type. Bugs and stories are both associated with products, so joining on this field could be useful for product-level reporting, though it is less granular than project or story.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_projectstory t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 32,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "story, storyVersion",
            "to_table": "zt_projectstory",
            "to_column": "story, version",
            "condition": "zt_bug.story = zt_projectstory.story AND zt_bug.storyVersion = zt_projectstory.version",
            "confidence": "high",
            "reasoning": "zt_bug tracks the version of the story via 'storyVersion', and zt_projectstory tracks the version via 'version'. This join would allow analysis of bugs against the specific version of a story included in a project. The data types are compatible, and the business logic supports versioned requirements.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_projectstory t2 ON t1.story = t2.story AND t1.storyVersion = t2.version LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "task",
            "to_table": "zt_taskspec",
            "to_column": "task",
            "condition": "zt_bug.task = zt_taskspec.task",
            "confidence": "high",
            "reasoning": "Both tables contain a 'task' field of compatible data types (mediumint/mediumint). In zt_bug, 'task' likely references a task entity, and in zt_taskspec, 'task' is the primary key (with version) representing a specific task's specification. It is reasonable to infer that a bug may be associated with a task, and that task may have specifications in zt_taskspec. However, there is no explicit foreign key or versioning link, so the relationship is not certain.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_taskspec t2 ON t1.task = t2.task LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "project",
            "to_table": "zt_team",
            "to_column": "root",
            "condition": "zt_bug.project = zt_team.root AND zt_team.type = 'project'",
            "confidence": "high",
            "reasoning": "Both zt_bug.project and zt_team.root are mediumint unsigned fields and likely refer to the same project entity. zt_team.type distinguishes the context, so only rows where type = 'project' are relevant. This is a common pattern for associating bugs with the teams working on the same project.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_team t2 ON t1.project = t2.root AND t2.type = 'project' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 12,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "execution",
            "to_table": "zt_team",
            "to_column": "root",
            "condition": "zt_bug.execution = zt_team.root AND zt_team.type = 'execution'",
            "confidence": "high",
            "reasoning": "zt_bug.execution and zt_team.root are both mediumint unsigned and likely refer to the same execution entity. zt_team.type = 'execution' ensures the context matches. This allows analysis of which team members are associated with the execution where the bug was found or is being addressed.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_team t2 ON t1.execution = t2.root AND t2.type = 'execution' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 12,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "task",
            "to_table": "zt_testrun",
            "to_column": "task",
            "condition": "zt_bug.task = zt_testrun.task AND zt_bug.task != 0",
            "confidence": "high",
            "reasoning": "Both tables have a 'task' field of type mediumint unsigned. In the context of software testing and bug tracking, a 'task' could represent a testing activity or assignment. While the business meaning is less direct than 'case', the matching field name and type suggest a possible relationship, such as bugs being linked to the testing task during which they were found.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_testrun t2 ON t1.task = t2.task WHERE t1.task != 0 LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "project",
            "to_table": "zt_task",
            "to_column": "project",
            "condition": "zt_bug.project = zt_task.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field (mediumint unsigned), suggesting that bugs and tasks can be associated with the same project. While this does not represent a direct foreign key relationship, it is a common business logic join for reporting or filtering all bugs and tasks within a project.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_task t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 32,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "execution",
            "to_table": "zt_task",
            "to_column": "execution",
            "condition": "zt_bug.execution = zt_task.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field (mediumint unsigned), likely representing a phase or sprint. This allows for joining bugs and tasks within the same execution context, which is useful for sprint or phase-based reporting.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_task t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 32,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "story",
            "to_table": "zt_task",
            "to_column": "story",
            "condition": "zt_bug.story = zt_task.story",
            "confidence": "high",
            "reasoning": "Both tables have a 'story' field (mediumint unsigned), suggesting that bugs and tasks can be linked to the same user story or requirement. This is a logical join for aggregating all work (bugs and tasks) related to a specific story.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_task t2 ON t1.story = t2.story LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "resolvedDate",
            "to_table": "ztv_daybugresolve",
            "to_column": "day",
            "condition": "DATE(zt_bug.resolvedDate) = ztv_daybugresolve.day",
            "confidence": "high",
            "reasoning": "The ztv_daybugresolve table appears to be a daily aggregation of bug resolutions, while zt_bug contains the detailed resolution date for each bug. By matching the date part of zt_bug.resolvedDate to ztv_daybugresolve.day, we can relate individual bug resolutions to the daily summary. This is a common statistical aggregation pattern, though there is no explicit foreign key.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN ztv_daybugresolve t2 ON DATE(t1.resolvedDate) = t2.day LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "story",
            "to_table": "ztv_projectstories",
            "to_column": "stories",
            "condition": "zt_bug.story = ztv_projectstories.stories",
            "confidence": "high",
            "reasoning": "The 'story' field in zt_bug and the 'stories' field in ztv_projectstories both likely refer to user stories or work items. Although the data types differ (mediumint unsigned vs bigint), the business logic suggests a possible link between bugs and the stories they are associated with. This relationship would allow analysis of bugs per story.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN ztv_projectstories t2 ON t1.story = t2.stories LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "execution",
            "to_table": "zt_kanbanlane",
            "to_column": "execution",
            "condition": "zt_build.execution = zt_kanbanlane.execution",
            "confidence": "high",
            "reasoning": "Both tables contain an 'execution' field of compatible types (mediumint unsigned vs mediumint). In zt_build, 'execution' likely refers to the context or phase in which a build occurs, while in zt_kanbanlane, 'execution' appears to represent the Kanban board or workflow context to which the lane belongs. It is plausible that builds are associated with a specific execution context, and Kanban lanes are organized by the same context, allowing for a logical join on this field. However, without explicit foreign key constraints or more detailed business rules, the relationship is inferred based on naming and typical project management patterns.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_kanbanlane t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "project",
            "to_table": "zt_metriclib",
            "to_column": "project",
            "condition": "CAST(zt_build.project AS CHAR) = zt_metriclib.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field, which likely refers to the same business entity (a project). However, the data types differ: zt_build.project is a numeric (mediumint unsigned), while zt_metriclib.project is a char(30). This suggests a possible relationship, but the type mismatch reduces confidence. The relationship is based on business logic and naming convention.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_metriclib t2 ON CAST(t1.project AS CHAR) = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 50,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "product",
            "to_table": "zt_metriclib",
            "to_column": "product",
            "condition": "CAST(zt_build.product AS CHAR) = zt_metriclib.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field, which likely refers to the same business entity (a product). The data types differ (numeric vs char), but the naming and business context suggest a logical relationship. This is a common pattern in reporting/analytics systems.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_metriclib t2 ON CAST(t1.product AS CHAR) = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 32,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "execution",
            "to_table": "zt_metriclib",
            "to_column": "execution",
            "condition": "CAST(zt_build.execution AS CHAR) = zt_metriclib.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field, which likely refers to an execution context or phase. The data types differ (numeric vs char), but the naming and business context suggest a possible relationship, especially for aggregating metrics by execution.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_metriclib t2 ON CAST(t1.execution AS CHAR) = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 34,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "project",
            "to_table": "zt_projectadmin",
            "to_column": "projects",
            "condition": "FIND_IN_SET(CAST(zt_build.project AS CHAR), REPLACE(REPLACE(REPLACE(zt_projectadmin.projects, '[', ''), ']', ''), '\"', '')) > 0",
            "confidence": "high",
            "reasoning": "The zt_build table has a 'project' field (numeric ID) and zt_projectadmin has a 'projects' text field, which likely stores a list of project IDs (possibly as a comma-separated string or JSON array). This suggests a business logic relationship: builds are associated with projects, and project admins may have rights over those projects. The relationship is not a direct foreign key but can be inferred via string matching.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_projectadmin t2 ON FIND_IN_SET(CAST(t1.project AS CHAR), REPLACE(REPLACE(REPLACE(t2.projects, '[', ''), ']', ''), '\"', '')) > 0 LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "branch",
            "to_table": "zt_productplan",
            "to_column": "branch",
            "condition": "zt_build.branch = zt_productplan.branch",
            "confidence": "high",
            "reasoning": "Both tables have a 'branch' field (varchar(255)), which likely refers to a code or product branch. Builds are often associated with specific branches, and product plans may also be organized by branch. However, the field is a string and may not always match exactly, so the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_productplan t2 ON t1.branch = t2.branch LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "product",
            "to_table": "zt_projectcase",
            "to_column": "product",
            "condition": "zt_build.product = zt_projectcase.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same data type, and both use it to represent the product context. While 'product' is not a primary key in either table, it is likely that builds and test cases are both associated with specific products. This relationship could be useful for filtering or aggregating data by product, but is less direct than the project-based relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_projectcase t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "['project', 'product']",
            "to_table": "zt_projectproduct",
            "to_column": "['project', 'product']",
            "condition": "zt_build.project = zt_projectproduct.project AND zt_build.product = zt_projectproduct.product",
            "confidence": "high",
            "reasoning": "Both tables contain 'project' and 'product' fields with identical names and compatible data types. The business logic suggests that builds are associated with specific projects and products, and zt_projectproduct defines valid project-product (and branch) combinations. However, zt_build.branch is varchar while zt_projectproduct.branch is mediumint, so a full three-way match is not possible without data transformation. Thus, a two-field join is plausible for associating builds with their project-product context.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_projectproduct t2 ON t1.project = t2.project AND t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "product",
            "to_table": "zt_projectstory",
            "to_column": "product",
            "condition": "zt_build.product = zt_projectstory.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same data type, and both use it to represent the product context. While not a direct foreign key, it is common for builds and project stories to be grouped or filtered by product. This relationship is logical for reporting or filtering, but not necessarily a strict foreign key relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_projectstory t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "id",
            "to_table": "zt_searchindex",
            "to_column": "objectID",
            "condition": "zt_build.id = zt_searchindex.objectID AND zt_searchindex.objectType = 'build'",
            "confidence": "high",
            "reasoning": "The zt_searchindex table is designed as a polymorphic search index, where objectType indicates the type of object being indexed and objectID is the identifier of that object. Given the business purpose and naming conventions, it is likely that builds are indexed for search, with objectType set to 'build' (or a similar value) and objectID referencing zt_build.id. This is a common pattern for search indexing in business applications.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_searchindex t2 ON t1.id = t2.objectID WHERE t2.objectType = 'build' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "stories",
            "to_table": "zt_storyreview",
            "to_column": "story",
            "condition": "FIND_IN_SET(CAST(zt_storyreview.story AS CHAR), zt_build.stories) > 0",
            "confidence": "high",
            "reasoning": "The zt_build table has a 'stories' field (text, likely a comma-separated list of story IDs) and zt_storyreview has a 'story' field (story ID). It is plausible that builds are linked to stories, and story reviews are linked to stories as well. While there is no direct foreign key, a business logic relationship exists: builds may reference stories, and those stories may have reviews. The data types are compatible if 'stories' is a list of IDs. This is a business_logic relationship, not a strict foreign key.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_storyreview t2 ON FIND_IN_SET(CAST(t2.story AS CHAR), t1.stories) > 0 LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "stories",
            "to_table": "zt_storyspec",
            "to_column": "story",
            "condition": "FIND_IN_SET(CAST(zt_storyspec.story AS CHAR), zt_build.stories) > 0",
            "confidence": "high",
            "reasoning": "The zt_build table has a 'stories' field (text, likely a comma-separated list of story IDs) and zt_storyspec has a 'story' field (the story ID). It is common in project management systems for builds to reference the stories they implement or affect. Although there is no explicit foreign key, the naming and business logic suggest that zt_build.stories contains references to zt_storyspec.story. The data types are compatible if stories is a list of integers and story is an integer. The relationship is not direct (not normalized), but is a common denormalized pattern.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_storyspec t2 ON FIND_IN_SET(CAST(t2.story AS CHAR), t1.stories) > 0 LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "product",
            "to_table": "zt_story",
            "to_column": "product",
            "condition": "zt_build.product = zt_story.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of type mediumint unsigned, and both use it to associate records with a product. In zt_build, 'product' links a build to a product, while in zt_story, 'product' links a story to a product. This is a common pattern in software lifecycle management systems, where builds and stories are both scoped to products. However, without explicit foreign keys or further context, the relationship is inferred based on naming, data type, and business logic.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_story t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "project",
            "to_table": "zt_team",
            "to_column": "root",
            "condition": "zt_build.project = zt_team.root AND zt_team.type = 'project'",
            "confidence": "high",
            "reasoning": "Both tables have fields that reference a 'project' context: zt_build.project (the project to which a build belongs) and zt_team.root (the entity to which a team member is assigned, with type indicating the entity type). When zt_team.type = 'project', root likely refers to a project ID, which could match zt_build.project. Data types are compatible (mediumint unsigned). This is a common pattern in project management systems, but the relationship is not explicit and depends on the business logic of how 'project' and 'root' are used.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_team t2 ON t1.project = t2.root AND t2.type = 'project' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "execution",
            "to_table": "zt_team",
            "to_column": "root",
            "condition": "zt_build.execution = zt_team.root AND zt_team.type = 'execution'",
            "confidence": "high",
            "reasoning": "zt_build.execution references an execution context, and zt_team.root can reference an execution when zt_team.type = 'execution'. Both are mediumint unsigned. This suggests a possible relationship where builds are associated with executions, and team members are assigned to those executions. The relationship is logical but not explicit.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_team t2 ON t1.execution = t2.root AND t2.type = 'execution' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "date",
            "to_table": "ztv_daybugopen",
            "to_column": "day",
            "condition": "zt_build.date = ztv_daybugopen.day",
            "confidence": "high",
            "reasoning": "Both fields represent dates and could be used to correlate builds created on a specific day with the number of bugs opened on that same day. This relationship is not enforced by a foreign key, but is a common business logic pattern for time-based reporting or analysis. However, the relationship is not direct or structural, but rather statistical/logical for reporting purposes.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN ztv_daybugopen t2 ON t1.date = t2.day LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "id",
            "to_table": "zt_testtask",
            "to_column": "build",
            "condition": "zt_build.id = zt_testtask.build",
            "confidence": "high",
            "reasoning": "The 'zt_testtask' table has a 'build' column, which by naming convention likely refers to a build record. In 'zt_build', the primary key is 'id'. However, the data types differ: 'zt_build.id' is a numeric auto-increment field, while 'zt_testtask.build' is a char(30). This suggests that 'build' in 'zt_testtask' may store the build's id as a string, or possibly a build name or a comma-separated list. If the system stores the build id as a string in 'build', a join is possible. This is a common pattern in systems where foreign keys are not strictly enforced. The confidence is medium due to the data type mismatch and possible ambiguity in what 'build' stores.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_testtask t2 ON t1.id = t2.build LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "execution",
            "to_table": "zt_kanbanlane",
            "to_column": "execution",
            "condition": "zt_burn.execution = zt_kanbanlane.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of compatible types (mediumint/mediumint unsigned) and business logic suggests that both track data within the same execution context (e.g., a sprint, iteration, or Kanban board). This is a common pattern in project management systems where progress (zt_burn) and workflow structure (zt_kanbanlane) are both scoped to the same execution. However, there is no explicit foreign key or further linking field, so the relationship is inferred based on naming and business context.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN zt_kanbanlane t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "execution",
            "to_table": "zt_doclib",
            "to_column": "execution",
            "condition": "zt_burn.execution = zt_doclib.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same data type (mediumint unsigned), and both use it to associate records with a specific execution (such as a sprint, iteration, or project phase). In zt_burn, 'execution' identifies the context for burn tracking, while in zt_doclib, it associates a document library with an execution. This suggests a logical relationship where document libraries may be linked to the same execution as burn records, supporting business operations such as accessing documentation relevant to a specific execution.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN zt_doclib t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "product",
            "to_table": "zt_doclib",
            "to_column": "product",
            "condition": "zt_burn.product = zt_doclib.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same data type (mediumint unsigned), and both use it to associate records with a specific product. In zt_burn, 'product' identifies the product for which burn tracking is performed, while in zt_doclib, it associates a document library with a product. This suggests a logical relationship where document libraries may be linked to the same product as burn records, supporting business operations such as accessing documentation relevant to a specific product.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN zt_doclib t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "date",
            "to_table": "zt_effort",
            "to_column": "date",
            "condition": "zt_burn.date = zt_effort.date",
            "confidence": "high",
            "reasoning": "Both tables have a 'date' field of type date, representing the day of the effort or progress record. This allows for temporal alignment of burn and effort data for reporting or analysis, though it is not a foreign key relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN zt_effort t2 ON t1.date = t2.date LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "execution",
            "to_table": "zt_metriclib",
            "to_column": "execution",
            "condition": "CAST(zt_burn.execution AS CHAR) = zt_metriclib.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field, which likely refers to the same business concept (e.g., a sprint or project phase). However, the data types differ: zt_burn.execution is a numeric type (mediumint unsigned), while zt_metriclib.execution is a char(30). This suggests a possible relationship, but the type mismatch reduces confidence. The relationship is inferred based on naming and business logic.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN zt_metriclib t2 ON CAST(t1.execution AS CHAR) = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 102,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "date",
            "to_table": "zt_metriclib",
            "to_column": "date",
            "condition": "zt_burn.date = DATE(zt_metriclib.date)",
            "confidence": "high",
            "reasoning": "zt_burn.date is a DATE, while zt_metriclib.date is a DATETIME. Matching on the date portion allows for time-based analysis or aggregation. This is a common pattern in reporting and analytics.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN zt_metriclib t2 ON t1.date = DATE(t2.date) LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 96,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "execution",
            "to_table": "zt_team",
            "to_column": "root",
            "condition": "zt_burn.execution = zt_team.root AND zt_team.type = 'execution'",
            "confidence": "high",
            "reasoning": "Both tables use a numeric field (zt_burn.execution and zt_team.root) that likely refers to an 'execution' entity. zt_team.type distinguishes the context of 'root', and when type = 'execution', root probably matches the execution ID in zt_burn. This is a common pattern for associating team members with a specific execution, and burn records with that execution.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN zt_team t2 ON t1.execution = t2.root AND t2.type = 'execution' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "execution",
            "to_table": "zt_task",
            "to_column": "execution",
            "condition": "zt_burn.execution = zt_task.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same type, and both are related to project phases or sprints. While this does not uniquely identify a task, it is likely that burn records and tasks are grouped by execution for reporting and filtering.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN zt_task t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 24,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "execution",
            "to_table": "zt_testtask",
            "to_column": "execution",
            "condition": "zt_burn.execution = zt_testtask.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same data type (mediumint unsigned), and both use it to represent an execution context (such as a sprint, iteration, or test cycle). While 'zt_burn' tracks effort for tasks within an execution, 'zt_testtask' associates test tasks with an execution. This suggests a logical relationship where burn data could be filtered or grouped by the same execution as test tasks.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN zt_testtask t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "date",
            "to_table": "ztv_dayactions",
            "to_column": "day",
            "condition": "zt_burn.date = ztv_dayactions.day",
            "confidence": "high",
            "reasoning": "Both tables contain a date field ('date' in zt_burn and 'day' in ztv_dayactions') with compatible data types. While 'zt_burn' tracks task progress per day and 'ztv_dayactions' aggregates actions per day, a join on the date fields could allow for correlating daily task progress with overall daily action volume. However, there is no explicit business logic or foreign key relationship, so this is an inferred, logical/statistical relationship based on time alignment.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN ztv_dayactions t2 ON t1.date = t2.day LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "date",
            "to_table": "ztv_dayeffort",
            "to_column": "date",
            "condition": "zt_burn.date = ztv_dayeffort.date",
            "confidence": "high",
            "reasoning": "Both tables contain a 'date' field of the same data type (date), and both are used to track effort or progress on a daily basis. While zt_burn tracks effort per task per execution per day, ztv_dayeffort aggregates or logs effort per day. Joining on 'date' could allow for analysis of total effort logged versus effort tracked per task on the same day. However, there is no explicit foreign key or unique constraint linking the two, so the relationship is inferred based on business logic and naming conventions.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN ztv_dayeffort t2 ON t1.date = t2.date LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "date",
            "to_table": "ztv_daybugopen",
            "to_column": "day",
            "condition": "zt_burn.date = ztv_daybugopen.day",
            "confidence": "high",
            "reasoning": "Both tables track daily metrics: zt_burn records task progress per day, and ztv_daybugopen records the number of bugs opened per day. The only commonality is the date field (zt_burn.date and ztv_daybugopen.day), which could be used to correlate team progress with bug influx for reporting or analysis purposes. There are no explicit foreign keys or business entity links, so this is a logical/statistical relationship based on time.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN ztv_daybugopen t2 ON t1.date = t2.day LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "date",
            "to_table": "ztv_daytaskfinish",
            "to_column": "day",
            "condition": "zt_burn.date = ztv_daytaskfinish.day",
            "confidence": "high",
            "reasoning": "Both tables track daily data: zt_burn records task progress per day, while ztv_daytaskfinish records the number of tasks finished per day. The only commonality is the date fields (zt_burn.date and ztv_daytaskfinish.day), which are of the same data type and represent the same business concept (a calendar day). There is no direct foreign key or unique identifier linking the two, but joining on date could allow for correlating daily task progress with the number of tasks finished, supporting reporting or analysis use cases.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN ztv_daytaskfinish t2 ON t1.date = t2.day LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "date",
            "to_table": "ztv_daytaskopen",
            "to_column": "day",
            "condition": "zt_burn.date = ztv_daytaskopen.day",
            "confidence": "high",
            "reasoning": "Both tables contain a date field ('date' in zt_burn and 'day' in ztv_daytaskopen) with compatible data types. The business purposes are related to daily tracking: zt_burn tracks task progress per day, while ztv_daytaskopen tracks the number of open tasks per day. This suggests a possible business logic relationship for reporting or analytics, such as correlating daily burn data with the number of open tasks.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN ztv_daytaskopen t2 ON t1.date = t2.day LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "product",
            "to_table": "zt_doclib",
            "to_column": "product",
            "condition": "zt_case.product = zt_doclib.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same type (mediumint unsigned), and both are used to associate records with a specific product. While there is no explicit foreign key, it is common in business logic for test cases and document libraries to be grouped or filtered by product. However, this is not a strict one-to-one or one-to-many relationship, as multiple test cases and document libraries can share the same product.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_doclib t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "project",
            "to_table": "zt_doclib",
            "to_column": "project",
            "condition": "zt_case.project = zt_doclib.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field (mediumint unsigned), likely referencing the same project entity. Test cases and document libraries are often organized or filtered by project in software development and QA processes. This relationship is logical for grouping or reporting, but not a strict foreign key.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_doclib t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "execution",
            "to_table": "zt_doclib",
            "to_column": "execution",
            "condition": "zt_case.execution = zt_doclib.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field (mediumint unsigned), which likely refers to a specific execution or iteration of a project. Test cases and document libraries may be associated with the same execution context, supporting reporting or filtering by execution.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_doclib t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 12,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "branch",
            "to_table": "zt_productplan",
            "to_column": "branch",
            "condition": "CAST(zt_case.branch AS CHAR) = zt_productplan.branch",
            "confidence": "high",
            "reasoning": "Both tables have a 'branch' field, which likely refers to a product branch or version. However, in zt_case it is stored as a mediumint unsigned, while in zt_productplan it is a varchar(255). This suggests a possible relationship, but the data types differ, so a cast or conversion would be required. The business logic supports the idea that test cases may be associated with specific product branches, and product plans may also be branch-specific.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_productplan t2 ON CAST(t1.branch AS CHAR) = t2.branch LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "product",
            "to_table": "zt_metriclib",
            "to_column": "product",
            "condition": "CAST(zt_case.product AS CHAR) = zt_metriclib.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field, which likely refers to the same business entity (a product). As with 'project', the data types differ (numeric vs. char), but the naming and business context suggest a logical relationship. This is a business logic relationship, assuming product IDs or codes are consistent.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_metriclib t2 ON CAST(t1.product AS CHAR) = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 128,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "product",
            "to_table": "zt_projectcase",
            "to_column": "product",
            "condition": "zt_case.product = zt_projectcase.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same type and name, indicating that test cases and their project associations may be product-specific. This relationship is likely used for filtering or reporting, but may not always be a strict foreign key relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_projectcase t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 32,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "story, version",
            "to_table": "zt_projectstory",
            "to_column": "story, version",
            "condition": "zt_case.story = zt_projectstory.story AND zt_case.storyVersion = zt_projectstory.version",
            "confidence": "high",
            "reasoning": "Both tables track story and version, though zt_case uses 'storyVersion' and zt_projectstory uses 'version'. This join would allow matching test cases to the specific version of a story as included in a project.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_projectstory t2 ON t1.story = t2.story AND t1.storyVersion = t2.version LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "product",
            "to_table": "zt_system",
            "to_column": "product",
            "condition": "zt_case.product = zt_system.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same data type (mediumint unsigned), and both use it to associate their records with a product entity. While the tables do not directly reference each other, it is common in business logic for test cases (zt_case) and systems (zt_system) to be grouped or filtered by the same product context. This allows for analysis or reporting of test cases and systems under the same product umbrella.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_system t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "version",
            "to_table": "zt_testrun",
            "to_column": "version",
            "condition": "zt_case.version = zt_testrun.version",
            "confidence": "high",
            "reasoning": "Both tables have a 'version' field of the same type. In test management, it is common to track which version of a test case was executed in a test run. However, this relationship only makes sense in conjunction with the test case ID, as version numbers are not globally unique. Thus, this is a composite relationship (zt_case.id = zt_testrun.case AND zt_case.version = zt_testrun.version).",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_testrun t2 ON t1.id = t2.case AND t1.version = t2.version LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "version",
            "to_table": "zt_testresult",
            "to_column": "version",
            "condition": "zt_case.version = zt_testresult.version",
            "confidence": "high",
            "reasoning": "Both tables have a 'version' field, and in the context of test management, test results are often tied to a specific version of a test case. However, the data types are not exactly the same (tinyint unsigned vs smallint unsigned), and there is no explicit foreign key, so confidence is medium. This relationship is only meaningful when combined with the test case ID.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN zt_testresult t2 ON t1.id = t2.case AND t1.version = t2.version LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "story",
            "to_table": "ztv_projectstories",
            "to_column": "stories",
            "condition": "zt_case.story = ztv_projectstories.stories",
            "confidence": "high",
            "reasoning": "The 'story' field in zt_case and the 'stories' field in ztv_projectstories both likely refer to user stories or requirements. Although the data types differ (mediumint unsigned vs. bigint), the naming and business context suggest a possible relationship. This could allow for analysis of which test cases are associated with which stories tracked in executions. However, the difference in data type and the possibility that 'stories' in ztv_projectstories could represent a set or count rather than a single story ID lowers the confidence.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN ztv_projectstories t2 ON t1.story = t2.stories LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_casestep",
            "from_column": "case, version",
            "to_table": "zt_projectcase",
            "to_column": "case, version",
            "condition": "zt_casestep.case = zt_projectcase.case AND zt_casestep.version = zt_projectcase.version",
            "confidence": "high",
            "reasoning": "Both tables have 'case' and 'version' fields. zt_casestep uses 'version' to track different versions of steps for a case, and zt_projectcase tracks which version of a case is assigned to a project. Joining on both fields ensures that the correct version of steps is associated with the version of the case used in the project.",
            "test_sql": "SELECT COUNT(*) FROM zt_casestep t1 JOIN zt_projectcase t2 ON t1.case = t2.case AND t1.version = t2.version LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 12,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "view_datasource_11",
            "to_column": "id",
            "condition": "tmp_case_getDevStories.story = view_datasource_11.id",
            "confidence": "high",
            "reasoning": "The only possible relationship based on schema is that 'story' (a mediumint unsigned) in tmp_case_getDevStories could reference 'id' (also a mediumint unsigned) in view_datasource_11. However, there is no explicit naming or business logic linking 'story' to 'id', and the business purposes of the tables do not clearly overlap. This is a speculative relationship based solely on compatible data types and common database patterns.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN view_datasource_11 t2 ON t1.story = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "view_datasource_10",
            "to_column": "id",
            "condition": "tmp_case_getDevStories.story = view_datasource_10.id",
            "confidence": "high",
            "reasoning": "Both 'story' and 'id' are of type 'mediumint unsigned', and 'story' appears to be an identifier that could reference another entity. However, there is no explicit naming or business logic linking 'story' to 'id', and the business purposes of the tables do not clearly overlap. The relationship is inferred solely based on data type compatibility and the possibility that 'story' could reference a named entity, but this is speculative.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN view_datasource_10 t2 ON t1.story = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "view_datasource_5",
            "to_column": "id",
            "condition": "tmp_case_getDevStories.story = view_datasource_5.id",
            "confidence": "high",
            "reasoning": "The only possible field match is between 'story' (mediumint unsigned) and 'id' (mediumint unsigned). Both are numeric and could theoretically represent related entities, but there is no naming similarity or explicit business logic connecting a 'story' to a 'datasource_5' entry. The relationship is inferred solely on data type compatibility and common database patterns, but there is no strong evidence to support this as a meaningful or intentional relationship.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN view_datasource_5 t2 ON t1.story = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "zt_metriclib",
            "to_column": "metricID",
            "condition": "tmp_case_getDevStories.story = zt_metriclib.metricID",
            "confidence": "high",
            "reasoning": "Both 'story' (mediumint unsigned) and 'metricID' (mediumint) share a compatible data type and could, by naming convention, represent identifiers for entities (e.g., a 'story' as a business object and a 'metricID' as a metric definition). However, there is no clear semantic or business logic connection between a 'story' and a 'metricID' based solely on the provided schemas and business purposes. The relationship is speculative and not strongly supported by the available information.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN zt_metriclib t2 ON t1.story = t2.metricID LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_case_getDevStories",
            "from_column": "story",
            "to_table": "ztv_normalproduct",
            "to_column": "id",
            "condition": "tmp_case_getDevStories.story = ztv_normalproduct.id",
            "confidence": "high",
            "reasoning": "The 'story' field in tmp_case_getDevStories and the 'id' field in ztv_normalproduct share the same data type (mediumint unsigned), but their naming and business purposes do not directly align. 'story' likely refers to a user story or work item, while 'id' in ztv_normalproduct refers to a product entity. There is no clear business logic or naming convention linking these fields, but the data type compatibility allows for a possible, though unlikely, relationship.",
            "test_sql": "SELECT COUNT(*) FROM tmp_case_getDevStories t1 JOIN ztv_normalproduct t2 ON t1.story = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "view_datasource_5",
            "to_column": "id",
            "condition": "tmp_task_getProjectTasks.project = view_datasource_5.id",
            "confidence": "high",
            "reasoning": "The only possible join is between 'project' (tmp_task_getProjectTasks) and 'id' (view_datasource_5) because both are of type 'mediumint unsigned'. However, there is no clear naming or business logic connection between 'project' and 'id', and the business purposes of the tables do not obviously overlap. This join is suggested solely on data type compatibility and the common pattern of using integer IDs as references, but there is no strong evidence to support a meaningful relationship.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN view_datasource_5 t2 ON t1.project = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "view_datasource_6",
            "to_column": "id",
            "condition": "tmp_task_getProjectTasks.project = view_datasource_6.id",
            "confidence": "high",
            "reasoning": "The only possible join is between 'project' (tmp_task_getProjectTasks) and 'id' (view_datasource_6) as both are numeric fields and could theoretically represent a reference. However, there is no explicit naming or business logic connection between 'project' and 'id', and the business purposes of the tables do not clearly align. This is a speculative relationship based solely on data type compatibility and common database patterns.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN view_datasource_6 t2 ON t1.project = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_pivot",
            "to_column": "dimension",
            "condition": "tmp_task_getProjectTasks.project = zt_pivot.dimension",
            "confidence": "high",
            "reasoning": "Both fields ('project' and 'dimension') share the same data type (mediumint unsigned) and could, in theory, represent related entities (e.g., a project as a reporting dimension). However, there is no explicit naming or business logic connection between a 'project' and a 'dimension' in the provided schemas. The relationship is speculative and based solely on data type compatibility and the possibility that a pivot might be defined for a specific project dimension.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_pivot t2 ON t1.project = t2.dimension LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_projectadmin",
            "to_column": "projects",
            "condition": "CAST(tmp_task_getProjectTasks.project AS CHAR) = ANY (SPLIT(zt_projectadmin.projects, ','))",
            "confidence": "high",
            "reasoning": "The 'project' field in tmp_task_getProjectTasks and the 'projects' field in zt_projectadmin both refer to projects, but 'project' is a numeric ID and 'projects' is a text field likely containing a comma-separated list of project IDs. There is no direct foreign key or enforced relationship, but by business logic, it is possible that 'zt_projectadmin.projects' contains the IDs of projects over which an account has admin rights. However, the lack of structure and data type mismatch (integer vs. text list) makes this relationship speculative and implementation-dependent.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_projectadmin t2 ON FIND_IN_SET(CAST(t1.project AS CHAR), t2.projects) > 0 LIMIT 1;",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "project",
            "to_table": "zt_searchindex",
            "to_column": "objectID",
            "condition": "tmp_task_getProjectTasks.project = zt_searchindex.objectID",
            "confidence": "high",
            "reasoning": "Both fields are integer types and could theoretically reference the same entity (e.g., a project), but there is no explicit indication in the schemas or naming conventions that 'objectID' in zt_searchindex refers to a project. Furthermore, zt_searchindex uses a polymorphic pattern with 'objectType', so objectID could refer to many different types of objects, not just projects. Without further context or a matching 'objectType', this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN zt_searchindex t2 ON t1.project = t2.objectID LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "consumed",
            "to_table": "ztv_dayeffort",
            "to_column": "consumed",
            "condition": "tmp_task_getProjectTasks.consumed = ztv_dayeffort.consumed",
            "confidence": "high",
            "reasoning": "Both tables have a 'consumed' field of type double, but in the absence of a project or date field in common, and given that 'consumed' likely represents a numeric value (e.g., hours) rather than a unique identifier, joining on this field is not meaningful for business logic or referential integrity. There is no clear business or logical relationship between these fields, but technically a join is possible.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN ztv_dayeffort t2 ON t1.consumed = t2.consumed LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tmp_task_getProjectTasks",
            "from_column": "consumed",
            "to_table": "ztv_executionsummary",
            "to_column": "consumed",
            "condition": "tmp_task_getProjectTasks.consumed = ztv_executionsummary.consumed",
            "confidence": "high",
            "reasoning": "Both tables have a 'consumed' field of type double, which likely represents the amount of effort or resources used. However, there is no clear indication that these values are directly related or that they refer to the same business entity. The 'consumed' value in tmp_task_getProjectTasks is associated with a 'project', while in ztv_executionsummary it is associated with an 'execution'. Without further context, any join on this field would be coincidental or statistical rather than based on a logical or foreign key relationship.",
            "test_sql": "SELECT COUNT(*) FROM tmp_task_getProjectTasks t1 JOIN ztv_executionsummary t2 ON t1.consumed = t2.consumed LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_10",
            "from_column": "id",
            "to_table": "view_datasource_12",
            "to_column": "id",
            "condition": "view_datasource_10.id = view_datasource_12.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of the same data type and similar structure, but there is no explicit foreign key or naming convention indicating a direct relationship. The business purposes described suggest both are independent lookup/reference tables, and there is no evidence that the 'id' values are meant to correspond. This join is only suggested based on matching field names and types, not on business logic or design patterns.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_10 t1 JOIN view_datasource_12 t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_10",
            "from_column": "id",
            "to_table": "view_datasource_11",
            "to_column": "id",
            "condition": "view_datasource_10.id = view_datasource_11.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of the same data type and similar business purpose (lookup/reference), but there is no explicit foreign key or naming convention indicating a direct relationship. The matching 'id' fields could, in rare cases, represent the same entity across both tables, but this is speculative without further context.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_10 t1 JOIN view_datasource_11 t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_10",
            "from_column": "id",
            "to_table": "view_datasource_41",
            "to_column": "id",
            "condition": "view_datasource_10.id = view_datasource_41.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of the same data type and constraints, but there is no explicit foreign key or naming convention indicating a relationship. The 'id' fields are likely independent primary keys for each table, and the business purposes suggest they are separate lookup/reference tables. However, a statistical or accidental overlap could exist if the same IDs are used to represent related entities, but this is not supported by the schema or business logic provided.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_10 t1 JOIN view_datasource_41 t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_10",
            "from_column": "id",
            "to_table": "view_datasource_6",
            "to_column": "id",
            "condition": "view_datasource_10.id = view_datasource_6.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of similar type (mediumint/mediumint unsigned), but there is no explicit foreign key, naming convention, or business logic indicating that these ids are related. The ids may be independently generated and serve as primary keys for their respective tables. The only basis for a join is the matching column name and compatible data type, which is a weak indicator.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_10 t1 JOIN view_datasource_6 t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_10",
            "from_column": "id",
            "to_table": "view_datasource_5",
            "to_column": "id",
            "condition": "view_datasource_10.id = view_datasource_5.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field of the same data type and similar business purpose (reference/lookup), but there is no explicit foreign key or naming convention indicating a direct relationship. In typical database design, lookup tables have unique 'id' values within their own context, and sharing 'id' values across unrelated lookup tables is uncommon. However, a join on 'id' is technically possible and could be tested for overlap, though it is likely coincidental rather than intentional.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_10 t1 JOIN view_datasource_5 t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_10",
            "from_column": "id",
            "to_table": "zt_action",
            "to_column": "objectID",
            "condition": "view_datasource_10.id = zt_action.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of type mediumint unsigned, which makes them technically compatible. However, there is no clear semantic or naming connection between 'view_datasource_10' and the 'objectID' in 'zt_action'. 'objectID' is a generic reference to an object, but without knowing that 'view_datasource_10' represents an object type referenced by 'zt_action', this relationship is speculative. No explicit foreign key or naming convention links these fields.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_10 t1 JOIN zt_action t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 29,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_10",
            "from_column": "id",
            "to_table": "zt_build",
            "to_column": "system",
            "condition": "view_datasource_10.id = zt_build.system",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and could theoretically be related if 'system' in zt_build refers to a named entity in view_datasource_10. However, there is no explicit naming or business logic evidence to strongly support this relationship. The only basis is data type compatibility and the possibility that 'system' is a reference to a lookup table.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_10 t1 JOIN zt_build t2 ON t1.id = t2.system LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_10",
            "from_column": "id",
            "to_table": "zt_testtask",
            "to_column": "id",
            "condition": "view_datasource_10.id = zt_testtask.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of the same data type, but in both schemas, 'id' serves as a primary key and unique identifier for their respective entities. There is no business logic or naming convention suggesting that these IDs are related or reference each other. This is a statistical or coincidental match, not a logical or business-driven relationship.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_10 t1 JOIN zt_testtask t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "view_datasource_5",
            "to_column": "id",
            "condition": "view_datasource_11.id = view_datasource_5.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of the same data type and similar business purpose (reference/lookup entities). However, there is no explicit foreign key, and the table names and business purposes do not indicate a direct relationship. The matching 'id' fields could be coincidental, and without further context, this is only a speculative relationship.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN view_datasource_5 t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "zt_actionrecent",
            "to_column": "objectID",
            "condition": "view_datasource_11.id = zt_actionrecent.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of compatible numeric types (mediumint unsigned), and 'objectID' in zt_actionrecent is designed to reference the primary key of some object table. However, there is no explicit indication that 'objectID' refers to 'view_datasource_11.id', nor is there a matching 'objectType' value or naming convention to suggest a direct relationship. This is a generic polymorphic pattern, but without further context, the relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_actionrecent t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "zt_acl",
            "to_column": "objectID",
            "condition": "view_datasource_11.id = zt_acl.objectID",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field of compatible integer types (mediumint unsigned vs mediumint), and 'objectID' in zt_acl is likely intended to reference the primary key of some object table. However, there is no explicit indication that 'objectType' in zt_acl ever refers to 'view_datasource_11', nor is there a field in zt_acl that directly references 'view_datasource_11' by name or type. The relationship is possible only if, by business logic, some ACL entries are meant to control access to entities in 'view_datasource_11', but this cannot be confirmed from the schemas alone.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_acl t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "zt_build",
            "to_column": "system",
            "condition": "view_datasource_11.id = zt_build.system",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and could potentially represent a lookup relationship where 'system' in zt_build refers to a named entity in view_datasource_11. However, there is no explicit naming or business logic evidence to strongly support this, and the table/view name 'view_datasource_11' is generic. This is a speculative relationship based solely on data type compatibility and common database patterns.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_build t2 ON t1.id = t2.system LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "zt_searchindex",
            "to_column": "objectID",
            "condition": "view_datasource_11.id = zt_searchindex.objectID",
            "confidence": "high",
            "reasoning": "Both fields are integer types and could theoretically be used to link records, but there is no explicit or implied business logic, naming convention, or domain knowledge connecting 'view_datasource_11' to the 'objectID' in 'zt_searchindex'. The 'objectType' field in 'zt_searchindex' is intended to distinguish which table 'objectID' refers to, but since there is no evidence that 'view_datasource_11' is one of those types, this relationship is speculative and weak.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_searchindex t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 32,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "zt_project",
            "to_column": "id",
            "condition": "view_datasource_11.id = zt_project.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field of the same data type (mediumint unsigned), but in both schemas, 'id' is the primary key and unique identifier for each table. There is no evidence that these IDs are related or that one references the other. Typically, primary keys in different tables are not directly related unless explicitly designed as such, which is not indicated here.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_project t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "name",
            "to_table": "zt_project",
            "to_column": "name",
            "condition": "view_datasource_11.name = zt_project.name",
            "confidence": "high",
            "reasoning": "Both tables have a 'name' field, but the data types differ (char(60) vs varchar(90)), and there is no indication that these names are standardized or reference the same domain. The 'name' in view_datasource_11 is likely a lookup value, while in zt_project it is the project name. Without further business context, this is a weak, statistical relationship at best.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_project t2 ON t1.name = t2.name LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "name",
            "to_table": "zt_workflowdatasource",
            "to_column": "name",
            "condition": "view_datasource_11.name = zt_workflowdatasource.name",
            "confidence": "high",
            "reasoning": "Both tables have a 'name' field, and both fields are of string type. However, there is no explicit indication that these names are meant to reference each other. The 'name' in view_datasource_11 is a char(60), while in zt_workflowdatasource it is varchar(30), suggesting possible overlap but not guaranteed. The business purposes are different: one is a generic lookup, the other is a workflow data source definition. This join could be used for reporting or mapping purposes if the names are standardized, but there is no strong evidence of a direct relationship.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN zt_workflowdatasource t2 ON t1.name = t2.name LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 45,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "ztv_projectbugs",
            "to_column": "execution",
            "condition": "view_datasource_11.id = ztv_projectbugs.execution",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_11) and 'execution' (ztv_projectbugs) are of type 'mediumint unsigned' and are non-nullable, which makes them technically compatible for a join. However, there is no clear naming or business logic connection between a generic 'id' in a lookup/reference table and an 'execution' identifier in a bug tracking summary table. No explicit foreign key or semantic link is evident from the schemas or business purposes provided. This join is suggested only on the basis of data type compatibility and common database patterns, but the actual business relationship is unclear.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN ztv_projectbugs t2 ON t1.id = t2.execution LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_11",
            "from_column": "id",
            "to_table": "ztv_projectteams",
            "to_column": "execution",
            "condition": "view_datasource_11.id = ztv_projectteams.execution",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and non-null, which makes them technically compatible. However, there is no clear naming or business logic connection between 'id' (a generic identifier for named entities) and 'execution' (which likely refers to a project or task). Without further context, this relationship is speculative and based solely on data type compatibility.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_11 t1 JOIN ztv_projectteams t2 ON t1.id = t2.execution LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "view_datasource_5",
            "to_column": "id",
            "condition": "view_datasource_12.id = view_datasource_5.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of the same data type and similar structure, but there is no evidence from naming conventions, business purpose, or schema that these IDs are meant to reference each other. Typically, IDs in separate lookup/reference tables are independent. However, a join could be attempted to check for coincidental overlap or shared meaning.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN view_datasource_5 t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "view_datasource_4",
            "to_column": "id",
            "condition": "view_datasource_12.id = view_datasource_4.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of the same data type and similar business purpose (catalog/lookup), but there is no explicit foreign key or naming convention indicating a direct relationship. The 'id' fields may be independently generated and not intended to reference each other. However, if both tables represent catalogs of similar entities, there is a remote possibility that the same 'id' could refer to the same logical entity in both tables.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN view_datasource_4 t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "view_datasource_41",
            "to_column": "id",
            "condition": "view_datasource_12.id = view_datasource_41.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of the same data type and similar business purpose (catalog/listing), but there is no explicit foreign key or naming convention indicating a direct relationship. The 'id' fields may be independently generated and not related. However, if the business logic dictates that these catalogs are synchronized or represent the same entities in different contexts, a join on 'id' could be possible. Without further context, this is speculative.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN view_datasource_41 t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "view_datasource_6",
            "to_column": "id",
            "condition": "view_datasource_12.id = view_datasource_6.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field of similar type and purpose (catalog/listing identifier), but there is no explicit foreign key or business logic indicating that these IDs are related or reference the same domain. The tables may represent entirely separate catalogs. The only basis for a join is the matching field name and type, which is a weak indicator.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN view_datasource_6 t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "zt_acl",
            "to_column": "objectID",
            "condition": "view_datasource_12.id = zt_acl.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of compatible integer types and could theoretically be linked if 'view_datasource_12' represents objects that are subject to access control. However, there is no explicit indication that 'objectType' in zt_acl would match 'view_datasource_12', nor is there a direct naming or business logic connection. The relationship is possible only if, in practice, some ACL entries use 'objectType' to refer to the type of entity stored in 'view_datasource_12'. Without further context, this is a speculative, low-confidence relationship.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN zt_acl t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "zt_action",
            "to_column": "objectID",
            "condition": "view_datasource_12.id = zt_action.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of compatible numeric types (mediumint unsigned), and 'objectID' in zt_action is intended to reference an object in another table. However, there is no explicit indication that 'objectType' in zt_action would ever refer to 'view_datasource_12', nor is there a field in view_datasource_12 that matches 'objectType'. Without a matching 'objectType' or further context, this relationship is speculative and weak.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN zt_action t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 29,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "zt_actionrecent",
            "to_column": "objectID",
            "condition": "view_datasource_12.id = zt_actionrecent.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of compatible numeric types (mediumint unsigned), and 'objectID' in zt_actionrecent is designed to reference the primary key of some business object. However, there is no explicit indication that 'objectID' refers to 'view_datasource_12.id', nor is there a matching 'objectType' value or naming convention to suggest a direct relationship. Without further context, this is a possible but weakly supported relationship.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN zt_actionrecent t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "zt_bug",
            "to_column": "id",
            "condition": "view_datasource_12.id = zt_bug.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field of similar data type (mediumint), but in both cases, 'id' is used as a primary key for their respective tables and represents different business entities (a catalog entry vs. a bug record). There is no business logic or naming convention suggesting these IDs are related. This join is technically possible but almost certainly meaningless.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN zt_bug t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "zt_searchindex",
            "to_column": "objectID",
            "condition": "view_datasource_12.id = zt_searchindex.objectID",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field (view_datasource_12.id and zt_searchindex.objectID) of compatible numeric types (mediumint unsigned vs mediumint). However, there is no explicit foreign key, and the business purposes are different: one is a catalog, the other is a polymorphic search index. There is no direct evidence that zt_searchindex.objectID references view_datasource_12.id, and the objectType field in zt_searchindex suggests it could reference many different tables. Without further information, this relationship is speculative and weak.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN zt_searchindex t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "zt_workflowdatasource",
            "to_column": "id",
            "condition": "view_datasource_12.id = zt_workflowdatasource.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of the same data type (mediumint unsigned), but in both schemas, 'id' is used as a primary key for their respective tables and serves different business purposes. There is no evidence that these IDs are related or that one references the other. This is a common field name but not a meaningful relationship in this context.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN zt_workflowdatasource t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_12",
            "from_column": "id",
            "to_table": "zt_story",
            "to_column": "id",
            "condition": "view_datasource_12.id = zt_story.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field of the same data type (mediumint unsigned), but in both schemas, 'id' is used as a primary key for their respective entities. There is no business logic or naming convention suggesting that the 'id' in view_datasource_12 refers to a story in zt_story. This is likely a coincidence due to common use of 'id' as a primary key.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_12 t1 JOIN zt_story t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "id",
            "to_table": "zt_acl",
            "to_column": "objectID",
            "condition": "view_datasource_4.id = zt_acl.objectID",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field (view_datasource_4.id and zt_acl.objectID) of compatible numeric types. In some business contexts, ACL tables reference objects in other tables by their IDs. However, there is no explicit indication that zt_acl.objectType would match 'view_datasource_4', nor is there a direct naming or schema link. The relationship is possible if zt_acl.objectType is used to distinguish which table objectID refers to, but this cannot be confirmed from the provided schemas alone.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN zt_acl t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "id",
            "to_table": "view_datasource_41",
            "to_column": "id",
            "condition": "view_datasource_4.id = view_datasource_41.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of the same type and name, but there is no explicit foreign key or business logic indicating a relationship. The identical schema suggests they may be parallel catalogs or versions, but without further context, any join on 'id' is speculative and likely coincidental.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN view_datasource_41 t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "id",
            "to_table": "view_datasource_6",
            "to_column": "id",
            "condition": "view_datasource_4.id = view_datasource_6.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of similar type and purpose (unique identifier for catalog entries), but there is no explicit foreign key or business logic indicating that these ids are related. The tables may represent independent catalogs. A join on 'id' is only statistically plausible if both tables share a common id space, which is not evident from the schema or business purpose.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN view_datasource_6 t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "id",
            "to_table": "zt_action",
            "to_column": "objectID",
            "condition": "view_datasource_4.id = zt_action.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of compatible numeric types (mediumint unsigned), but there is no direct naming or business logic connection. The 'objectID' in zt_action is a generic reference to an object, and without a matching 'objectType' or further context, it is not clear that it refers to entries in view_datasource_4. This is a possible, but weak, statistical or logical relationship based solely on data type compatibility.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN zt_action t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 95,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "id",
            "to_table": "zt_actionrecent",
            "to_column": "objectID",
            "condition": "view_datasource_4.id = zt_actionrecent.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of compatible numeric types (mediumint unsigned), and 'objectID' in zt_actionrecent is designed to reference the primary key of some business object. However, there is no explicit indication that 'objectType' in zt_actionrecent ever refers to 'view_datasource_4', nor is there a field in zt_actionrecent that directly references 'view_datasource_4'. Without further context or a matching 'objectType', this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN zt_actionrecent t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "id",
            "to_table": "zt_projectcase",
            "to_column": "project",
            "condition": "view_datasource_4.id = zt_projectcase.project",
            "confidence": "high",
            "reasoning": "Both fields are of type mediumint unsigned and could theoretically be related if 'view_datasource_4' represents a catalog of projects. However, there is no explicit naming or business logic evidence to confirm this. The relationship is inferred solely based on data type compatibility and the common use of 'id' as a primary key and 'project' as a foreign key in typical database designs.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN zt_projectcase t2 ON t1.id = t2.project LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "id",
            "to_table": "zt_searchindex",
            "to_column": "objectID",
            "condition": "view_datasource_4.id = zt_searchindex.objectID",
            "confidence": "high",
            "reasoning": "Both fields are numeric and could theoretically be used to link records, but there is no explicit indication that zt_searchindex.objectID refers to view_datasource_4.id. The objectType field in zt_searchindex is likely intended to distinguish which table objectID refers to, but since we do not know if any objectType value corresponds to view_datasource_4, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN zt_searchindex t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 31,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "id",
            "to_table": "zt_story",
            "to_column": "id",
            "condition": "view_datasource_4.id = zt_story.id",
            "confidence": "high",
            "reasoning": "Although both tables have an 'id' column of the same data type, these are both primary keys for their respective tables and are likely to be independently generated. There is no business logic or naming convention suggesting that a datasource entry would directly correspond to a story entry by id. This is likely a coincidence of naming, not a true relationship.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN zt_story t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "title",
            "to_table": "zt_story",
            "to_column": "title",
            "condition": "view_datasource_4.title = zt_story.title",
            "confidence": "high",
            "reasoning": "Both tables have a 'title' column of the same data type and length, but the business purposes are different: one is a catalog/lookup, the other is a detailed requirements/story table. There is no evidence that the titles are meant to be synchronized or that one references the other. Any matches would likely be coincidental or based on loose business logic, not a formal relationship.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN zt_story t2 ON t1.title = t2.title LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "id",
            "to_table": "ztv_projectbugs",
            "to_column": "execution",
            "condition": "view_datasource_4.id = ztv_projectbugs.execution",
            "confidence": "high",
            "reasoning": "The only possible relationship based on schema is that both 'id' (view_datasource_4) and 'execution' (ztv_projectbugs) are of compatible numeric types (mediumint unsigned). There is no explicit foreign key or naming convention linking them, but in some business contexts, a catalog table's id may be referenced as an execution id in a metrics table. However, there is no strong evidence from the provided schemas or business purposes that these fields are related, so confidence is low.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN ztv_projectbugs t2 ON t1.id = t2.execution LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_4",
            "from_column": "id",
            "to_table": "ztv_projectsummary",
            "to_column": "project",
            "condition": "view_datasource_4.id = ztv_projectsummary.project",
            "confidence": "high",
            "reasoning": "Both fields (id and project) are of the same numeric type (mediumint unsigned) and could theoretically represent a relationship where each project summary is associated with a catalog entry from view_datasource_4. However, there is no explicit naming or business logic connection between 'id' and 'project', and the business purposes of the tables do not clearly overlap. This is a speculative relationship based solely on data type compatibility and common database patterns.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_4 t1 JOIN ztv_projectsummary t2 ON t1.id = t2.project LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "view_datasource_5",
            "to_column": "id",
            "condition": "view_datasource_41.id = view_datasource_5.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of the same data type and constraints, but there is no evidence from naming conventions, business purpose, or schema that these IDs are meant to reference each other. The IDs likely serve as independent primary keys for separate lookup/reference tables. This join is only suggested due to structural similarity, not business logic.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN view_datasource_5 t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "zt_action",
            "to_column": "objectID",
            "condition": "view_datasource_41.id = zt_action.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of compatible numeric types (mediumint unsigned) and could potentially be related if zt_action.objectType refers to entities cataloged in view_datasource_41. However, there is no explicit evidence in the schemas or business purposes that these two tables are directly related. The relationship is speculative and based solely on matching data types and naming conventions.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN zt_action t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 80,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "zt_acl",
            "to_column": "objectID",
            "condition": "view_datasource_41.id = zt_acl.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of compatible integer types and could represent a reference from zt_acl to view_datasource_41 if, in the business logic, the ACL is meant to control access to entities listed in view_datasource_41. However, there is no explicit indication that objectType in zt_acl would match view_datasource_41, nor is there a naming convention or foreign key constraint to confirm this. The relationship is possible but speculative.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN zt_acl t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "zt_actionrecent",
            "to_column": "objectID",
            "condition": "view_datasource_41.id = zt_actionrecent.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of compatible numeric types (mediumint unsigned), and 'objectID' in zt_actionrecent is designed to reference the primary key of some business object. However, there is no explicit indication that 'objectType' in zt_actionrecent ever refers to 'view_datasource_41', nor is there a field in view_datasource_41 that would clarify this. Without further context, this is a speculative relationship based solely on data type and naming convention.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN zt_actionrecent t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "view_datasource_6",
            "to_column": "id",
            "condition": "view_datasource_41.id = view_datasource_6.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field of similar type and purpose, but there is no explicit foreign key or business logic indicating that these IDs are related. The tables appear to be independent catalogs or lookup tables, and the IDs may be generated independently. However, a join on 'id' is technically possible due to matching data types and naming, but it is likely coincidental rather than intentional.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN view_datasource_6 t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "zt_bug",
            "to_column": "id",
            "condition": "view_datasource_41.id = zt_bug.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of similar data type, but in both schemas, 'id' is used as a primary key for their respective entities (catalog entry vs. bug record). There is no business logic or naming convention suggesting that these IDs refer to the same entity or that one is a foreign key to the other. This is likely a coincidence due to common naming, and joining on these fields would not be meaningful in most business contexts.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN zt_bug t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "zt_projectcase",
            "to_column": "project",
            "condition": "view_datasource_41.id = zt_projectcase.project",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and could represent a relationship where 'view_datasource_41' lists projects and 'zt_projectcase.project' references them. However, there is no explicit naming or business logic evidence that 'view_datasource_41' is a project catalog, nor is there a clear semantic link between the two tables based on the provided schemas and business purposes.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN zt_projectcase t2 ON t1.id = t2.project LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "zt_searchindex",
            "to_column": "objectID",
            "condition": "view_datasource_41.id = zt_searchindex.objectID",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field (view_datasource_41.id and zt_searchindex.objectID) with compatible numeric types (mediumint unsigned vs mediumint). However, there is no explicit foreign key, and the business purposes are different: one is a catalog, the other is a polymorphic search index. The only possible link is if entries from view_datasource_41 are indexed in zt_searchindex with objectType set to a value representing 'view_datasource_41'. Without further evidence, this is a speculative relationship based on naming and data type compatibility.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN zt_searchindex t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 25,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "zt_team",
            "to_column": "root",
            "condition": "view_datasource_41.id = zt_team.root",
            "confidence": "high",
            "reasoning": "Both fields are of type 'mediumint unsigned' and could potentially represent a link between a cataloged entity (view_datasource_41) and a team assignment (zt_team). However, there is no explicit naming or business logic connecting 'id' in view_datasource_41 to 'root' in zt_team, and the business purposes described do not clearly overlap. This is a speculative relationship based solely on data type compatibility and common database patterns.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN zt_team t2 ON t1.id = t2.root LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "zt_zoutput",
            "to_column": "activity",
            "condition": "view_datasource_41.id = zt_zoutput.activity",
            "confidence": "high",
            "reasoning": "The only possible relationship based on field names and data types is between 'view_datasource_41.id' (mediumint unsigned) and 'zt_zoutput.activity' (mediumint). Both are numeric and could represent a reference, but there is no explicit foreign key or clear business logic connecting a 'catalog/list' entry to an 'activity' in outputs. The naming does not strongly suggest a relationship, and the business purposes are not obviously aligned. This is a speculative relationship based solely on compatible data types and the common pattern of referencing an 'id' from another table.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN zt_zoutput t2 ON t1.id = t2.activity LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "zt_workflowdatasource",
            "to_column": "id",
            "condition": "view_datasource_41.id = zt_workflowdatasource.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of the same data type (mediumint unsigned), but in both schemas, 'id' is used as a primary key for their respective tables and there is no explicit indication that these IDs are related or share a common sequence. The business purposes are also distinct: one is a catalog/list, the other is a workflow data source definition. This is a common field name but likely coincidental.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN zt_workflowdatasource t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "ztv_executionsummary",
            "to_column": "execution",
            "condition": "view_datasource_41.id = ztv_executionsummary.execution",
            "confidence": "high",
            "reasoning": "Both 'id' (view_datasource_41) and 'execution' (ztv_executionsummary) are of compatible numeric types (mediumint unsigned) and serve as unique identifiers in their respective tables. However, there is no explicit naming convention, foreign key, or business logic directly linking these fields. The relationship is inferred solely on the basis of data type compatibility and common database design patterns where a summary table references a master or catalog table by ID. Without further context, this is a speculative relationship.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN ztv_executionsummary t2 ON t1.id = t2.execution LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "ztv_projectbugs",
            "to_column": "execution",
            "condition": "view_datasource_41.id = ztv_projectbugs.execution",
            "confidence": "high",
            "reasoning": "Both fields ('id' in view_datasource_41 and 'execution' in ztv_projectbugs) share the same data type (mediumint unsigned) and could potentially represent a reference from bug statistics to a catalog of executions or entities. However, there is no explicit naming or business logic connection between 'id' and 'execution' based on the provided schemas and business purposes. The relationship is inferred solely on data type compatibility and the common pattern of referencing an entity by ID.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN ztv_projectbugs t2 ON t1.id = t2.execution LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_41",
            "from_column": "id",
            "to_table": "ztv_projectstories",
            "to_column": "execution",
            "condition": "view_datasource_41.id = ztv_projectstories.execution",
            "confidence": "high",
            "reasoning": "Both fields ('id' and 'execution') are of compatible numeric types (mediumint unsigned) and could theoretically represent a relationship where each 'execution' in ztv_projectstories references an entity in view_datasource_41. However, there is no explicit naming or business logic connection between 'id' and 'execution' based on the provided schemas and business purposes. The relationship is inferred solely on data type compatibility and the common pattern of referencing catalog tables, but the lack of clear semantic alignment makes this a low-confidence suggestion.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_41 t1 JOIN ztv_projectstories t2 ON t1.id = t2.execution LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_5",
            "from_column": "id",
            "to_table": "zt_actionrecent",
            "to_column": "objectID",
            "condition": "view_datasource_5.id = zt_actionrecent.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of compatible numeric types (mediumint unsigned), and 'objectID' in zt_actionrecent is intended to reference an object in another table. However, there is no direct evidence that 'objectID' refers to 'view_datasource_5.id', and the 'objectType' field in zt_actionrecent would typically be used to distinguish which table 'objectID' references. Since we do not know if 'view_datasource_5' is ever referenced by 'objectType', this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_5 t1 JOIN zt_actionrecent t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_5",
            "from_column": "id",
            "to_table": "zt_chart",
            "to_column": "dimension",
            "condition": "view_datasource_5.id = zt_chart.dimension",
            "confidence": "high",
            "reasoning": "Both fields are of type mediumint unsigned and could potentially be related if 'dimension' in zt_chart refers to a reference entity such as those listed in view_datasource_5. However, there is no explicit naming or business logic evidence to strongly support this relationship, and 'dimension' could represent something else entirely.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_5 t1 JOIN zt_chart t2 ON t1.id = t2.dimension LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 182,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_5",
            "from_column": "id",
            "to_table": "zt_zoutput",
            "to_column": "id",
            "condition": "view_datasource_5.id = zt_zoutput.id",
            "confidence": "high",
            "reasoning": "Although both tables have an 'id' field of the same type, these are both primary keys for their respective tables and are likely to be independently generated. There is no business logic or naming convention suggesting these IDs are related. This is a common field name but does not imply a relationship.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_5 t1 JOIN zt_zoutput t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "zt_action",
            "to_column": "objectID",
            "condition": "view_datasource_6.id = zt_action.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of compatible numeric types (mediumint), and 'objectID' in zt_action is intended to reference an object in another table. However, there is no direct evidence that 'objectID' refers to entries in view_datasource_6, nor is there a matching 'objectType' constraint or naming convention linking the two tables. This is a speculative relationship based solely on data type compatibility and common database patterns.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN zt_action t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 80,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "zt_acl",
            "to_column": "objectID",
            "condition": "view_datasource_6.id = zt_acl.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of type mediumint and could potentially represent the same entity ID in different contexts. However, there is no explicit indication that the 'objectID' in zt_acl refers to the 'id' in view_datasource_6, nor is there a matching 'objectType' field in view_datasource_6 to confirm the type of object. The relationship is possible if, in the business logic, view_datasource_6 represents an object type that is referenced in zt_acl, but this cannot be confirmed from the schemas alone.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN zt_acl t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "zt_actionrecent",
            "to_column": "objectID",
            "condition": "view_datasource_6.id = zt_actionrecent.objectID",
            "confidence": "high",
            "reasoning": "Both fields are of compatible numeric types (mediumint), and 'objectID' in zt_actionrecent is designed to reference the primary key of some object. However, without a matching 'objectType' or further context, there is no direct evidence that 'objectID' refers to 'view_datasource_6.id'. The relationship is possible in a polymorphic sense, but not strongly supported by the provided schemas alone.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN zt_actionrecent t2 ON t1.id = t2.objectID LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "zt_bug",
            "to_column": "id",
            "condition": "view_datasource_6.id = zt_bug.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field of similar type (mediumint), but in both cases, 'id' is used as a primary key for their respective tables and represents different entities (a catalog entry vs. a bug record). There is no business logic or naming convention suggesting these IDs are related. This join is not meaningful in a typical business context.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN zt_bug t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "title",
            "to_table": "zt_bug",
            "to_column": "title",
            "condition": "view_datasource_6.title = zt_bug.title",
            "confidence": "high",
            "reasoning": "Both tables have a 'title' field of type varchar(255), but the business meaning is different: in view_datasource_6, 'title' is a catalog/lookup description, while in zt_bug, it is the bug's summary/title. There is no evidence these titles are standardized or meant to match. This join is not meaningful without further context.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN zt_bug t2 ON t1.title = t2.title LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "zt_case",
            "to_column": "id",
            "condition": "view_datasource_6.id = zt_case.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field of similar type (mediumint), but in both schemas, 'id' is used as a primary key for their respective entities (catalog entry vs. test case). There is no evidence that these IDs are meant to reference each other, and their business purposes are unrelated. This is likely a coincidence due to common naming conventions.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN zt_case t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "zt_story",
            "to_column": "id",
            "condition": "view_datasource_6.id = zt_story.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of similar data type, but 'id' in each table is used as a primary key for different entities (catalog entry vs. story/requirement). There is no business or schema evidence that these IDs are related or that one references the other. Any join on these fields would be coincidental and not based on business logic.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN zt_story t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "ztv_executionsummary",
            "to_column": "execution",
            "condition": "view_datasource_6.id = ztv_executionsummary.execution",
            "confidence": "high",
            "reasoning": "The only possible relationship based on field names and data types is between 'id' (mediumint) in view_datasource_6 and 'execution' (mediumint unsigned) in ztv_executionsummary. Both are numeric identifiers and could theoretically represent a reference from execution summaries to a catalog of entities. However, there is no explicit foreign key, and the business purposes do not clearly align (one is a generic catalog, the other is an execution summary). This is a speculative relationship based solely on compatible data types and naming conventions.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN ztv_executionsummary t2 ON t1.id = t2.execution LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "ztv_normalproduct",
            "to_column": "id",
            "condition": "view_datasource_6.id = ztv_normalproduct.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field of similar data type (mediumint), but in typical database design, 'id' is a primary key for each table and is not intended to reference another table's 'id'. There is no business logic or naming convention suggesting that these ids are related. This is likely a coincidence, but a join could be tested for completeness.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN ztv_normalproduct t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "ztv_projectbugs",
            "to_column": "execution",
            "condition": "view_datasource_6.id = ztv_projectbugs.execution",
            "confidence": "high",
            "reasoning": "The only possible relationship based on schema is that 'id' (mediumint) in view_datasource_6 could correspond to 'execution' (mediumint unsigned) in ztv_projectbugs, as both are numeric and could represent a reference to an entity. However, there is no explicit naming or business logic connection between 'id' and 'execution', and their business purposes do not clearly overlap. This is a speculative relationship based solely on compatible data types and the possibility that 'view_datasource_6' is a catalog of entities that might be referenced by 'execution'.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN ztv_projectbugs t2 ON t1.id = t2.execution LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "view_datasource_6",
            "from_column": "id",
            "to_table": "ztv_projectsummary",
            "to_column": "project",
            "condition": "view_datasource_6.id = ztv_projectsummary.project",
            "confidence": "high",
            "reasoning": "The only possible relationship based on schema and naming is between view_datasource_6.id and ztv_projectsummary.project, as both are numeric fields and could represent an entity and its summary. However, there is no explicit indication from naming, business purpose, or schema that these fields are related. The id field in view_datasource_6 is a generic identifier, and project in ztv_projectsummary likely refers to a project entity not defined here. Data types are compatible (both are mediumint), but there is no strong business logic or naming convention to support this relationship.",
            "test_sql": "SELECT COUNT(*) FROM view_datasource_6 t1 JOIN ztv_projectsummary t2 ON t1.id = t2.project LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_acl",
            "from_column": "objectType",
            "to_table": "zt_metric",
            "to_column": "object",
            "condition": "zt_acl.objectType = zt_metric.object",
            "confidence": "high",
            "reasoning": "Both tables have a field named 'objectType' (zt_acl) and 'object' (zt_metric), both of type char(30). While the naming suggests a possible conceptual link (e.g., permissions on a type of object that is also measured as a metric), there is no explicit foreign key or business rule connecting them. The business purposes are different: zt_acl manages access, zt_metric defines metrics. The relationship is speculative and based only on naming and data type similarity.",
            "test_sql": "SELECT COUNT(*) FROM zt_acl t1 JOIN zt_metric t2 ON t1.objectType = t2.object LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 20,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_acl",
            "from_column": "account",
            "to_table": "zt_metriclib",
            "to_column": "user",
            "condition": "zt_acl.account = zt_metriclib.user",
            "confidence": "high",
            "reasoning": "The 'account' field in zt_acl and the 'user' field in zt_metriclib could both represent user identifiers. However, 'user' in zt_metriclib is of type TEXT (possibly a list or JSON), while 'account' is char(30), making direct matching unlikely. There is no explicit indication that these fields are meant to be joined, but the business logic of permissions and metrics per user could suggest a weak logical relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_acl t1 JOIN zt_metriclib t2 ON t1.account = t2.user LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_acl",
            "from_column": "account",
            "to_table": "zt_testresult",
            "to_column": "lastRunner",
            "condition": "zt_acl.account = zt_testresult.lastRunner",
            "confidence": "high",
            "reasoning": "Both fields are of similar type (char(30) vs varchar(30)) and could represent user accounts. However, there is no explicit indication that 'account' in zt_acl and 'lastRunner' in zt_testresult refer to the same entity, and there is no supporting foreign key or naming convention to confirm this. The relationship is possible if 'account' represents users who can run tests, but this is speculative.",
            "test_sql": "SELECT COUNT(*) FROM zt_acl t1 JOIN zt_testresult t2 ON t1.account = t2.lastRunner LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_acl",
            "from_column": "account",
            "to_table": "zt_testrun",
            "to_column": "lastRunner",
            "condition": "zt_acl.account = zt_testrun.lastRunner",
            "confidence": "high",
            "reasoning": "Both fields represent user/account identifiers (char(30) vs varchar(30)), and it is possible that ACLs could be used to control access or permissions for users who execute test runs. However, there is no explicit schema or business logic linking these fields, so the relationship is speculative and based only on naming and data type compatibility.",
            "test_sql": "SELECT COUNT(*) FROM zt_acl t1 JOIN zt_testrun t2 ON t1.account = t2.lastRunner LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "vision",
            "to_table": "zt_group",
            "to_column": "vision",
            "condition": "zt_action.vision = zt_group.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field (varchar(10)), which may represent a business segmentation or context. While the field names and types match, and both default to 'rnd', there is no clear business logic or operation directly linking actions to groups by vision alone. This could be used for filtering or reporting, but the relationship is weak and likely only useful in conjunction with other fields (such as project).",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_group t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1287,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_doclib",
            "to_column": "project",
            "condition": "zt_action.project = zt_doclib.project AND zt_action.project != 0",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field of the same type (mediumint unsigned), suggesting possible association with the same project entity. However, this is a weak relationship since 'project' is likely a reference to a project table not provided here, and does not directly link the two tables in a meaningful way without further context.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_doclib t2 ON t1.project = t2.project AND t1.project != 0 LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 201,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "execution",
            "to_table": "zt_doclib",
            "to_column": "execution",
            "condition": "zt_action.execution = zt_doclib.execution AND zt_action.execution != 0",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field of the same type, which may indicate association with the same execution entity. However, as with 'project', this is a weak statistical relationship and does not directly link the two tables without additional context.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_doclib t2 ON t1.execution = t2.execution AND t1.execution != 0 LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 55,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "vision",
            "to_table": "zt_doclib",
            "to_column": "vision",
            "condition": "zt_action.vision = zt_doclib.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field (varchar(10)), which may represent a business context or domain. However, this is not a unique or identifying relationship, but could be used for filtering or grouping in reporting.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_doclib t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 495,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectType",
            "to_table": "zt_pivotdrill",
            "to_column": "object",
            "condition": "zt_action.objectType = zt_pivotdrill.object",
            "confidence": "high",
            "reasoning": "Both tables have fields that refer to a business object type or name (zt_action.objectType and zt_pivotdrill.object). While the naming convention is similar and both are varchar fields, there is no direct evidence that these fields are intended to reference the same domain values or entities. The business purposes are also distinct: zt_action logs actions on objects, while zt_pivotdrill defines drill-down configurations for reports. However, if the system uses consistent object type naming, there could be a logical relationship for reporting or filtering actions by object type.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_pivotdrill t2 ON t1.objectType = t2.object LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 773,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "objectType",
            "to_table": "zt_metric",
            "to_column": "object",
            "condition": "zt_action.objectType = zt_metric.object",
            "confidence": "high",
            "reasoning": "Both fields describe an object type or name, but there is no guarantee that the values or semantics align. The relationship is possible if the system uses the same naming conventions for object types in both tables, but this is not certain from the schema alone.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_metric t2 ON t1.objectType = t2.object LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3531,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "actor",
            "to_table": "zt_effort",
            "to_column": "account",
            "condition": "zt_action.actor = zt_effort.account",
            "confidence": "high",
            "reasoning": "The 'actor' field in zt_action and the 'account' field in zt_effort both represent a user or system entity, but their data types differ (actor: varchar(100), account: varchar(30)). While they may sometimes refer to the same entity, the difference in length and possible value formats reduces confidence. This join could be useful for user activity analysis but may not always be reliable.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_effort t2 ON t1.actor = t2.account LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 162,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "actor",
            "to_table": "zt_metriclib",
            "to_column": "user",
            "condition": "zt_action.actor = zt_metriclib.user",
            "confidence": "high",
            "reasoning": "zt_action.actor is a varchar(100) and zt_metriclib.user is a text field. Both may represent a user or actor, but the lack of enforced structure and possible differences in value format (usernames, IDs, or lists) reduce confidence. Still, there may be cases where a direct match is possible.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_metriclib t2 ON t1.actor = t2.user LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 328,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "project",
            "to_table": "zt_projectadmin",
            "to_column": "projects",
            "condition": "FIND_IN_SET(CAST(zt_action.project AS CHAR), zt_projectadmin.projects) > 0",
            "confidence": "high",
            "reasoning": "zt_action.project is a numeric field, while zt_projectadmin.projects is a text field likely containing a comma-separated list of project IDs. There is a possible logical relationship: actions are linked to projects, and project admins have a list of projects they administer. However, the use of a text field for IDs is not ideal, and the relationship is not explicit or normalized.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_projectadmin t2 ON FIND_IN_SET(CAST(t1.project AS CHAR), t2.projects) > 0 LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 67,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "vision",
            "to_table": "zt_story",
            "to_column": "vision",
            "condition": "zt_action.vision = zt_story.vision",
            "confidence": "high",
            "reasoning": "Both tables have a vision field of the same type and default value, suggesting they may be used to partition or categorize data (e.g., by business line or product vision). However, this is not a direct foreign key or entity relationship, but could be used for filtering or grouping in reports.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_story t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 693,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "actor",
            "to_table": "zt_testresult",
            "to_column": "lastRunner",
            "condition": "zt_action.actor = zt_testresult.lastRunner",
            "confidence": "high",
            "reasoning": "Both tables have fields representing a user or actor (actor in zt_action, lastRunner in zt_testresult). While it's possible that the same person who runs a test (lastRunner) could also be the actor logging an action, there is no guarantee of a direct relationship, and the fields are not explicitly linked by schema or business logic. This is a weak, statistical or reporting relationship at best.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_testresult t2 ON t1.actor = t2.lastRunner LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 288,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "date",
            "to_table": "zt_testresult",
            "to_column": "date",
            "condition": "zt_action.date = zt_testresult.date",
            "confidence": "high",
            "reasoning": "Both tables have a date field, but these represent different events (action date vs. test result date). A join on date could be used for time-based correlation or reporting, but there is no direct business or logical relationship between these fields.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN zt_testresult t2 ON t1.date = t2.date LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_action",
            "from_column": "date",
            "to_table": "ztv_dayeffort",
            "to_column": "date",
            "condition": "DATE(zt_action.date) = ztv_dayeffort.date",
            "confidence": "high",
            "reasoning": "Both tables contain a 'date' field, but in zt_action it is a datetime (possibly including time), while in ztv_dayeffort it is a date (without time). There is no other field in common, and no explicit foreign key or business object identifier. The only possible relationship is a statistical or reporting join on the date, for example, to analyze actions and effort on the same day. However, this is a weak relationship as there is no guarantee that the actions and effort are related to the same business object or context.",
            "test_sql": "SELECT COUNT(*) FROM zt_action t1 JOIN ztv_dayeffort t2 ON DATE(t1.date) = t2.date LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 96,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_actionrecent",
            "from_column": "actor",
            "to_table": "zt_config",
            "to_column": "owner",
            "condition": "zt_actionrecent.actor = zt_config.owner",
            "confidence": "high",
            "reasoning": "The 'actor' field in zt_actionrecent and the 'owner' field in zt_config are both character fields that could represent users or entities. There is a possibility that configuration settings are owned by the same actors who perform actions, but there is no guarantee of semantic alignment or enforced referential integrity. This relationship is speculative and would depend on application-specific conventions.",
            "test_sql": "SELECT COUNT(*) FROM zt_actionrecent t1 JOIN zt_config t2 ON t1.actor = t2.owner LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_actionrecent",
            "from_column": "vision",
            "to_table": "zt_group",
            "to_column": "vision",
            "condition": "zt_actionrecent.vision = zt_group.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field (varchar(10)), which may represent a business segmentation or context. However, without further information about the meaning and usage of 'vision', the relationship is speculative and likely only useful for filtering or grouping, not as a direct join.",
            "test_sql": "SELECT COUNT(*) FROM zt_actionrecent t1 JOIN zt_group t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 39,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_actionrecent",
            "from_column": "objectType",
            "to_table": "zt_pivotdrill",
            "to_column": "object",
            "condition": "zt_actionrecent.objectType = zt_pivotdrill.object",
            "confidence": "high",
            "reasoning": "Both fields represent a type or name of a business object. 'objectType' in zt_actionrecent indicates the type of object an action was performed on, while 'object' in zt_pivotdrill likely refers to the data object being analyzed in a pivot drill. However, there is no guarantee that the values or naming conventions match, and there is no explicit foreign key or strong business logic linking these tables. This is a speculative, logical relationship based on naming and possible business context.",
            "test_sql": "SELECT COUNT(*) FROM zt_actionrecent t1 JOIN zt_pivotdrill t2 ON t1.objectType = t2.object LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_actionrecent",
            "from_column": "objectType",
            "to_table": "zt_metric",
            "to_column": "object",
            "condition": "zt_actionrecent.objectType = zt_metric.object",
            "confidence": "high",
            "reasoning": "The 'objectType' in zt_actionrecent and 'object' in zt_metric may both refer to the type of business object (e.g., project, product, etc.). If the metric is defined for a certain object type, and actions are logged for that object type, there could be a logical relationship. However, there is no guarantee that the values or semantics match, and no explicit foreign key or strong naming convention.",
            "test_sql": "SELECT COUNT(*) FROM zt_actionrecent t1 JOIN zt_metric t2 ON t1.objectType = t2.object LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 15,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_actionrecent",
            "from_column": "project",
            "to_table": "zt_metriclib",
            "to_column": "project",
            "condition": "zt_actionrecent.project = zt_metriclib.project",
            "confidence": "high",
            "reasoning": "Both tables have a 'project' field, suggesting a possible business association. However, the data types differ: zt_actionrecent.project is a mediumint unsigned (numeric), while zt_metriclib.project is a char(30) (string). Unless the numeric project ID is stored as a string in zt_metriclib, this join is unlikely to be reliable. There is no explicit foreign key or clear evidence of a direct relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_actionrecent t1 JOIN zt_metriclib t2 ON t1.project = t2.project LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 426,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_actionrecent",
            "from_column": "execution",
            "to_table": "zt_metriclib",
            "to_column": "execution",
            "condition": "zt_actionrecent.execution = zt_metriclib.execution",
            "confidence": "high",
            "reasoning": "Both tables have an 'execution' field, but zt_actionrecent.execution is a mediumint unsigned (numeric), while zt_metriclib.execution is a char(30) (string). Unless the execution IDs are stored as strings in zt_metriclib, this join is not reliable. No explicit foreign key or strong business logic is present.",
            "test_sql": "SELECT COUNT(*) FROM zt_actionrecent t1 JOIN zt_metriclib t2 ON t1.execution = t2.execution LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 474,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_activity",
            "from_column": "assignedTo",
            "to_table": "zt_bug",
            "to_column": "assignedTo",
            "condition": "zt_activity.assignedTo = zt_bug.assignedTo",
            "confidence": "high",
            "reasoning": "Both tables have an 'assignedTo' field of the same data type (varchar(30)), likely representing the user responsible for the activity or bug. However, without a user table or further context, this is only a logical or statistical relationship, not a foreign key. The business logic could involve reporting or filtering by the same assignee across activities and bugs.",
            "test_sql": "SELECT COUNT(*) FROM zt_activity t1 JOIN zt_bug t2 ON t1.assignedTo = t2.assignedTo LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 320,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_activity",
            "from_column": "assignedTo",
            "to_table": "zt_testrun",
            "to_column": "assignedTo",
            "condition": "zt_activity.assignedTo = zt_testrun.assignedTo",
            "confidence": "high",
            "reasoning": "Both tables have an 'assignedTo' field of similar type and length, likely representing the user or individual responsible for the activity or test run. However, without a shared user table or further context, this is only a possible business logic relationship, not a foreign key. The business meaning of 'assignedTo' may differ between activities and test runs.",
            "test_sql": "SELECT COUNT(*) FROM zt_activity t1 JOIN zt_testrun t2 ON t1.assignedTo = t2.assignedTo LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1280,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_activity",
            "from_column": "assignedTo",
            "to_table": "zt_story",
            "to_column": "assignedTo",
            "condition": "zt_activity.assignedTo = zt_story.assignedTo",
            "confidence": "high",
            "reasoning": "Both tables have an 'assignedTo' field of the same data type (varchar(30)), which likely refers to the user responsible for the activity or story. However, without a user table or further context, this is only a statistical or reporting relationship (e.g., to find all activities and stories assigned to the same person), not a true foreign key or business logic relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_activity t1 JOIN zt_story t2 ON t1.assignedTo = t2.assignedTo LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 2240,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_activity",
            "from_column": "createdBy",
            "to_table": "ztv_normalproduct",
            "to_column": "createdBy",
            "condition": "zt_activity.createdBy = ztv_normalproduct.createdBy",
            "confidence": "high",
            "reasoning": "Both tables have a 'createdBy' field, but this likely refers to the user who created the record in each table, not a direct relationship between activity and product. This could be used for statistical analysis (e.g., activities and products created by the same person), but not a business or foreign key relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_activity t1 JOIN ztv_normalproduct t2 ON t1.createdBy = t2.createdBy LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 640,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_ai_miniprogramfield",
            "from_column": "appID",
            "to_table": "zt_ai_prompt",
            "to_column": "id",
            "condition": "zt_ai_miniprogramfield.appID = zt_ai_prompt.id",
            "confidence": "high",
            "reasoning": "The only possible numeric field in zt_ai_miniprogramfield that could reference zt_ai_prompt is appID, and both are mediumint unsigned. However, based on naming conventions and business logic, appID likely refers to a mini-program or application entity, not an AI prompt. There is no clear semantic or business connection between a form field definition and an AI prompt record. This relationship is technically possible due to data type compatibility, but is not supported by business purpose or naming.",
            "test_sql": "SELECT COUNT(*) FROM zt_ai_miniprogramfield t1 JOIN zt_ai_prompt t2 ON t1.appID = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 44,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_ai_prompt",
            "from_column": "createdBy",
            "to_table": "zt_chart",
            "to_column": "createdBy",
            "condition": "zt_ai_prompt.createdBy = zt_chart.createdBy",
            "confidence": "high",
            "reasoning": "Both tables have a 'createdBy' field of similar type and length, likely representing the creator of the record. However, without a shared user/entity table or explicit foreign key, this is only a possible business logic relationship for filtering or reporting (e.g., prompts and charts created by the same person). There is no guarantee that the values are managed consistently across both tables.",
            "test_sql": "SELECT COUNT(*) FROM zt_ai_prompt t1 JOIN zt_chart t2 ON t1.createdBy = t2.createdBy LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1456,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_ai_prompt",
            "from_column": "createdBy",
            "to_table": "zt_pivot",
            "to_column": "createdBy",
            "condition": "zt_ai_prompt.createdBy = zt_pivot.createdBy",
            "confidence": "high",
            "reasoning": "Both tables have a 'createdBy' field of the same data type (varchar(30)), which could indicate that prompts and pivots are created by the same entity (e.g., a user or system process). However, without a shared user/entity table or further context, this is only a weak business logic relationship and not a true foreign key.",
            "test_sql": "SELECT COUNT(*) FROM zt_ai_prompt t1 JOIN zt_pivot t2 ON t1.createdBy = t2.createdBy LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 232,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_approvalflow",
            "from_column": "createdBy",
            "to_table": "zt_pivot",
            "to_column": "createdBy",
            "condition": "zt_approvalflow.createdBy = zt_pivot.createdBy",
            "confidence": "high",
            "reasoning": "Both tables have a 'createdBy' field of the same data type and length, likely representing the creator of the record. However, without a user table or further context, this is only a weak business logic relationship, not a true foreign key. It could be used to find all pivots and approval flows created by the same person, but this is not a direct entity relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_approvalflow t1 JOIN zt_pivot t2 ON t1.createdBy = t2.createdBy LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 116,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "vision",
            "to_table": "zt_doclib",
            "to_column": "vision",
            "condition": "zt_block.vision = zt_doclib.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field of the same type and default value, which may represent a product line, business area, or application context. However, there is no explicit indication that these fields are intended to link records between the two tables. The relationship is possible only if the application uses 'vision' as a scoping or filtering mechanism across both dashboard blocks and document libraries.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_doclib t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 120,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "vision",
            "to_table": "zt_searchindex",
            "to_column": "vision",
            "condition": "zt_block.vision = zt_searchindex.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field, which may represent a product line, application area, or context. While this could be used to filter or group data in both tables, it does not establish a direct relationship between individual records. This is more of a logical or filtering relationship than a true joinable relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_searchindex t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 768,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "vision",
            "to_table": "zt_workflowdatasource",
            "to_column": "vision",
            "condition": "zt_block.vision = zt_workflowdatasource.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field of the same type and default value, likely used for product line or application area segmentation. However, there is no clear business logic or foreign key relationship between the two tables based solely on 'vision'. The field may be used for filtering or grouping, but not as a direct join key.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_workflowdatasource t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1650,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_block",
            "from_column": "vision",
            "to_table": "zt_workflowgroup",
            "to_column": "vision",
            "condition": "zt_block.vision = zt_workflowgroup.vision",
            "confidence": "high",
            "reasoning": "Both tables have a 'vision' field of the same type and default value ('rnd'), suggesting a possible logical grouping or filtering by product line or application area. However, there is no evidence that this is a foreign key or that the values are managed in a way that enforces a direct relationship. This is more likely a business logic or reporting filter than a true relational join.",
            "test_sql": "SELECT COUNT(*) FROM zt_block t1 JOIN zt_workflowgroup t2 ON t1.vision = t2.vision LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 120,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "branch",
            "to_table": "zt_module",
            "to_column": "branch",
            "condition": "zt_bug.branch = zt_module.branch",
            "confidence": "high",
            "reasoning": "Both tables have a 'branch' field of the same type and name, but without further context, it's unclear if these represent the same domain concept. In some systems, 'branch' may refer to code branches or product branches, but the business logic is ambiguous here. This could be a statistical or logical relationship, but confidence is low.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_module t2 ON t1.branch = t2.branch LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 316,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_bug",
            "from_column": "product",
            "to_table": "zt_system",
            "to_column": "product",
            "condition": "zt_bug.product = zt_system.product",
            "confidence": "high",
            "reasoning": "Both tables have a 'product' field of the same data type (mediumint unsigned), and both reference a product entity. However, this does not directly link a bug to a system, but rather to the same product context. This could be used for statistical or reporting purposes to aggregate bugs by systems under the same product, but it is not a direct foreign key relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_bug t1 JOIN zt_system t2 ON t1.product = t2.product LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "branch",
            "to_table": "zt_module",
            "to_column": "branch",
            "condition": "zt_build.branch = CAST(zt_module.branch AS CHAR)",
            "confidence": "high",
            "reasoning": "Both tables have a 'branch' field, but the data types differ: zt_build.branch is varchar(255) (default '0'), while zt_module.branch is mediumint unsigned (default 0). The naming suggests a possible logical connection (e.g., both referencing a branch concept), but the type mismatch and lack of explicit foreign key or business context make this relationship weak. It is possible that zt_build.branch stores numeric IDs as strings, but this is speculative.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_module t2 ON t1.branch = CAST(t2.branch AS CHAR) LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 79,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "system",
            "to_table": "zt_metriclib",
            "to_column": "system",
            "condition": "CAST(zt_build.system AS CHAR) = zt_metriclib.system",
            "confidence": "high",
            "reasoning": "Both tables have a 'system' field, but in zt_build it is a numeric (mediumint unsigned), while in zt_metriclib it is a char(30). The meaning of 'system' may differ, and the type mismatch further reduces confidence. This relationship is possible but less likely to be reliable.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_metriclib t2 ON CAST(t1.system AS CHAR) = t2.system LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 68,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "['project', 'product', 'branch']",
            "to_table": "zt_projectproduct",
            "to_column": "['project', 'product', 'branch']",
            "condition": "zt_build.project = zt_projectproduct.project AND zt_build.product = zt_projectproduct.product AND zt_build.branch = CAST(zt_projectproduct.branch AS CHAR)",
            "confidence": "high",
            "reasoning": "All three fields (project, product, branch) exist in both tables and likely represent the same business entities. However, the data types for 'branch' differ (varchar in zt_build, mediumint in zt_projectproduct), which may cause mismatches unless the varchar in zt_build always contains numeric values matching the int in zt_projectproduct. This join is only valid if the data is compatible or can be cast appropriately.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_projectproduct t2 ON t1.project = t2.project AND t1.product = t2.product AND t1.branch = CAST(t2.branch AS CHAR) LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "branch",
            "to_table": "zt_story",
            "to_column": "branch",
            "condition": "zt_build.branch = CAST(zt_story.branch AS CHAR)",
            "confidence": "high",
            "reasoning": "Both tables have a 'branch' field, but zt_build.branch is varchar(255) and zt_story.branch is mediumint unsigned. This suggests a possible relationship, but the data types are not directly compatible. If zt_build.branch stores numeric branch IDs as strings, a join may be possible by casting. However, the default value of '0' as a string in zt_build and as an integer in zt_story, and the lack of explicit foreign keys, make this relationship uncertain.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN zt_story t2 ON t1.branch = CAST(t2.branch AS CHAR) LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "date",
            "to_table": "ztv_daybugresolve",
            "to_column": "day",
            "condition": "zt_build.date = ztv_daybugresolve.day",
            "confidence": "high",
            "reasoning": "Both fields represent dates, and it is plausible that builds and bug resolutions could be analyzed or reported by date. However, there is no direct evidence in the schema or business logic that explicitly links a build's date to the daily bug resolution count. The relationship is speculative and would likely only be used for statistical or reporting purposes (e.g., aggregating builds and bug resolutions by day), not as a foreign key or direct business logic join.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN ztv_daybugresolve t2 ON t1.date = t2.day LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_build",
            "from_column": "date",
            "to_table": "ztv_dayeffort",
            "to_column": "date",
            "condition": "zt_build.date = ztv_dayeffort.date",
            "confidence": "high",
            "reasoning": "Both tables contain a 'date' field of the same data type. However, there is no explicit business logic or foreign key relationship connecting a build record to a daily effort record. The only possible connection is that both may reference the same calendar date, which could be used for statistical or reporting purposes (e.g., aggregating effort spent on days when builds occurred). This is a weak, statistical relationship rather than a true logical or foreign key relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_build t1 JOIN ztv_dayeffort t2 ON t1.date = t2.date LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "date",
            "to_table": "ztv_daybugresolve",
            "to_column": "day",
            "condition": "zt_burn.date = ztv_daybugresolve.day",
            "confidence": "high",
            "reasoning": "Both tables contain a date field (zt_burn.date and ztv_daybugresolve.day) that could represent the same calendar day. While zt_burn tracks task progress per day and ztv_daybugresolve tracks the number of bugs resolved per day, there is no direct business or foreign key relationship. However, a statistical or reporting join could be made on the date fields to correlate team progress with bug resolution activity for reporting or analytics purposes.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN ztv_daybugresolve t2 ON t1.date = t2.day LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "date",
            "to_table": "ztv_daystoryopen",
            "to_column": "day",
            "condition": "zt_burn.date = ztv_daystoryopen.day",
            "confidence": "high",
            "reasoning": "The only field with matching data type and potential semantic overlap is 'date' in zt_burn and 'day' in ztv_daystoryopen. Both represent a calendar date, and both tables track daily metrics (burn-down data and story open counts, respectively). However, there is no direct business or logical link between the two tables based on the provided schemas and business purposes. The join could be used for time series analysis or to correlate project activity with story engagement, but this is speculative and not strongly supported by the schema.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN ztv_daystoryopen t2 ON t1.date = t2.day LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_burn",
            "from_column": "date",
            "to_table": "ztv_dayuserlogin",
            "to_column": "day",
            "condition": "zt_burn.date = ztv_dayuserlogin.day",
            "confidence": "high",
            "reasoning": "Both tables contain a date field (zt_burn.date and ztv_dayuserlogin.day) with the same data type. However, there is no direct business or logical connection between task burn tracking and user login activity based solely on the date. A join on date could be used for statistical or reporting purposes (e.g., correlating project activity with user logins), but there is no evidence of a foreign key or business logic relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_burn t1 JOIN ztv_dayuserlogin t2 ON t1.date = t2.day LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_case",
            "from_column": "openedDate",
            "to_table": "ztv_daybugopen",
            "to_column": "day",
            "condition": "DATE(zt_case.openedDate) = ztv_daybugopen.day",
            "confidence": "high",
            "reasoning": "The only possible connection is that zt_case.openedDate (datetime) could correspond to ztv_daybugopen.day (date), allowing aggregation of test cases created on the same day as bugs opened. However, there is no direct field or business logic explicitly linking test cases to bug open counts per day. This is a statistical or reporting relationship, not a foreign key or logical join.",
            "test_sql": "SELECT COUNT(*) FROM zt_case t1 JOIN ztv_daybugopen t2 ON DATE(t1.openedDate) = t2.day LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "zt_casestep",
            "from_column": "case",
            "to_table": "zt_task",
            "to_column": "id",
            "condition": "zt_casestep.case = zt_task.id",
            "confidence": "high",
            "reasoning": "The 'case' field in zt_casestep and the 'id' field in zt_task are both mediumint unsigned and could theoretically be related if a 'case' in zt_casestep refers to a task in zt_task. However, based on the business purposes, 'case' likely refers to a test case entity, not a task. There is no explicit evidence in the schemas or business logic that these two fields are related, but the data types and naming conventions allow for a possible, though unlikely, relationship.",
            "test_sql": "SELECT COUNT(*) FROM zt_casestep t1 JOIN zt_task t2 ON t1.case = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        }
    ]
}