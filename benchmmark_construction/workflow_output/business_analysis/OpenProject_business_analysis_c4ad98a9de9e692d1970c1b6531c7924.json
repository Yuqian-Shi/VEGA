{
    "core_tables": [
        "ar_internal_metadata",
        "attachment_journals",
        "attachments",
        "categories",
        "colors",
        "delayed_jobs",
        "enabled_modules",
        "enumerations",
        "grid_widgets",
        "grids",
        "journals",
        "meeting_agenda_items",
        "meeting_journals",
        "meeting_participants",
        "meetings",
        "member_roles",
        "members",
        "menu_items",
        "news",
        "news_journals",
        "notification_settings",
        "ordered_work_packages",
        "project_journals",
        "projects",
        "projects_types",
        "queries",
        "relations",
        "role_permissions",
        "roles",
        "schema_migrations",
        "sessions",
        "settings",
        "statuses",
        "tokens",
        "types",
        "user_passwords",
        "user_preferences",
        "users",
        "version_settings",
        "versions",
        "views",
        "watchers",
        "wiki_page_journals",
        "wiki_pages",
        "wikis",
        "work_package_hierarchies",
        "work_package_journals",
        "work_packages",
        "workflows"
    ],
    "table_analysis": {
        "ar_internal_metadata": {
            "business_purpose": "The 'ar_internal_metadata' table is typically used in web applications, particularly those using the Ruby on Rails framework, to store internal metadata about the application's environment or state. It is not directly related to business entities but rather serves as a mechanism for the application to manage its own operational state.",
            "key_fields": [
                "key",
                "value",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "This table is generally standalone and does not have direct relationships with other business tables. It is used internally by the application framework to store metadata, such as environment information or versioning data."
            ],
            "business_operations": [
                "Operations involving this table would include application initialization, environment configuration, and possibly version control or migration processes. It is not typically involved in business logic or user-facing operations."
            ]
        },
        "attachment_journals": {
            "business_purpose": "The 'attachment_journals' table is designed to store information about file attachments related to various entities or processes within a business system. It likely serves as a repository for managing and tracking files that are associated with different containers, which could be projects, tasks, or other business objects.",
            "key_fields": [
                "id",
                "container_id",
                "container_type",
                "filename",
                "disk_filename",
                "filesize",
                "digest",
                "downloads",
                "author_id"
            ],
            "potential_relationships": [
                "The 'container_id' and 'container_type' fields suggest a polymorphic relationship with other tables, where attachments can be linked to various types of entities or records.",
                "The 'author_id' field indicates a potential relationship with a table that stores author or user information, linking attachments to the individuals who created or uploaded them."
            ],
            "business_operations": [
                "Uploading and storing file attachments related to business processes or entities.",
                "Retrieving and downloading files for review or use in business operations.",
                "Tracking the number of times a file has been downloaded, which could be useful for analytics or auditing purposes.",
                "Managing metadata about files, such as their size, type, and description, to facilitate organization and retrieval."
            ]
        },
        "attachments": {
            "business_purpose": "The 'attachments' table represents a system for managing files or documents that are associated with various entities or processes within a business application. It stores metadata about each file, such as its name, size, type, and author, as well as tracking download counts and timestamps for creation and updates.",
            "key_fields": [
                "id",
                "container_id",
                "container_type",
                "filename",
                "disk_filename",
                "filesize",
                "content_type",
                "digest",
                "downloads",
                "author_id",
                "created_at",
                "updated_at",
                "status"
            ],
            "potential_relationships": [
                "The 'container_id' and 'container_type' fields suggest a polymorphic association, where attachments can be linked to various types of entities or records within the system.",
                "The 'author_id' field indicates a relationship with a user or author entity, which would be responsible for creating or uploading the attachment."
            ],
            "business_operations": [
                "Uploading and storing files or documents related to different business entities or processes.",
                "Retrieving and downloading attachments for viewing or processing.",
                "Tracking and managing metadata about attachments, such as file size, type, and download counts.",
                "Searching and indexing file contents using full-text search capabilities provided by 'fulltext_tsv' and 'file_tsv' fields."
            ]
        },
        "categories": {
            "business_purpose": "The 'categories' table is likely used to organize or classify different elements within a project management system. Each category is associated with a specific project and can be assigned to a user or team member, facilitating task or resource management within that project.",
            "key_fields": [
                "id",
                "project_id",
                "name",
                "assigned_to_id",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "The 'project_id' field suggests a relationship with a 'projects' table, where each category belongs to a specific project.",
                "The 'assigned_to_id' field implies a potential relationship with a 'users' or 'team_members' table, indicating which user or team member is responsible for the category."
            ],
            "business_operations": [
                "Creating new categories for organizing tasks or resources within a project.",
                "Updating category details, such as changing the name or reassigning it to a different user.",
                "Tracking the creation and modification times of categories for auditing or reporting purposes.",
                "Assigning categories to specific users or team members to manage responsibilities within a project."
            ]
        },
        "colors": {
            "business_purpose": "The 'colors' table represents a catalog or repository of color information, likely used in a system that requires color management, such as a design application, e-commerce platform, or any application that involves color selection or customization.",
            "key_fields": [
                "id",
                "name",
                "hexcode"
            ],
            "potential_relationships": [
                "This table might have a one-to-many relationship with a 'products' table if colors are used to define product variations.",
                "It could have a many-to-many relationship with a 'designs' table if multiple colors can be associated with a single design.",
                "A one-to-many relationship with a 'themes' table if colors are used to define different themes or palettes."
            ],
            "business_operations": [
                "Adding new colors to the system for use in various applications.",
                "Retrieving color information for display or selection in user interfaces.",
                "Updating color details, such as changing the name or hexcode.",
                "Tracking the creation and modification times of color entries for auditing or version control purposes."
            ]
        },
        "delayed_jobs": {
            "business_purpose": "The 'delayed_jobs' table represents a job queue system used to manage and execute background tasks or jobs that are scheduled to run at a later time. This is typically used in applications to handle asynchronous processing, such as sending emails, processing data, or performing other tasks that do not need to be executed immediately.",
            "key_fields": [
                "id",
                "priority",
                "attempts",
                "handler",
                "run_at",
                "locked_at",
                "failed_at",
                "locked_by",
                "created_at",
                "updated_at",
                "queue",
                "cron"
            ],
            "potential_relationships": [
                "This table might relate to a table that logs job execution results or history.",
                "It could be associated with a table that defines job types or categories, potentially using the 'queue' field.",
                "There might be a relationship with a table that manages worker nodes or processes, which could be linked via the 'locked_by' field."
            ],
            "business_operations": [
                "Scheduling jobs to be executed at a specific time or on a recurring basis using the 'run_at' and 'cron' fields.",
                "Prioritizing jobs based on the 'priority' field to ensure critical tasks are executed first.",
                "Tracking job execution attempts and errors using the 'attempts' and 'last_error' fields.",
                "Managing job locks and execution status with 'locked_at', 'locked_by', and 'failed_at' fields to prevent duplicate processing and handle failures."
            ]
        },
        "enabled_modules": {
            "business_purpose": "The 'enabled_modules' table likely represents a configuration or settings entity within a software application, where different modules or features can be enabled or disabled for specific projects. This allows for customization of functionality on a per-project basis.",
            "key_fields": [
                "id",
                "project_id",
                "name"
            ],
            "potential_relationships": [
                "The 'project_id' field suggests a potential relationship with a 'projects' table, where each entry in 'enabled_modules' is associated with a specific project.",
                "The 'name' field indicates the type of module or feature that is enabled, which could relate to a 'modules' or 'features' table if such a table exists."
            ],
            "business_operations": [
                "Enabling or disabling specific modules for a project, which involves inserting or deleting records in this table.",
                "Retrieving the list of enabled modules for a given project to determine available features.",
                "Auditing or reporting on which modules are enabled across different projects for management or compliance purposes."
            ]
        },
        "enumerations": {
            "business_purpose": "The 'enumerations' table likely represents a system for managing various types of enumerated values or categories that can be used across different parts of a business application. These enumerations could be used to define lists of options, statuses, or types that are configurable and can be associated with projects or other entities.",
            "key_fields": [
                "id",
                "name",
                "type",
                "is_default",
                "active",
                "project_id",
                "parent_id"
            ],
            "potential_relationships": [
                "The 'project_id' field suggests a potential relationship with a 'projects' table, where enumerations can be specific to certain projects.",
                "The 'parent_id' field indicates a hierarchical relationship within the enumerations table itself, allowing for nested or grouped enumerations.",
                "The 'color_id' field suggests a potential relationship with a 'colors' table, where each enumeration might be associated with a specific color for display purposes."
            ],
            "business_operations": [
                "Creating and managing lists of options or categories for use in forms, dropdowns, or other UI elements.",
                "Configuring default values for certain types of enumerations using the 'is_default' field.",
                "Activating or deactivating enumerations based on business needs, controlled by the 'active' field.",
                "Organizing enumerations into hierarchical structures using the 'parent_id' field, which could be useful for complex categorization."
            ]
        },
        "grid_widgets": {
            "business_purpose": "The 'grid_widgets' table likely represents a system for managing widgets or components within a grid layout. This could be part of a user interface design tool, dashboard configuration, or any application that requires dynamic placement of elements in a grid structure.",
            "key_fields": [
                "id",
                "start_row",
                "end_row",
                "start_column",
                "end_column",
                "grid_id"
            ],
            "potential_relationships": [
                "The 'grid_id' field suggests a potential relationship with a 'grids' table, where each grid can have multiple widgets.",
                "The 'identifier' field might be used to relate to a table that defines widget types or properties, although this is speculative without further context."
            ],
            "business_operations": [
                "Creating and configuring grid layouts by placing widgets at specific positions.",
                "Updating widget positions or dimensions within a grid.",
                "Retrieving widget configurations for rendering a grid-based interface.",
                "Deleting widgets from a grid layout."
            ]
        },
        "grids": {
            "business_purpose": "The 'grids' table likely represents a data structure or layout configuration used in a software application. It could be used to define grid-based layouts for user interfaces, data visualization, or other grid-related functionalities within a project or application.",
            "key_fields": [
                "id",
                "row_count",
                "column_count",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "The 'user_id' field suggests a potential relationship with a table that stores user information, indicating that grids might be associated with specific users.",
                "The 'project_id' field implies a possible relationship with a projects table, suggesting that grids could be part of a larger project or collection of work.",
                "The 'type' field might relate to a categorization or classification system, potentially linking to a table that defines different grid types."
            ],
            "business_operations": [
                "Creating new grid configurations for projects or users.",
                "Updating existing grid layouts to reflect changes in design or data requirements.",
                "Retrieving grid information for rendering user interfaces or visualizations.",
                "Managing grid options and settings to customize the appearance or behavior of grids."
            ]
        },
        "journals": {
            "business_purpose": "The 'journals' table appears to represent a logging or journaling system for tracking changes or events related to various entities within a business application. It captures details about the changes, the user responsible, and the context of the change.",
            "key_fields": [
                "id",
                "journable_type",
                "journable_id",
                "user_id",
                "created_at",
                "data_type",
                "data_id"
            ],
            "potential_relationships": [
                "Polymorphic relationship with other entities through 'journable_type' and 'journable_id', allowing it to log changes for different types of entities.",
                "Relationship with a 'users' table through 'user_id' to identify the user responsible for the journal entry.",
                "Relationship with other data entities through 'data_type' and 'data_id', indicating the specific data item affected by the journal entry."
            ],
            "business_operations": [
                "Tracking changes or updates to various entities within the system.",
                "Auditing user actions and maintaining a history of changes for accountability.",
                "Providing a timeline of events or changes for reporting and analysis purposes.",
                "Supporting rollback or version control functionality by maintaining a history of changes."
            ]
        },
        "meeting_agenda_items": {
            "business_purpose": "The 'meeting_agenda_items' table represents the agenda items associated with meetings. It is used to organize and manage the topics or points to be discussed during a meeting, including details such as the author of the agenda item, its title, notes, position in the agenda, and timing details.",
            "key_fields": [
                "id",
                "meeting_id",
                "author_id",
                "title",
                "position",
                "start_time",
                "end_time",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "This table has a foreign key relationship with the 'users' table through 'author_id', indicating which user authored the agenda item. It also relates to the 'meetings' table through 'meeting_id', linking each agenda item to a specific meeting."
            ],
            "business_operations": [
                "Creating and organizing agenda items for meetings",
                "Assigning authors to agenda items",
                "Scheduling agenda items within a meeting",
                "Tracking changes to agenda items over time",
                "Linking agenda items to specific work packages for project management purposes"
            ]
        },
        "meeting_journals": {
            "business_purpose": "The 'meeting_journals' table is designed to store records of meetings, capturing details such as the meeting's title, author, associated project, location, start time, and duration. This table is likely used to document and manage meetings within an organization, providing a structured way to track and reference past meetings.",
            "key_fields": [
                "id",
                "title",
                "author_id",
                "project_id",
                "start_time"
            ],
            "potential_relationships": [
                "The 'author_id' field suggests a potential relationship with a table that stores information about authors or users, indicating who created or is responsible for the meeting record.",
                "The 'project_id' field implies a relationship with a table that manages projects, linking meetings to specific projects they are associated with.",
                "The 'location' field could relate to a table that manages locations or venues, although this is less explicit."
            ],
            "business_operations": [
                "Scheduling and documenting meetings, including setting the title, author, and project association.",
                "Tracking meeting history for projects, allowing users to view past meetings related to specific projects.",
                "Analyzing meeting data, such as frequency, duration, and locations, to optimize meeting management within the organization."
            ]
        },
        "meeting_participants": {
            "business_purpose": "The 'meeting_participants' table represents the participants involved in meetings, capturing details about their identity, participation status, and timestamps for record-keeping.",
            "key_fields": [
                "id",
                "user_id",
                "meeting_id",
                "email",
                "invited",
                "attended",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "This table might have a relationship with a 'meetings' table through the 'meeting_id' field, indicating which meeting the participant is associated with.",
                "It might also relate to a 'users' table through the 'user_id' field, linking participants to user profiles if they exist in the system."
            ],
            "business_operations": [
                "Tracking which users are invited to meetings and whether they attended.",
                "Managing and updating participant lists for meetings.",
                "Generating reports on meeting attendance and participation.",
                "Sending invitations and follow-up communications to participants based on their email and invitation status."
            ]
        },
        "meetings": {
            "business_purpose": "The 'meetings' table represents a system for scheduling and managing meetings within an organization. It captures essential details about each meeting, such as its title, author, associated project, location, timing, and duration. The table also tracks the creation and update timestamps, the state of the meeting, its type, and a version for concurrency control.",
            "key_fields": [
                "id",
                "title",
                "author_id",
                "project_id",
                "start_time",
                "duration",
                "created_at",
                "updated_at",
                "state",
                "type",
                "lock_version"
            ],
            "potential_relationships": [
                "The 'author_id' field suggests a potential relationship with a table that stores information about authors or organizers of the meetings.",
                "The 'project_id' field indicates a possible relationship with a table that contains project details, linking meetings to specific projects.",
                "The 'state' field could relate to a table defining various states or statuses a meeting can have."
            ],
            "business_operations": [
                "Scheduling new meetings by inserting records with details such as title, author, project, location, and timing.",
                "Updating meeting details, such as rescheduling or changing the location, which would involve modifying existing records.",
                "Tracking the history and changes of meetings using the 'created_at', 'updated_at', and 'lock_version' fields for concurrency control.",
                "Managing meeting states, such as marking meetings as completed or canceled, using the 'state' field."
            ]
        },
        "member_roles": {
            "business_purpose": "The 'member_roles' table is designed to manage the roles assigned to members within an organization or system. It tracks which roles are associated with each member and allows for the possibility of roles being inherited from other entities.",
            "key_fields": [
                "id",
                "member_id",
                "role_id",
                "inherited_from"
            ],
            "potential_relationships": [
                "The 'member_id' field suggests a relationship with a table that stores member information, potentially linking each role assignment to a specific member.",
                "The 'role_id' field indicates a relationship with a table that defines roles, linking each member to specific roles they hold.",
                "The 'inherited_from' field suggests a hierarchical or inheritance relationship, where roles can be inherited from other entities, possibly linking to another table that tracks role inheritance or parent-child relationships."
            ],
            "business_operations": [
                "Assigning roles to members, which involves inserting new records into the table.",
                "Updating role assignments, which may involve modifying the 'role_id' or 'inherited_from' fields.",
                "Querying to determine which roles a member currently holds, including inherited roles.",
                "Managing role inheritance, which involves understanding and updating the 'inherited_from' field to reflect changes in role hierarchy."
            ]
        },
        "members": {
            "business_purpose": "The 'members' table likely represents the association of users with projects or other entities within a system. It tracks membership or participation details, potentially in a collaborative or project management context.",
            "key_fields": [
                "id",
                "user_id",
                "project_id",
                "entity_type",
                "entity_id"
            ],
            "potential_relationships": [
                "The 'user_id' field suggests a relationship with a table that stores user information, indicating which user is a member.",
                "The 'project_id' field implies a connection to a table that manages project details, indicating which project the user is associated with.",
                "The 'entity_type' and 'entity_id' fields suggest a polymorphic relationship, where the member can be associated with various types of entities, not limited to projects."
            ],
            "business_operations": [
                "Adding a user to a project or other entity, creating a new membership record.",
                "Updating membership details, such as changing the associated project or entity.",
                "Tracking when a user was added to a project or entity, using the 'created_at' timestamp.",
                "Monitoring changes to membership records over time, using the 'updated_at' timestamp."
            ]
        },
        "menu_items": {
            "business_purpose": "The 'menu_items' table likely represents a hierarchical structure of menu items, which could be used in a website or application navigation system. Each entry in the table corresponds to a menu item that can have a parent-child relationship with other menu items, allowing for nested menus.",
            "key_fields": [
                "id",
                "name",
                "parent_id",
                "navigatable_id",
                "type"
            ],
            "potential_relationships": [
                "Self-referential relationship through 'parent_id' to establish a hierarchy of menu items.",
                "Potential relationship with another table that stores navigatable entities, indicated by 'navigatable_id'. This could link to pages, sections, or other content types that the menu item points to."
            ],
            "business_operations": [
                "Creating and managing the structure of a navigation menu.",
                "Retrieving menu items for display in a user interface, potentially in a hierarchical format.",
                "Updating menu items to change their position or hierarchy within the menu.",
                "Linking menu items to specific content or pages within an application or website."
            ]
        },
        "news": {
            "business_purpose": "The 'news' table represents a collection of news articles or updates related to projects. It is designed to store information about individual news items, including their titles, summaries, full descriptions, authorship, and associated project details.",
            "key_fields": [
                "id",
                "project_id",
                "title",
                "author_id",
                "created_at",
                "comments_count"
            ],
            "potential_relationships": [
                "The 'project_id' field suggests a potential relationship with a 'projects' table, where each news item could be associated with a specific project.",
                "The 'author_id' field indicates a possible relationship with an 'authors' or 'users' table, linking each news item to its creator or author."
            ],
            "business_operations": [
                "Creating and publishing new articles or updates related to projects.",
                "Retrieving and displaying news articles for specific projects or authors.",
                "Updating existing news articles with new information or corrections.",
                "Tracking and displaying the number of comments on each news article.",
                "Archiving or deleting outdated or irrelevant news articles."
            ]
        },
        "news_journals": {
            "business_purpose": "The 'news_journals' table represents a collection of journal entries or articles related to news projects. Each entry is likely associated with a specific project and authored by a particular individual, capturing the title, summary, and detailed description of the news content.",
            "key_fields": [
                "id",
                "project_id",
                "title",
                "author_id",
                "comments_count"
            ],
            "potential_relationships": [
                "The 'project_id' field suggests a potential relationship with a 'projects' table, where each news journal entry is linked to a specific project.",
                "The 'author_id' field indicates a possible relationship with an 'authors' or 'users' table, identifying the creator of the journal entry.",
                "The 'comments_count' field implies a relationship with a 'comments' table, where comments related to each journal entry are stored and counted."
            ],
            "business_operations": [
                "Creating and storing new journal entries related to news projects.",
                "Retrieving and displaying journal entries based on project or author.",
                "Updating journal entries with new information or corrections.",
                "Counting and managing comments associated with each journal entry."
            ]
        },
        "notification_settings": {
            "business_purpose": "The 'notification_settings' table represents the configuration of notification preferences for users within a project management system. It allows users to customize which events they want to receive notifications for, such as changes in work packages, news updates, document additions, and more.",
            "key_fields": [
                "id",
                "project_id",
                "user_id",
                "watched",
                "mentioned",
                "created_at",
                "updated_at",
                "assignee",
                "responsible",
                "shared"
            ],
            "potential_relationships": [
                "One-to-Many relationship with the 'projects' table, where each project can have multiple notification settings.",
                "One-to-Many relationship with the 'users' table, where each user can have multiple notification settings for different projects."
            ],
            "business_operations": [
                "Configuring user notification preferences for different events within a project.",
                "Retrieving user-specific notification settings to determine which notifications to send.",
                "Updating notification settings when a user changes their preferences.",
                "Auditing changes to notification settings by tracking 'created_at' and 'updated_at' timestamps."
            ]
        },
        "ordered_work_packages": {
            "business_purpose": "The 'ordered_work_packages' table represents a system for organizing and managing work packages in a specific order, likely within the context of project management or task tracking. It allows for the association of work packages with queries, which could be used to filter or categorize these packages based on certain criteria.",
            "key_fields": [
                "id",
                "position",
                "query_id",
                "work_package_id"
            ],
            "potential_relationships": [
                "The 'work_package_id' field establishes a relationship with the 'work_packages' table, indicating that each entry in 'ordered_work_packages' is linked to a specific work package.",
                "The 'query_id' field establishes a relationship with the 'queries' table, suggesting that each ordered work package can be associated with a specific query, possibly for filtering or categorization purposes."
            ],
            "business_operations": [
                "Ordering and prioritizing work packages within a project or task management system.",
                "Associating work packages with specific queries to facilitate filtering, reporting, or categorization.",
                "Managing the sequence of tasks or work packages to ensure proper workflow and task execution."
            ]
        },
        "project_journals": {
            "business_purpose": "The 'project_journals' table likely represents a system for managing and tracking various projects or initiatives within an organization. Each entry in the table corresponds to a specific project journal, which may include details about the project's name, description, visibility, and status.",
            "key_fields": [
                "id",
                "name",
                "public",
                "identifier",
                "active",
                "templated"
            ],
            "potential_relationships": [
                "Hierarchical relationship with itself through 'parent_id' to represent sub-projects or related projects",
                "Potential relationship with a 'status' table to provide more detailed information about the 'status_code'",
                "Possible linkage to a 'templates' table if 'templated' projects are based on predefined templates"
            ],
            "business_operations": [
                "Creating new project journals to document and initiate new projects",
                "Updating existing project journals to reflect changes in project status or details",
                "Retrieving project journals for reporting and analysis purposes",
                "Managing project visibility and access through the 'public' field",
                "Organizing projects hierarchically using the 'parent_id' field"
            ]
        },
        "projects": {
            "business_purpose": "The 'projects' table represents a collection of projects within an organization or system. Each project can have various attributes such as name, description, visibility, hierarchy, and status, which are essential for managing and organizing projects effectively.",
            "key_fields": [
                "id",
                "name",
                "public",
                "parent_id",
                "identifier",
                "active",
                "templated",
                "status_code"
            ],
            "potential_relationships": [
                "Hierarchical relationship with itself through 'parent_id' to represent sub-projects or project dependencies.",
                "Potential relationship with a 'status' table to provide detailed status information based on 'status_code'.",
                "Possible relationship with a 'templates' table if 'templated' projects are based on predefined templates."
            ],
            "business_operations": [
                "Creating new projects with specific attributes such as name, description, and visibility.",
                "Updating project details including status, description, and hierarchy.",
                "Managing project visibility and activity status for public or internal access.",
                "Organizing projects into hierarchical structures using 'parent_id' for better management and reporting."
            ]
        },
        "projects_types": {
            "business_purpose": "The 'projects_types' table represents a many-to-many relationship between projects and types. It is used to associate multiple types with a single project and vice versa, allowing for flexible categorization or classification of projects based on predefined types.",
            "key_fields": [
                "project_id",
                "type_id"
            ],
            "potential_relationships": [
                "Many-to-many relationship between 'projects' and 'types' tables",
                "Foreign key relationship with 'projects' table via 'project_id'",
                "Foreign key relationship with 'types' table via 'type_id'"
            ],
            "business_operations": [
                "Assigning types to projects for categorization or classification",
                "Querying projects by type to generate reports or analytics",
                "Managing project types to ensure accurate classification",
                "Updating or deleting associations between projects and types as business needs change"
            ]
        },
        "queries": {
            "business_purpose": "The 'queries' table appears to represent a system for managing and storing user-defined queries within a project management or data analysis application. It allows users to create, customize, and save queries that can be used to filter, sort, and display data according to specific criteria.",
            "key_fields": [
                "id",
                "project_id",
                "name",
                "user_id",
                "public",
                "filters",
                "column_names",
                "sort_criteria",
                "group_by",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "The 'project_id' field suggests a relationship with a 'projects' table, where each query is associated with a specific project.",
                "The 'user_id' field indicates a potential relationship with a 'users' table, linking queries to the users who created them."
            ],
            "business_operations": [
                "Creating and saving new queries for data analysis or reporting purposes.",
                "Retrieving and executing saved queries to filter and display data according to user-defined criteria.",
                "Managing query visibility and access, such as setting queries to be public or private.",
                "Updating existing queries to refine filters, sorting, or display options.",
                "Tracking changes to queries over time with 'created_at' and 'updated_at' timestamps."
            ]
        },
        "relations": {
            "business_purpose": "The 'relations' table appears to represent connections or associations between entities identified by 'from_id' and 'to_id'. This could be used in scenarios such as mapping dependencies, relationships between tasks, or connections between nodes in a network.",
            "key_fields": [
                "id",
                "from_id",
                "to_id",
                "relation_type"
            ],
            "potential_relationships": [
                "The 'relations' table might relate to other tables that store entities or nodes, where 'from_id' and 'to_id' are foreign keys referencing the primary keys of those tables.",
                "It could be part of a larger schema involving tasks, events, or nodes, where 'relation_type' specifies the nature of the relationship (e.g., dependency, hierarchy, sequence)."
            ],
            "business_operations": [
                "Tracking dependencies or connections between entities, such as tasks in a project management system.",
                "Analyzing network paths or relationships in a graph database context.",
                "Managing workflows or processes where the sequence or type of relationship between steps is important."
            ]
        },
        "role_permissions": {
            "business_purpose": "The 'role_permissions' table is designed to manage and store the permissions associated with different roles within a system. It is likely part of an access control mechanism where roles are assigned specific permissions to perform certain actions or access certain resources.",
            "key_fields": [
                "id",
                "permission",
                "role_id",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "This table might have a relationship with a 'roles' table, where 'role_id' would be a foreign key referencing the primary key of the 'roles' table.",
                "It could also relate to a 'permissions' table if permissions are managed separately, where 'permission' might be a foreign key or a reference to a permission identifier."
            ],
            "business_operations": [
                "Assigning permissions to roles, which involves inserting new records into this table.",
                "Updating permissions for existing roles, which would involve updating the 'permission' field for specific 'role_id' entries.",
                "Auditing role permissions over time, utilizing the 'created_at' and 'updated_at' timestamps to track changes.",
                "Removing permissions from roles, which would involve deleting records from this table."
            ]
        },
        "roles": {
            "business_purpose": "The 'roles' table represents a system for managing different roles within an organization or application. Each role likely defines a set of permissions or responsibilities that can be assigned to users or entities within the system.",
            "key_fields": [
                "id",
                "name",
                "builtin"
            ],
            "potential_relationships": [
                "This table might have a relationship with a 'users' table where each user is assigned one or more roles.",
                "It could be related to a 'permissions' table where each role is associated with specific permissions.",
                "There might be a relationship with a 'departments' or 'teams' table if roles are specific to certain organizational units."
            ],
            "business_operations": [
                "Creating new roles to define different access levels or responsibilities within the system.",
                "Updating existing roles to change their permissions or attributes.",
                "Deleting roles that are no longer needed or merging roles as organizational needs change.",
                "Assigning roles to users or entities to control access and permissions within the system."
            ]
        },
        "schema_migrations": {
            "business_purpose": "The 'schema_migrations' table is used to track the versions of database schema migrations that have been applied. It helps in managing and recording changes to the database structure over time, ensuring that the database is up-to-date with the latest schema changes.",
            "key_fields": [
                "version"
            ],
            "potential_relationships": [
                "This table might relate to tables that require schema changes, but it does not directly reference other tables. It serves as a standalone record of migration versions applied to the database."
            ],
            "business_operations": [
                "Database migration processes, version control of database schema, rollback operations, and ensuring consistency across different environments by tracking which migrations have been applied."
            ]
        },
        "sessions": {
            "business_purpose": "The 'sessions' table likely represents user sessions in a web application or system. It is used to track and manage user interactions over a period of time, storing session-specific data and associating it with a user when applicable.",
            "key_fields": [
                "id",
                "session_id",
                "updated_at",
                "user_id"
            ],
            "potential_relationships": [
                "This table might have a relationship with a 'users' table, where 'user_id' serves as a foreign key linking a session to a specific user.",
                "It could also relate to a 'session_logs' table, where each session's activities are logged and referenced by 'session_id'."
            ],
            "business_operations": [
                "Creating a new session when a user logs in or starts a new session.",
                "Updating session data as the user interacts with the application.",
                "Retrieving session data to maintain user state across requests.",
                "Associating sessions with users for tracking user activity and analytics."
            ]
        },
        "settings": {
            "business_purpose": "The 'settings' table is designed to store configuration settings or preferences for an application or system. Each setting is identified by a unique name and can have a corresponding value, which may be updated over time.",
            "key_fields": [
                "id",
                "name",
                "value",
                "updated_at"
            ],
            "potential_relationships": [
                "This table might have relationships with tables that require configuration settings, such as application modules, user preferences, or system components. It could be referenced by tables that need to apply specific settings or configurations dynamically."
            ],
            "business_operations": [
                "Retrieving configuration settings for application initialization or runtime adjustments",
                "Updating settings to change application behavior or preferences",
                "Auditing changes to settings by tracking the 'updated_at' timestamp",
                "Managing system-wide or module-specific configurations"
            ]
        },
        "statuses": {
            "business_purpose": "The 'statuses' table likely represents a set of status definitions for tracking the progress or state of items within a business process, such as tasks, projects, or tickets. Each status can have attributes that define its behavior and appearance, such as whether it is closed, default, or readonly, and its position in a sequence.",
            "key_fields": [
                "id",
                "name",
                "is_closed",
                "is_default",
                "position",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "This table might have relationships with tables representing items that require status tracking, such as tasks, projects, or tickets. It could also relate to a 'colors' table through the 'color_id' field to define visual attributes of statuses."
            ],
            "business_operations": [
                "Operations involving this table would include creating, updating, and deleting status definitions, assigning statuses to items, determining the default status for new items, and managing the sequence or order of statuses."
            ]
        },
        "tokens": {
            "business_purpose": "The 'tokens' table is likely used to manage authentication or authorization tokens for users. It stores information about tokens that are associated with user accounts, including their type, value, creation time, expiration, and any additional data in JSON format.",
            "key_fields": [
                "id",
                "user_id",
                "type",
                "value",
                "created_at",
                "expires_on"
            ],
            "potential_relationships": [
                "The 'tokens' table has a foreign key relationship with a 'users' table, indicating that each token is associated with a specific user. This suggests a one-to-many relationship where a user can have multiple tokens."
            ],
            "business_operations": [
                "User authentication processes, such as login sessions or API access, where tokens are issued and validated. Token management operations, including creation, validation, expiration checks, and revocation. Security audits and monitoring of token usage and expiration."
            ]
        },
        "types": {
            "business_purpose": "The 'types' table likely represents a categorization or classification system within a business process, possibly related to project management or product development. It defines different types or categories that can be used to organize or classify items, tasks, or milestones within a roadmap or project plan.",
            "key_fields": [
                "id",
                "name",
                "is_in_roadmap",
                "is_milestone",
                "is_default",
                "color_id",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "The 'color_id' field suggests a relationship with a 'colors' table, where each type can be associated with a specific color for visual representation.",
                "The 'types' table might be related to a 'projects' or 'tasks' table, where each project or task can be assigned a type from this table.",
                "The 'is_milestone' and 'is_in_roadmap' fields suggest a potential relationship with a 'roadmaps' or 'milestones' table, where these types are used to define key points or phases."
            ],
            "business_operations": [
                "Defining and managing different types or categories for projects or tasks.",
                "Assigning colors to types for visual differentiation in reports or dashboards.",
                "Configuring default types for new projects or tasks.",
                "Tracking and updating the status of types within a roadmap or project lifecycle.",
                "Using types to filter or sort items in a project management tool."
            ]
        },
        "user_passwords": {
            "business_purpose": "The 'user_passwords' table is designed to store and manage password-related information for users. It likely serves as a part of a user authentication system, where it securely stores hashed passwords and related metadata for user accounts.",
            "key_fields": [
                "id",
                "user_id",
                "hashed_password",
                "type"
            ],
            "potential_relationships": [
                "This table might have a one-to-one or many-to-one relationship with a 'users' table, where 'user_id' would serve as a foreign key linking to a primary key in the 'users' table. This relationship would associate each password entry with a specific user account."
            ],
            "business_operations": [
                "User registration: When a new user registers, a new entry would be created in this table with their hashed password.",
                "User authentication: During login, the system would verify the user's credentials by comparing the provided password with the stored hashed password.",
                "Password updates: When a user changes their password, the corresponding entry in this table would be updated with the new hashed password.",
                "Security audits: The 'created_at' and 'updated_at' timestamps can be used to track when passwords were set or changed, aiding in security audits and compliance checks."
            ]
        },
        "user_preferences": {
            "business_purpose": "The 'user_preferences' table is designed to store customizable settings or preferences for individual users. It allows the application to personalize user experiences by saving specific configurations or choices made by users.",
            "key_fields": [
                "id",
                "user_id",
                "settings"
            ],
            "potential_relationships": [
                "One-to-One: This table might have a one-to-one relationship with a 'users' table, where each user has a unique set of preferences.",
                "One-to-Many: It could also relate to a 'user_sessions' table, where each session might need to reference user preferences for configuration purposes."
            ],
            "business_operations": [
                "Retrieving user preferences to customize user interfaces or experiences.",
                "Updating user preferences when a user changes their settings.",
                "Inserting new user preferences when a new user is created or when a user first sets their preferences.",
                "Deleting user preferences if a user account is removed or if preferences need to be reset."
            ]
        },
        "users": {
            "business_purpose": "The 'users' table represents a system for managing user accounts and their authentication details. It is designed to store information about users, including their personal details, authentication status, and login history. This table is likely part of a larger system that requires user authentication and management, such as a web application or an enterprise system.",
            "key_fields": [
                "id",
                "login",
                "firstname",
                "lastname",
                "mail",
                "admin",
                "status",
                "last_login_on",
                "created_at",
                "updated_at",
                "first_login",
                "failed_login_count"
            ],
            "potential_relationships": [
                "This table might have a relationship with an 'authentication_sources' table through the 'ldap_auth_source_id' field, which could reference different authentication methods or sources.",
                "It could be related to a 'roles' or 'permissions' table to manage user access levels and permissions based on the 'admin' and 'status' fields.",
                "The 'webauthn_id' field suggests a potential relationship with a table managing WebAuthn credentials for secure authentication."
            ],
            "business_operations": [
                "User registration and account creation, where new entries are added to the table.",
                "User authentication and login processes, which would involve checking the 'login', 'mail', and 'password' (not explicitly listed but implied) fields.",
                "User profile management, allowing users to update their 'firstname', 'lastname', 'mail', and other personal details.",
                "Administrative operations, such as managing user statuses, roles, and permissions, especially for users with 'admin' privileges.",
                "Security operations, including tracking failed login attempts and enforcing password changes, as indicated by the 'failed_login_count' and 'force_password_change' fields."
            ]
        },
        "version_settings": {
            "business_purpose": "The 'version_settings' table likely represents configuration or settings related to different versions of a project within a system. It is used to manage how different versions of a project are displayed or configured.",
            "key_fields": [
                "id",
                "project_id",
                "version_id",
                "display",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "The 'project_id' field suggests a potential relationship with a 'projects' table, where each entry in 'version_settings' is associated with a specific project.",
                "The 'version_id' field indicates a possible relationship with a 'versions' table, where each setting is linked to a specific version of a project."
            ],
            "business_operations": [
                "Creating new version settings for a project when a new version is released.",
                "Updating display settings for existing versions of a project.",
                "Retrieving version settings to determine how a specific version of a project should be presented or configured.",
                "Auditing changes to version settings over time using the 'created_at' and 'updated_at' timestamps."
            ]
        },
        "versions": {
            "business_purpose": "The 'versions' table likely represents different versions or releases of a project within a business context. It is used to track the development and lifecycle of project versions, including their names, descriptions, and relevant dates.",
            "key_fields": [
                "id",
                "project_id",
                "name",
                "effective_date",
                "status",
                "sharing"
            ],
            "potential_relationships": [
                "The 'project_id' field suggests a relationship with a 'projects' table, where each version is associated with a specific project.",
                "The 'wiki_page_title' field might indicate a relationship with a 'wiki_pages' table, where detailed documentation or notes about the version are stored."
            ],
            "business_operations": [
                "Creating new versions for a project, including setting names, descriptions, and effective dates.",
                "Updating version details such as status, sharing settings, and documentation links.",
                "Tracking the lifecycle of project versions, including start and effective dates.",
                "Managing version visibility and access through the 'sharing' field."
            ]
        },
        "views": {
            "business_purpose": "The 'views' table appears to represent a system for managing and storing metadata about database views. It includes information about the view's definition, its associated query, and various properties related to its updatability and insertability. This table is likely part of a larger system that tracks and manages database views, possibly for a data analytics or reporting platform.",
            "key_fields": [
                "id",
                "query_id",
                "options",
                "view_definition",
                "type",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "The 'views' table has a foreign key relationship with the 'queries' table, indicating that each view is associated with a specific query.",
                "It might also relate to tables that manage schemas or catalogs, given the presence of 'table_catalog' and 'table_schema' fields, although these relationships are not explicitly defined in the provided schema."
            ],
            "business_operations": [
                "Creating new views based on specific queries and storing their metadata.",
                "Updating existing views and tracking changes over time with 'created_at' and 'updated_at' timestamps.",
                "Retrieving view definitions and options for execution or analysis.",
                "Managing view properties such as updatability and insertability, which could be important for systems that allow dynamic data manipulation."
            ]
        },
        "watchers": {
            "business_purpose": "The 'watchers' table is designed to track entities that users are monitoring or following. It represents a system where users can 'watch' various types of items, such as projects, tasks, or other entities, to receive updates or notifications about changes or activities related to those items.",
            "key_fields": [
                "id",
                "watchable_type",
                "watchable_id",
                "user_id"
            ],
            "potential_relationships": [
                "The 'watchable_type' and 'watchable_id' fields suggest a polymorphic relationship, where this table can be linked to multiple other tables representing different types of entities that can be watched.",
                "The 'user_id' field indicates a potential relationship with a table that stores user information, allowing identification of which user is watching a particular entity."
            ],
            "business_operations": [
                "Tracking which users are watching specific entities for notification purposes.",
                "Managing user subscriptions to updates or changes in various entities.",
                "Generating reports on user engagement with different types of watchable entities."
            ]
        },
        "wiki_page_journals": {
            "business_purpose": "The 'wiki_page_journals' table likely represents a log or journal of changes or entries related to wiki pages. It may be used to track modifications, comments, or notes made by authors on specific wiki pages.",
            "key_fields": [
                "id",
                "author_id",
                "text"
            ],
            "potential_relationships": [
                "The 'author_id' field suggests a potential relationship with a table that stores author information, such as an 'authors' or 'users' table.",
                "The 'id' field could be used to relate entries in this table to specific wiki pages, possibly through a separate table that manages wiki page details."
            ],
            "business_operations": [
                "Recording changes or updates made by authors to wiki pages.",
                "Tracking the history of modifications or annotations on wiki pages.",
                "Retrieving journal entries for review or audit purposes."
            ]
        },
        "wiki_pages": {
            "business_purpose": "The 'wiki_pages' table represents a collection of pages within a wiki system. Each entry in the table corresponds to a specific page, capturing details such as its title, content, creation and update timestamps, and metadata like protection status and versioning. This table is likely part of a content management system designed to facilitate the creation, editing, and organization of wiki-style documentation or knowledge bases.",
            "key_fields": [
                "id",
                "wiki_id",
                "title",
                "created_at",
                "protected",
                "slug",
                "updated_at",
                "author_id",
                "lock_version"
            ],
            "potential_relationships": [
                "The 'author_id' field indicates a relationship with a 'users' table, where each page is associated with a user who authored or last edited the page.",
                "The 'parent_id' field suggests a hierarchical relationship within the 'wiki_pages' table itself, allowing for the organization of pages into parent-child structures, such as subpages or sections within a larger document.",
                "The 'wiki_id' field could imply a relationship with another table that represents different wikis or collections of pages, allowing for the organization of pages into distinct groups or projects."
            ],
            "business_operations": [
                "Creating new wiki pages, which involves inserting new records with details like title, author, and initial content.",
                "Editing existing wiki pages, which would update fields such as 'text', 'updated_at', and potentially 'lock_version' to manage concurrent edits.",
                "Organizing pages into hierarchies using the 'parent_id' field to create nested structures or categories.",
                "Managing access and edit permissions through the 'protected' field, which could restrict who can modify certain pages.",
                "Tracking changes and maintaining version control using the 'lock_version' field to handle concurrent edits and ensure data integrity."
            ]
        },
        "wikis": {
            "business_purpose": "The 'wikis' table represents a collection of wiki pages or documents associated with different projects. Each entry in the table corresponds to a distinct wiki, which is likely used for documentation, collaboration, or knowledge sharing within a project.",
            "key_fields": [
                "id",
                "project_id",
                "start_page",
                "status",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "The 'project_id' field suggests a relationship with a 'projects' table, where each wiki is linked to a specific project.",
                "The 'start_page' field might relate to a 'pages' table if individual pages are stored separately, indicating the entry point or main page of the wiki."
            ],
            "business_operations": [
                "Creating a new wiki for a project, which involves inserting a new record with details like the start page and initial status.",
                "Updating the wiki's status or start page, which involves modifying existing records.",
                "Tracking the creation and modification times of wikis for auditing or version control purposes.",
                "Associating wikis with projects, which involves ensuring the 'project_id' is correctly linked to an existing project."
            ]
        },
        "work_package_hierarchies": {
            "business_purpose": "The 'work_package_hierarchies' table is designed to represent hierarchical relationships between work packages, where each work package can have multiple levels of sub-packages. This structure is typically used in project management to organize tasks or deliverables in a parent-child relationship, allowing for the representation of complex project structures.",
            "key_fields": [
                "ancestor_id",
                "descendant_id",
                "generations"
            ],
            "potential_relationships": [
                "Self-referential relationship: The table inherently represents a self-referential hierarchy where 'ancestor_id' and 'descendant_id' are both likely to reference the same entity type, such as a work package.",
                "Hierarchical relationship: The 'generations' field indicates the level of separation between the ancestor and descendant, which can be used to determine the depth of the hierarchy."
            ],
            "business_operations": [
                "Project planning: Organizing and structuring work packages into a hierarchy for better management and tracking.",
                "Dependency management: Identifying dependencies between different work packages based on their hierarchical relationships.",
                "Reporting: Generating reports on project structure, progress, and dependencies by traversing the hierarchy.",
                "Resource allocation: Allocating resources based on the hierarchy to ensure that all levels of the project are adequately supported."
            ]
        },
        "work_package_journals": {
            "business_purpose": "The 'work_package_journals' table appears to represent a record of changes or updates to work packages within a project management system. It tracks various attributes related to work packages, such as type, project association, status, priority, and other relevant details that are essential for managing and monitoring the progress of work packages over time.",
            "key_fields": [
                "id",
                "type_id",
                "project_id",
                "subject",
                "status_id",
                "priority_id",
                "author_id",
                "done_ratio",
                "ignore_non_working_days"
            ],
            "potential_relationships": [
                "This table might have a relationship with a 'projects' table through the 'project_id' field, indicating which project the work package belongs to.",
                "It could relate to a 'work_package_types' table via the 'type_id' field, specifying the type of work package.",
                "The 'status_id' field suggests a potential relationship with a 'statuses' table to define the current status of the work package.",
                "The 'priority_id' field indicates a possible link to a 'priorities' table to determine the priority level of the work package.",
                "The 'author_id' field might relate to a 'users' or 'authors' table, identifying who created or last modified the work package journal entry."
            ],
            "business_operations": [
                "Tracking changes and updates to work packages over time.",
                "Monitoring the progress and status of work packages within projects.",
                "Assigning and managing work packages to different team members or roles.",
                "Estimating and tracking time and resources required for work packages.",
                "Prioritizing and scheduling work packages based on project needs and constraints."
            ]
        },
        "work_packages": {
            "business_purpose": "The 'work_packages' table represents tasks or units of work within a project management system. It is designed to track and manage various aspects of work items, such as their type, status, priority, and assignment, within the context of a project.",
            "key_fields": [
                "id",
                "type_id",
                "project_id",
                "subject",
                "status_id",
                "author_id",
                "assigned_to_id",
                "due_date",
                "estimated_hours",
                "done_ratio"
            ],
            "potential_relationships": [
                "Belongs to a project (project_id references projects table)",
                "Has a specific type (type_id references types table)",
                "Has a status (status_id references statuses table)",
                "May have a hierarchical relationship with other work packages (parent_id references work_packages table itself)"
            ],
            "business_operations": [
                "Creating and assigning work packages to projects",
                "Updating the status and progress of work packages",
                "Tracking time and effort estimates for work packages",
                "Managing dependencies and hierarchies between work packages",
                "Reporting on work package completion and performance metrics"
            ]
        },
        "workflows": {
            "business_purpose": "The 'workflows' table represents a system for managing transitions between different statuses of a business process or entity. It is likely used to define and control the flow of tasks or items through various stages, ensuring that only authorized roles can make specific status changes.",
            "key_fields": [
                "id",
                "type_id",
                "old_status_id",
                "new_status_id",
                "role_id",
                "assignee",
                "author"
            ],
            "potential_relationships": [
                "The 'type_id' field suggests a relationship with a 'types' table, indicating different categories or kinds of workflows.",
                "The 'old_status_id' and 'new_status_id' fields indicate relationships with a 'statuses' table, representing the transition from one status to another.",
                "The 'role_id' field suggests a relationship with a 'roles' table, defining which roles are permitted to execute the workflow transition."
            ],
            "business_operations": [
                "Defining and managing workflow transitions for business processes.",
                "Controlling access to status changes based on user roles.",
                "Tracking the history of status changes for auditing purposes.",
                "Automating task assignments based on workflow rules, potentially involving the 'assignee' and 'author' fields to determine if the current user is responsible for the task."
            ]
        }
    },
    "relationships": [
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "author_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "attachment_journals.author_id = users.id",
            "confidence": "high",
            "reasoning": "The 'author_id' field in the 'attachment_journals' table likely refers to the user who created or uploaded the attachment. This aligns with the 'id' field in the 'users' table, which uniquely identifies each user. This relationship is a common pattern where a foreign key in one table references the primary key of another table to establish a link between records.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN users t2 ON t1.author_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachments",
            "from_column": "author_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "attachments.author_id = users.id",
            "confidence": "high",
            "reasoning": "The 'author_id' field in the 'attachments' table likely refers to the user who created or uploaded the attachment. This aligns with the 'id' field in the 'users' table, which uniquely identifies each user. This is a common pattern where a foreign key relationship exists between a record and its creator or owner.",
            "test_sql": "SELECT COUNT(*) FROM attachments t1 JOIN users t2 ON t1.author_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "meetings",
            "to_column": "project_id",
            "condition": "categories.project_id = meetings.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that categories and meetings can be associated with the same project. This relationship is logical within a project management context, where both categories and meetings are organized around projects.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN meetings t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "news",
            "to_column": "project_id",
            "condition": "categories.project_id = news.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that categories and news items can be associated with the same project. This relationship is common in project management systems where different entities are linked to projects.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN news t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "projects",
            "to_column": "id",
            "condition": "categories.project_id = projects.id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'categories' table is likely intended to reference the 'id' field in the 'projects' table, as each category is associated with a specific project. This is a common pattern in database design where a foreign key relationship is used to link related records across tables.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN projects t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "versions",
            "to_column": "project_id",
            "condition": "categories.project_id = versions.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that categories and versions are both associated with specific projects. This is a common pattern in project management systems where different entities are linked to projects via a project ID.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN versions t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "wikis",
            "to_column": "project_id",
            "condition": "categories.project_id = wikis.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that categories and wikis are both associated with projects. This is a common pattern in project management systems where different entities are linked to a project through a project ID. The data types are compatible, and the business logic supports the idea that categories and wikis are both components of a project.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN wikis t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "colors",
            "from_column": "id",
            "to_table": "enumerations",
            "to_column": "color_id",
            "condition": "colors.id = enumerations.color_id",
            "confidence": "high",
            "reasoning": "The 'color_id' field in the 'enumerations' table suggests a direct reference to the 'id' field in the 'colors' table. This implies that each enumeration can be associated with a specific color, which aligns with common database design patterns where a foreign key relationship is established between tables to maintain referential integrity.",
            "test_sql": "SELECT COUNT(*) FROM colors t1 JOIN enumerations t2 ON t1.id = t2.color_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "work_package_journals",
            "to_column": "project_id",
            "condition": "categories.project_id = work_package_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, indicating that categories and work package journals are associated with specific projects. This relationship is highly likely as it aligns with common database design patterns where entities are linked to projects.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN work_package_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "types",
            "from_column": "color_id",
            "to_table": "colors",
            "to_column": "id",
            "condition": "types.color_id = colors.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "colors",
            "from_column": "id",
            "to_table": "statuses",
            "to_column": "color_id",
            "condition": "colors.id = statuses.color_id",
            "confidence": "high",
            "reasoning": "The 'statuses' table contains a 'color_id' field, which suggests a potential foreign key relationship to the 'colors' table's 'id' field. This relationship allows each status to be associated with a specific color, which can be used to visually distinguish statuses in a user interface.",
            "test_sql": "SELECT COUNT(*) FROM colors t1 JOIN statuses t2 ON t1.id = t2.color_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 14,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "projects",
            "to_column": "id",
            "condition": "enabled_modules.project_id = projects.id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'enabled_modules' table suggests a direct relationship with the 'id' field in the 'projects' table. This is a common pattern where a module is associated with a specific project, allowing for the customization of features per project.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN projects t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 13,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "versions",
            "to_column": "project_id",
            "condition": "enabled_modules.project_id = versions.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, which suggests that they are both related to projects. The 'enabled_modules' table likely configures modules for specific projects, while the 'versions' table tracks different versions of those projects. This common field indicates a logical relationship where modules are enabled for specific versions of a project.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN versions t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 24,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "wikis",
            "to_column": "project_id",
            "condition": "enabled_modules.project_id = wikis.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, which suggests that they are related to the same project entity. The 'enabled_modules' table likely configures modules for a project, while the 'wikis' table provides documentation or collaboration tools for the same project. This relationship is common in database design where different aspects of a project are linked through a shared project identifier.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN wikis t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 13,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "work_packages",
            "to_column": "project_id",
            "condition": "enabled_modules.project_id = work_packages.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that modules are enabled for specific projects and work packages are tasks within those projects. This relationship aligns with common database design patterns where entities are associated with projects.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN work_packages t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 229,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grid_widgets",
            "from_column": "grid_id",
            "to_table": "grids",
            "to_column": "id",
            "condition": "grid_widgets.grid_id = grids.id",
            "confidence": "high",
            "reasoning": "The 'grid_id' field in the 'grid_widgets' table suggests a direct relationship with the 'id' field in the 'grids' table. This is a common pattern where a child table (grid_widgets) references a parent table (grids) to associate widgets with a specific grid layout. The data types are compatible, and the naming convention supports this relationship.",
            "test_sql": "SELECT COUNT(*) FROM grid_widgets t1 JOIN grids t2 ON t1.grid_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 32,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "project_id",
            "to_table": "projects",
            "to_column": "id",
            "condition": "grids.project_id = projects.id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'grids' table suggests a direct association with the 'projects' table, where each grid can be part of a specific project. This is a common pattern where entities are linked to projects they belong to, and the data types are compatible (both are bigint).",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN projects t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "project_id",
            "to_table": "wikis",
            "to_column": "project_id",
            "condition": "grids.project_id = wikis.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that grids and wikis are associated with projects. This common field likely serves as a foreign key linking grids and wikis to the same project, indicating that a grid configuration might be used within the context of a project's wiki documentation.",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN wikis t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "journals",
            "from_column": "user_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "journals.user_id = users.id",
            "confidence": "high",
            "reasoning": "The 'journals' table includes a 'user_id' field, which likely references the 'id' field in the 'users' table. This relationship is common in systems where actions or changes are logged with reference to the user who performed them. The data types are compatible, and the business logic supports this relationship as it allows tracking of user actions.",
            "test_sql": "SELECT COUNT(*) FROM journals t1 JOIN users t2 ON t1.user_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 45,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "meeting_agenda_items",
            "from_column": "meeting_id",
            "to_table": "meetings",
            "to_column": "id",
            "condition": "meeting_agenda_items.meeting_id = meetings.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "meeting_agenda_items",
            "from_column": "meeting_id",
            "to_table": "meeting_participants",
            "to_column": "meeting_id",
            "condition": "meeting_agenda_items.meeting_id = meeting_participants.meeting_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'meeting_id' field, which suggests that they are related through the meeting they reference. This is a common pattern where agenda items and participants are linked to the same meeting, allowing for the organization of meeting details and attendance.",
            "test_sql": "SELECT COUNT(*) FROM meeting_agenda_items t1 JOIN meeting_participants t2 ON t1.meeting_id = t2.meeting_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "meeting_agenda_items",
            "from_column": "author_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "meeting_agenda_items.author_id = users.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "meeting_agenda_items",
            "from_column": "work_package_id",
            "to_table": "work_packages",
            "to_column": "id",
            "condition": "meeting_agenda_items.work_package_id = work_packages.id",
            "confidence": "high",
            "reasoning": "The 'work_package_id' in the 'meeting_agenda_items' table likely references the 'id' in the 'work_packages' table. This relationship is inferred based on the naming convention and the business purpose of linking agenda items to specific work packages for project management purposes.",
            "test_sql": "SELECT COUNT(*) FROM meeting_agenda_items t1 JOIN work_packages t2 ON t1.work_package_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "id",
            "to_table": "meeting_participants",
            "to_column": "meeting_id",
            "condition": "meeting_journals.id = meeting_participants.meeting_id",
            "confidence": "high",
            "reasoning": "The 'meeting_id' field in the 'meeting_participants' table is likely intended to reference the 'id' field in the 'meeting_journals' table. This relationship makes sense as it connects participants to the specific meetings they are associated with, which is a common pattern in database design where a participant or attendee table references a meeting or event table.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN meeting_participants t2 ON t1.id = t2.meeting_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "project_id",
            "to_table": "news",
            "to_column": "project_id",
            "condition": "meeting_journals.project_id = news.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that meetings and news articles can be associated with specific projects. This relationship is common in database design where different entities are linked to projects.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN news t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "project_id",
            "to_table": "projects",
            "to_column": "id",
            "condition": "meeting_journals.project_id = projects.id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'meeting_journals' table is likely intended to reference the 'id' field in the 'projects' table. This relationship makes sense because meetings are often associated with specific projects, and linking them allows for tracking meetings related to each project.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN projects t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "project_id",
            "to_table": "project_journals",
            "to_column": "id",
            "condition": "meeting_journals.project_id = project_journals.id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'meeting_journals' table suggests a direct relationship with the 'id' field in the 'project_journals' table. This is a common pattern where meetings are associated with specific projects, and the 'project_id' serves as a foreign key linking to the primary key 'id' of the 'project_journals'. This relationship aligns with the business purpose of tracking meetings related to specific projects.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN project_journals t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "author_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "meeting_journals.author_id = users.id",
            "confidence": "high",
            "reasoning": "The 'author_id' field in the 'meeting_journals' table likely corresponds to the 'id' field in the 'users' table, indicating that a user is responsible for creating or managing a meeting journal entry. This is a common pattern where user IDs are used to associate records with specific users.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN users t2 ON t1.author_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "project_id",
            "to_table": "wikis",
            "to_column": "project_id",
            "condition": "meeting_journals.project_id = wikis.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that meetings and wikis are associated with specific projects. This relationship is logical as meetings could be documented or referenced in wikis related to the same project.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN wikis t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_participants",
            "from_column": "meeting_id",
            "to_table": "meetings",
            "to_column": "id",
            "condition": "meeting_participants.meeting_id = meetings.id",
            "confidence": "high",
            "reasoning": "The 'meeting_id' field in the 'meeting_participants' table is likely intended to reference the 'id' field in the 'meetings' table. This relationship makes sense because it connects participants to the specific meetings they are involved in, which is a common pattern in database design where a participant or attendee table references a meeting or event table.",
            "test_sql": "SELECT COUNT(*) FROM meeting_participants t1 JOIN meetings t2 ON t1.meeting_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "project_id",
            "to_table": "work_packages",
            "to_column": "project_id",
            "condition": "meeting_journals.project_id = work_packages.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that meetings and work packages are associated with specific projects. This relationship is common in project management systems where meetings are often linked to the projects they pertain to, and work packages are tasks within those projects.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN work_packages t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 13,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_participants",
            "from_column": "user_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "meeting_participants.user_id = users.id",
            "confidence": "high",
            "reasoning": "The 'user_id' field in the 'meeting_participants' table likely corresponds to the 'id' field in the 'users' table, as it is common for participant records to reference user accounts. This relationship allows for the identification of which user is participating in a meeting, aligning with typical database design patterns where participant records are linked to user profiles.",
            "test_sql": "SELECT COUNT(*) FROM meeting_participants t1 JOIN users t2 ON t1.user_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "project_id",
            "to_table": "news",
            "to_column": "project_id",
            "condition": "meetings.project_id = news.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that meetings and news articles can be associated with the same projects. This relationship is logical as meetings and news updates are often linked to specific projects within an organization.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN news t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "project_id",
            "to_table": "projects",
            "to_column": "id",
            "condition": "meetings.project_id = projects.id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'meetings' table suggests a direct relationship with the 'id' field in the 'projects' table. This is a common pattern where meetings are associated with specific projects, allowing for organization and management of meetings within the context of a project.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN projects t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "author_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "meetings.author_id = users.id",
            "confidence": "high",
            "reasoning": "The 'author_id' field in the 'meetings' table likely refers to the user who organized or is responsible for the meeting. This aligns with the 'id' field in the 'users' table, which uniquely identifies each user. The data types are compatible, and this is a common pattern where meetings are associated with users who create or manage them.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN users t2 ON t1.author_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "project_id",
            "to_table": "wikis",
            "to_column": "project_id",
            "condition": "meetings.project_id = wikis.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that meetings and wikis are associated with specific projects. This is a common pattern where different entities are linked to a project, allowing for project-specific documentation and meetings.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN wikis t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "member_roles",
            "from_column": "member_id",
            "to_table": "members",
            "to_column": "id",
            "condition": "member_roles.member_id = members.id",
            "confidence": "high",
            "reasoning": "The 'member_id' field in the 'member_roles' table likely corresponds to the 'id' field in the 'members' table, as both fields are of type 'bigint' and the 'member_roles' table is designed to manage roles assigned to members. This suggests a foreign key relationship where each role assignment is linked to a specific member.",
            "test_sql": "SELECT COUNT(*) FROM member_roles t1 JOIN members t2 ON t1.member_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "project_id",
            "to_table": "work_packages",
            "to_column": "project_id",
            "condition": "meetings.project_id = work_packages.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that meetings can be associated with specific projects, and work packages are tasks within those projects. This relationship aligns with common project management practices where meetings are often linked to project tasks or milestones.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN work_packages t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 13,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "member_roles",
            "from_column": "role_id",
            "to_table": "role_permissions",
            "to_column": "role_id",
            "condition": "member_roles.role_id = role_permissions.role_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'role_id' field, which suggests a direct relationship between the roles assigned to members and the permissions associated with those roles. This is a common pattern in access control systems where roles are linked to permissions.",
            "test_sql": "SELECT COUNT(*) FROM member_roles t1 JOIN role_permissions t2 ON t1.role_id = t2.role_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 260,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "member_roles",
            "from_column": "role_id",
            "to_table": "roles",
            "to_column": "id",
            "condition": "member_roles.role_id = roles.id",
            "confidence": "high",
            "reasoning": "The 'role_id' in the 'member_roles' table is likely intended to reference the 'id' in the 'roles' table, as it is common for a role assignment table to link to a roles definition table. This relationship allows for the assignment of specific roles to members, which aligns with the business purpose of both tables.",
            "test_sql": "SELECT COUNT(*) FROM member_roles t1 JOIN roles t2 ON t1.role_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "member_roles",
            "from_column": "member_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "member_roles.member_id = users.id",
            "confidence": "high",
            "reasoning": "The 'member_id' field in the 'member_roles' table likely corresponds to the 'id' field in the 'users' table, as both are of type 'bigint' and the 'member_roles' table is designed to manage roles assigned to members, which are represented as users in the 'users' table.",
            "test_sql": "SELECT COUNT(*) FROM member_roles t1 JOIN users t2 ON t1.member_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "project_id",
            "to_table": "projects",
            "to_column": "id",
            "condition": "members.project_id = projects.id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'members' table likely corresponds to the 'id' field in the 'projects' table, indicating which project a member is associated with. This is a common foreign key relationship where a member is linked to a specific project.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN projects t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "user_id",
            "to_table": "user_preferences",
            "to_column": "user_id",
            "condition": "members.user_id = user_preferences.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which is a strong indicator of a relationship between the two. The 'members' table associates users with projects or entities, while the 'user_preferences' table stores settings for users. It is logical to assume that user preferences are linked to the users who are members of projects or entities.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN user_preferences t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "user_id",
            "to_table": "user_passwords",
            "to_column": "user_id",
            "condition": "members.user_id = user_passwords.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which is a common practice in database design to link user-related data. The 'members' table associates users with projects or entities, while the 'user_passwords' table manages authentication details for users. This suggests a logical connection where each user in the 'members' table can be linked to their authentication details in the 'user_passwords' table.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN user_passwords t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "user_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "members.user_id = users.id",
            "confidence": "high",
            "reasoning": "The 'user_id' field in the 'members' table is likely intended to reference the 'id' field in the 'users' table. This relationship makes sense because the 'members' table is designed to track user participation in projects or entities, and it needs to associate each membership record with a specific user.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN users t2 ON t1.user_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "project_id",
            "to_table": "wikis",
            "to_column": "project_id",
            "condition": "members.project_id = wikis.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that members and wikis are associated with projects. This is a common pattern where entities related to projects are linked via a project identifier.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN wikis t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "project_id",
            "to_table": "work_package_journals",
            "to_column": "project_id",
            "condition": "members.project_id = work_package_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that they are related through the projects they are associated with. The 'members' table tracks user membership in projects, while the 'work_package_journals' table tracks changes to work packages within those projects. This relationship is logical in a project management context where users are associated with projects and work packages are part of those projects.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN work_package_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "project_id",
            "to_table": "projects",
            "to_column": "id",
            "condition": "news.project_id = projects.id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'news' table suggests a direct association with the 'id' field in the 'projects' table. This relationship is logical as each news item is likely related to a specific project, and the 'project_id' serves as a foreign key to the 'projects' table.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN projects t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "author_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "news.author_id = users.id",
            "confidence": "high",
            "reasoning": "The 'author_id' field in the 'news' table likely corresponds to the 'id' field in the 'users' table, as each news article is authored by a user. This relationship is common in systems where users create content, and the data types (bigint) are compatible.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN users t2 ON t1.author_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "project_id",
            "to_table": "wikis",
            "to_column": "project_id",
            "condition": "news.project_id = wikis.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that news articles and wikis are associated with specific projects. This is a common pattern where different types of content are linked to projects, allowing for project-specific documentation and updates.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN wikis t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "project_id",
            "to_table": "work_packages",
            "to_column": "project_id",
            "condition": "news.project_id = work_packages.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that news articles and work packages are associated with projects. This relationship is common in project management systems where updates (news) and tasks (work packages) are linked to specific projects.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN work_packages t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "project_id",
            "to_table": "work_package_journals",
            "to_column": "project_id",
            "condition": "news.project_id = work_package_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that news articles and work package journals can be associated with the same projects. This is a common pattern in project management systems where different entities are linked to projects.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN work_package_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "project_id",
            "to_table": "projects",
            "to_column": "id",
            "condition": "news_journals.project_id = projects.id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'news_journals' table suggests a direct relationship with the 'id' field in the 'projects' table. This is a common foreign key relationship where each journal entry is associated with a specific project, allowing for the organization and categorization of news content by project.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN projects t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "author_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "news_journals.author_id = users.id",
            "confidence": "high",
            "reasoning": "The 'author_id' field in the 'news_journals' table likely references the 'id' field in the 'users' table, as each journal entry is authored by a user. This is a common pattern where content is linked to its creator.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN users t2 ON t1.author_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "project_id",
            "to_table": "wikis",
            "to_column": "project_id",
            "condition": "news_journals.project_id = wikis.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that news journal entries and wikis are associated with specific projects. This is a common pattern where different types of content are linked to projects, allowing for project-specific documentation and news updates.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN wikis t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "notification_settings",
            "from_column": "project_id",
            "to_table": "projects",
            "to_column": "id",
            "condition": "notification_settings.project_id = projects.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "notification_settings",
            "from_column": "user_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "notification_settings.user_id = users.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "notification_settings",
            "from_column": "user_id",
            "to_table": "user_preferences",
            "to_column": "user_id",
            "condition": "notification_settings.user_id = user_preferences.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a logical relationship where notification settings are specific to user preferences. This aligns with common database design patterns where user-specific settings are linked by user identifiers.",
            "test_sql": "SELECT COUNT(*) FROM notification_settings t1 JOIN user_preferences t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "ordered_work_packages",
            "from_column": "query_id",
            "to_table": "queries",
            "to_column": "id",
            "condition": "ordered_work_packages.query_id = queries.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "ordered_work_packages",
            "from_column": "work_package_id",
            "to_table": "work_packages",
            "to_column": "id",
            "condition": "ordered_work_packages.work_package_id = work_packages.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "project_journals",
            "from_column": "id",
            "to_table": "versions",
            "to_column": "project_id",
            "condition": "project_journals.id = versions.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'versions' table suggests a direct relationship with the 'project_journals' table, where each version is associated with a specific project journal entry. The 'id' field in 'project_journals' is a primary key, making it a likely candidate for this relationship.",
            "test_sql": "SELECT COUNT(*) FROM project_journals t1 JOIN versions t2 ON t1.id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "project_journals",
            "from_column": "id",
            "to_table": "wikis",
            "to_column": "project_id",
            "condition": "project_journals.id = wikis.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'wikis' table suggests a direct relationship with the 'project_journals' table, where each wiki is associated with a specific project. The 'id' field in 'project_journals' is a likely candidate for this relationship as it serves as the primary identifier for projects.",
            "test_sql": "SELECT COUNT(*) FROM project_journals t1 JOIN wikis t2 ON t1.id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "project_journals",
            "from_column": "id",
            "to_table": "work_package_journals",
            "to_column": "project_id",
            "condition": "project_journals.id = work_package_journals.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in 'work_package_journals' likely references the 'id' field in 'project_journals', indicating that each work package is associated with a specific project. This is a common pattern in project management systems where work packages are linked to projects.",
            "test_sql": "SELECT COUNT(*) FROM project_journals t1 JOIN work_package_journals t2 ON t1.id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "projects_types",
            "from_column": "project_id",
            "to_table": "projects",
            "to_column": "id",
            "condition": "projects_types.project_id = projects.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "projects",
            "from_column": "id",
            "to_table": "queries",
            "to_column": "project_id",
            "condition": "projects.id = queries.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'queries' table suggests a direct relationship with the 'id' field in the 'projects' table. This is a common pattern where queries are associated with specific projects, allowing users to manage and execute queries within the context of a particular project.",
            "test_sql": "SELECT COUNT(*) FROM projects t1 JOIN queries t2 ON t1.id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "projects",
            "from_column": "id",
            "to_table": "versions",
            "to_column": "project_id",
            "condition": "projects.id = versions.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'versions' table suggests a direct relationship with the 'id' field in the 'projects' table. This is a common foreign key relationship where each version is associated with a specific project.",
            "test_sql": "SELECT COUNT(*) FROM projects t1 JOIN versions t2 ON t1.id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "projects",
            "from_column": "id",
            "to_table": "version_settings",
            "to_column": "project_id",
            "condition": "projects.id = version_settings.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'version_settings' table suggests a direct association with the 'projects' table, where each version setting is linked to a specific project. This is a common pattern where settings or configurations are tied to a parent entity, in this case, a project.",
            "test_sql": "SELECT COUNT(*) FROM projects t1 JOIN version_settings t2 ON t1.id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "work_packages",
            "from_column": "project_id",
            "to_table": "projects",
            "to_column": "id",
            "condition": "work_packages.project_id = projects.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "projects",
            "from_column": "id",
            "to_table": "wikis",
            "to_column": "project_id",
            "condition": "projects.id = wikis.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'wikis' table suggests a direct relationship with the 'id' field in the 'projects' table. This is a common pattern where a foreign key in one table references the primary key of another table, indicating that each wiki is associated with a specific project.",
            "test_sql": "SELECT COUNT(*) FROM projects t1 JOIN wikis t2 ON t1.id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "projects",
            "from_column": "id",
            "to_table": "work_package_journals",
            "to_column": "project_id",
            "condition": "projects.id = work_package_journals.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'work_package_journals' table likely references the 'id' field in the 'projects' table, indicating which project each work package journal entry is associated with. This is a common pattern in project management systems where work packages are linked to specific projects.",
            "test_sql": "SELECT COUNT(*) FROM projects t1 JOIN work_package_journals t2 ON t1.id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "projects_types",
            "from_column": "type_id",
            "to_table": "types",
            "to_column": "id",
            "condition": "projects_types.type_id = types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "projects_types",
            "from_column": "project_id",
            "to_table": "versions",
            "to_column": "project_id",
            "condition": "projects_types.project_id = versions.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, which suggests a direct relationship between projects and their versions. The 'projects_types' table associates projects with types, while the 'versions' table tracks different versions of these projects. This relationship is logical as it connects the categorization of projects with their versioning.",
            "test_sql": "SELECT COUNT(*) FROM projects_types t1 JOIN versions t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 24,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "projects_types",
            "from_column": "project_id",
            "to_table": "wikis",
            "to_column": "project_id",
            "condition": "projects_types.project_id = wikis.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, which suggests a logical connection between the two. The 'projects_types' table associates projects with types, while the 'wikis' table associates wikis with projects. This implies that wikis are linked to projects that can be categorized by types, making it reasonable to join these tables on 'project_id'.",
            "test_sql": "SELECT COUNT(*) FROM projects_types t1 JOIN wikis t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "projects_types",
            "from_column": "project_id",
            "to_table": "work_packages",
            "to_column": "project_id",
            "condition": "projects_types.project_id = work_packages.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field that references the 'projects' table. This suggests a direct relationship where work packages are associated with projects, and projects can have multiple types. This relationship is logical given the business context of managing projects and their associated work packages.",
            "test_sql": "SELECT COUNT(*) FROM projects_types t1 JOIN work_packages t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 177,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "projects_types",
            "from_column": "project_id",
            "to_table": "work_package_journals",
            "to_column": "project_id",
            "condition": "projects_types.project_id = work_package_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, which suggests a direct relationship between projects and work package journals. This relationship is likely to exist because work package journals are associated with specific projects, and the 'projects_types' table categorizes these projects.",
            "test_sql": "SELECT COUNT(*) FROM projects_types t1 JOIN work_package_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 177,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "views",
            "from_column": "query_id",
            "to_table": "queries",
            "to_column": "id",
            "condition": "views.query_id = queries.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "queries",
            "from_column": "user_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "queries.user_id = users.id",
            "confidence": "high",
            "reasoning": "The 'user_id' field in the 'queries' table likely references the 'id' field in the 'users' table, indicating which user created or owns the query. This is a common pattern where a foreign key relationship is used to associate records in one table with users in another table.",
            "test_sql": "SELECT COUNT(*) FROM queries t1 JOIN users t2 ON t1.user_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "queries",
            "from_column": "user_id",
            "to_table": "user_preferences",
            "to_column": "user_id",
            "condition": "queries.user_id = user_preferences.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a logical relationship where each query is associated with a user, and each user has preferences. This relationship aligns with common database design patterns where user-specific data is linked through a user identifier.",
            "test_sql": "SELECT COUNT(*) FROM queries t1 JOIN user_preferences t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "queries",
            "from_column": "project_id",
            "to_table": "wikis",
            "to_column": "project_id",
            "condition": "queries.project_id = wikis.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that queries and wikis are associated with specific projects. This is a common pattern in project management systems where different entities are linked to projects.",
            "test_sql": "SELECT COUNT(*) FROM queries t1 JOIN wikis t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "queries",
            "from_column": "project_id",
            "to_table": "work_packages",
            "to_column": "project_id",
            "condition": "queries.project_id = work_packages.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that queries are associated with specific projects, and work packages are tasks within those projects. This relationship aligns with common project management practices where queries might be used to filter or report on work packages within the same project.",
            "test_sql": "SELECT COUNT(*) FROM queries t1 JOIN work_packages t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 458,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "role_permissions",
            "from_column": "role_id",
            "to_table": "roles",
            "to_column": "id",
            "condition": "role_permissions.role_id = roles.id",
            "confidence": "high",
            "reasoning": "The 'role_permissions' table contains a 'role_id' field, which is likely intended to reference the 'id' field in the 'roles' table. This is a common pattern in database design where a permissions table references a roles table to associate specific permissions with specific roles.",
            "test_sql": "SELECT COUNT(*) FROM role_permissions t1 JOIN roles t2 ON t1.role_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 306,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "role_permissions",
            "from_column": "role_id",
            "to_table": "workflows",
            "to_column": "role_id",
            "condition": "role_permissions.role_id = workflows.role_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'role_id' field, which suggests a logical connection where the permissions assigned to a role in 'role_permissions' could be related to the roles allowed to perform workflow transitions in 'workflows'. This relationship is supported by the business logic of controlling access to workflow transitions based on roles.",
            "test_sql": "SELECT COUNT(*) FROM role_permissions t1 JOIN workflows t2 ON t1.role_id = t2.role_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 136538,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "workflows",
            "from_column": "role_id",
            "to_table": "roles",
            "to_column": "id",
            "condition": "workflows.role_id = roles.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "sessions",
            "from_column": "user_id",
            "to_table": "user_preferences",
            "to_column": "user_id",
            "condition": "sessions.user_id = user_preferences.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field of the same data type (bigint), suggesting a logical connection where sessions are associated with user preferences. This relationship aligns with common database design patterns where user-specific data is linked through a user identifier.",
            "test_sql": "SELECT COUNT(*) FROM sessions t1 JOIN user_preferences t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "sessions",
            "from_column": "user_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "sessions.user_id = users.id",
            "confidence": "high",
            "reasoning": "The 'user_id' field in the 'sessions' table likely corresponds to the 'id' field in the 'users' table, as it is common for session data to be associated with a specific user. This relationship allows tracking of which user is associated with each session, which is a typical pattern in web applications for managing user sessions.",
            "test_sql": "SELECT COUNT(*) FROM sessions t1 JOIN users t2 ON t1.user_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "work_packages",
            "from_column": "status_id",
            "to_table": "statuses",
            "to_column": "id",
            "condition": "work_packages.status_id = statuses.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "workflows",
            "from_column": "new_status_id",
            "to_table": "statuses",
            "to_column": "id",
            "condition": "workflows.new_status_id = statuses.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "workflows",
            "from_column": "old_status_id",
            "to_table": "statuses",
            "to_column": "id",
            "condition": "workflows.old_status_id = statuses.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "tokens",
            "from_column": "user_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "tokens.user_id = users.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "statuses",
            "from_column": "id",
            "to_table": "work_package_journals",
            "to_column": "status_id",
            "condition": "statuses.id = work_package_journals.status_id",
            "confidence": "high",
            "reasoning": "The 'status_id' field in the 'work_package_journals' table likely references the 'id' field in the 'statuses' table to indicate the current status of a work package. This is a common pattern in database design where a status table is used to define possible states for entities in another table.",
            "test_sql": "SELECT COUNT(*) FROM statuses t1 JOIN work_package_journals t2 ON t1.id = t2.status_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tokens",
            "from_column": "user_id",
            "to_table": "user_preferences",
            "to_column": "user_id",
            "condition": "tokens.user_id = user_preferences.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a logical connection between the tokens associated with a user and their preferences. This relationship is common in systems where user-specific data is stored across multiple tables. The 'user_id' field in both tables is of the same data type (bigint), making them compatible for a JOIN operation.",
            "test_sql": "SELECT COUNT(*) FROM tokens t1 JOIN user_preferences t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tokens",
            "from_column": "user_id",
            "to_table": "user_passwords",
            "to_column": "user_id",
            "condition": "tokens.user_id = user_passwords.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a logical connection between tokens and user passwords. This relationship is likely based on the business logic that both tokens and passwords are associated with user accounts. The 'user_id' serves as a common identifier linking the two tables, even though the foreign key is not explicitly defined in the 'user_passwords' table.",
            "test_sql": "SELECT COUNT(*) FROM tokens t1 JOIN user_passwords t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "work_packages",
            "from_column": "type_id",
            "to_table": "types",
            "to_column": "id",
            "condition": "work_packages.type_id = types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "workflows",
            "from_column": "type_id",
            "to_table": "types",
            "to_column": "id",
            "condition": "workflows.type_id = types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "types",
            "from_column": "id",
            "to_table": "work_package_journals",
            "to_column": "type_id",
            "condition": "types.id = work_package_journals.type_id",
            "confidence": "high",
            "reasoning": "The 'type_id' field in the 'work_package_journals' table likely references the 'id' field in the 'types' table, as it is common for work packages to be categorized by type. This relationship aligns with the business purpose of categorizing work packages based on predefined types.",
            "test_sql": "SELECT COUNT(*) FROM types t1 JOIN work_package_journals t2 ON t1.id = t2.type_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "user_passwords",
            "from_column": "user_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "user_passwords.user_id = users.id",
            "confidence": "high",
            "reasoning": "The 'user_id' field in the 'user_passwords' table likely corresponds to the 'id' field in the 'users' table. This is a common pattern where a user account in the 'users' table is linked to their password information in the 'user_passwords' table. The data types are compatible, and the naming convention suggests a direct relationship.",
            "test_sql": "SELECT COUNT(*) FROM user_passwords t1 JOIN users t2 ON t1.user_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "user_passwords",
            "from_column": "user_id",
            "to_table": "user_preferences",
            "to_column": "user_id",
            "condition": "user_passwords.user_id = user_preferences.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a common link between them. The 'user_id' field in both tables likely serves as a reference to the same user entity, allowing for the association of password information with user preferences. This is a common pattern in database design where user-related data is distributed across multiple tables.",
            "test_sql": "SELECT COUNT(*) FROM user_passwords t1 JOIN user_preferences t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "user_preferences",
            "from_column": "user_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "user_preferences.user_id = users.id",
            "confidence": "high",
            "reasoning": "The 'user_id' field in the 'user_preferences' table likely corresponds to the 'id' field in the 'users' table, as it is common for user-specific settings to be linked to a user account. This relationship allows for the retrieval of user preferences based on the user account information.",
            "test_sql": "SELECT COUNT(*) FROM user_preferences t1 JOIN users t2 ON t1.user_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "wiki_pages",
            "from_column": "author_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "wiki_pages.author_id = users.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "users",
            "from_column": "id",
            "to_table": "watchers",
            "to_column": "user_id",
            "condition": "users.id = watchers.user_id",
            "confidence": "high",
            "reasoning": "The 'user_id' field in the 'watchers' table likely references the 'id' field in the 'users' table, as it is common for tables tracking user actions or preferences to link back to a user table via a user ID. This relationship allows the system to identify which user is watching a particular entity.",
            "test_sql": "SELECT COUNT(*) FROM users t1 JOIN watchers t2 ON t1.id = t2.user_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "version_settings",
            "from_column": "version_id",
            "to_table": "versions",
            "to_column": "id",
            "condition": "version_settings.version_id = versions.id",
            "confidence": "high",
            "reasoning": "The 'version_id' in 'version_settings' likely corresponds to the 'id' in 'versions', indicating that each setting is associated with a specific version of a project. This is a common pattern where settings or configurations are linked to specific entities by their IDs.",
            "test_sql": "SELECT COUNT(*) FROM version_settings t1 JOIN versions t2 ON t1.version_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "versions",
            "from_column": "project_id",
            "to_table": "wikis",
            "to_column": "project_id",
            "condition": "versions.project_id = wikis.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, which suggests that versions and wikis are associated with specific projects. This is a common pattern where different entities related to a project are linked through a project identifier.",
            "test_sql": "SELECT COUNT(*) FROM versions t1 JOIN wikis t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "versions",
            "from_column": "id",
            "to_table": "work_package_journals",
            "to_column": "version_id",
            "condition": "versions.id = work_package_journals.version_id",
            "confidence": "high",
            "reasoning": "The 'version_id' field in the 'work_package_journals' table suggests a direct relationship with the 'id' field in the 'versions' table. This implies that each work package journal entry can be associated with a specific version of a project, which aligns with common project management practices where tasks or work packages are often linked to specific project versions or releases.",
            "test_sql": "SELECT COUNT(*) FROM versions t1 JOIN work_package_journals t2 ON t1.id = t2.version_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "wiki_pages",
            "from_column": "wiki_id",
            "to_table": "wikis",
            "to_column": "id",
            "condition": "wiki_pages.wiki_id = wikis.id",
            "confidence": "high",
            "reasoning": "The 'wiki_id' field in the 'wiki_pages' table likely corresponds to the 'id' field in the 'wikis' table, suggesting that each page belongs to a specific wiki. This is a common pattern where pages are grouped under a wiki, and the 'wiki_id' serves as a foreign key to the 'wikis' table.",
            "test_sql": "SELECT COUNT(*) FROM wiki_pages t1 JOIN wikis t2 ON t1.wiki_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "wikis",
            "from_column": "project_id",
            "to_table": "work_packages",
            "to_column": "project_id",
            "condition": "wikis.project_id = work_packages.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that wikis and work packages are associated with projects. This is a common pattern in project management systems where documentation (wikis) and tasks (work packages) are linked to specific projects.",
            "test_sql": "SELECT COUNT(*) FROM wikis t1 JOIN work_packages t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "work_package_hierarchies",
            "from_column": "ancestor_id",
            "to_table": "work_packages",
            "to_column": "id",
            "condition": "work_package_hierarchies.ancestor_id = work_packages.id",
            "confidence": "high",
            "reasoning": "The 'ancestor_id' in 'work_package_hierarchies' likely references the 'id' in 'work_packages' as it represents a hierarchical relationship where the ancestor is a work package itself.",
            "test_sql": "SELECT COUNT(*) FROM work_package_hierarchies t1 JOIN work_packages t2 ON t1.ancestor_id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 54,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "work_package_hierarchies",
            "from_column": "descendant_id",
            "to_table": "work_packages",
            "to_column": "id",
            "condition": "work_package_hierarchies.descendant_id = work_packages.id",
            "confidence": "high",
            "reasoning": "The 'descendant_id' in 'work_package_hierarchies' likely references the 'id' in 'work_packages' as it represents a hierarchical relationship where the descendant is a work package itself.",
            "test_sql": "SELECT COUNT(*) FROM work_package_hierarchies t1 JOIN work_packages t2 ON t1.descendant_id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 54,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "container_id",
            "to_table": "attachments",
            "to_column": "container_id",
            "condition": "attachment_journals.container_id = attachments.container_id AND attachment_journals.container_type = attachments.container_type",
            "confidence": "high",
            "reasoning": "Both tables have 'container_id' and 'container_type' fields, suggesting a polymorphic relationship where attachments in both tables could be linked to the same entities or records. This relationship is inferred based on the common pattern of using container fields to associate records with various entities.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN attachments t2 ON t1.container_id = t2.container_id AND t1.container_type = t2.container_type LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "author_id",
            "to_table": "meeting_journals",
            "to_column": "author_id",
            "condition": "attachment_journals.author_id = meeting_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that attachments and meetings could be linked to the same author or user. This relationship is based on the assumption that the same individuals who create or upload attachments might also be responsible for creating or managing meeting records.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN meeting_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "author_id",
            "to_table": "meeting_agenda_items",
            "to_column": "author_id",
            "condition": "attachment_journals.author_id = meeting_agenda_items.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that attachments and meeting agenda items could be linked to the same author. This relationship is based on the assumption that the same author could be responsible for creating both attachments and agenda items.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN meeting_agenda_items t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "author_id",
            "to_table": "meetings",
            "to_column": "author_id",
            "condition": "attachment_journals.author_id = meetings.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that attachments and meetings could be linked to the same author or user. This relationship is based on the assumption that the 'author_id' represents the same entity in both tables, such as a user or employee who can create both attachments and meetings.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN meetings t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "author_id",
            "to_table": "members",
            "to_column": "user_id",
            "condition": "attachment_journals.author_id = members.user_id",
            "confidence": "high",
            "reasoning": "The 'author_id' in 'attachment_journals' could correspond to the 'user_id' in 'members', suggesting that the author of an attachment might be a member of a project or entity. This relationship is based on the assumption that authors are users who can be members of projects or entities.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN members t2 ON t1.author_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "author_id",
            "to_table": "news",
            "to_column": "author_id",
            "condition": "attachment_journals.author_id = news.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, suggesting that attachments and news articles could be linked to the same author. This relationship is based on the assumption that the same authors can create both attachments and news articles.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN news t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "author_id",
            "to_table": "news_journals",
            "to_column": "author_id",
            "condition": "attachment_journals.author_id = news_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that attachments and news journal entries could be linked to the same author. This relationship is based on the assumption that the same authors can create both attachments and news entries, although there is no explicit foreign key constraint.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN news_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "author_id",
            "to_table": "queries",
            "to_column": "user_id",
            "condition": "attachment_journals.author_id = queries.user_id",
            "confidence": "high",
            "reasoning": "Both tables have fields that reference user-related information: 'author_id' in 'attachment_journals' and 'user_id' in 'queries'. This suggests a potential relationship where attachments are linked to the queries created by the same user. However, without explicit foreign keys or additional context, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN queries t2 ON t1.author_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 52,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "author_id",
            "to_table": "wiki_page_journals",
            "to_column": "author_id",
            "condition": "attachment_journals.author_id = wiki_page_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that attachments and wiki page journal entries could be linked to the same author. This relationship is based on the assumption that the same authors are responsible for creating or modifying both attachments and wiki page entries.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN wiki_page_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "author_id",
            "to_table": "wiki_pages",
            "to_column": "author_id",
            "condition": "attachment_journals.author_id = wiki_pages.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that attachments and wiki pages could be linked to the same author. This relationship is based on the assumption that the same author could be responsible for creating both attachments and wiki pages, even though there is no explicit foreign key constraint defined between these tables.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN wiki_pages t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "author_id",
            "to_table": "work_package_journals",
            "to_column": "author_id",
            "condition": "attachment_journals.author_id = work_package_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that attachments and work package journals could be linked to the same author or user. This relationship is based on the assumption that the same individuals who create or modify work packages might also be responsible for uploading related attachments.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN work_package_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 72,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "container_id",
            "to_table": "work_packages",
            "to_column": "id",
            "condition": "attachment_journals.container_id = work_packages.id",
            "confidence": "high",
            "reasoning": "The 'container_id' in 'attachment_journals' suggests a polymorphic relationship where attachments can be linked to various entities. Given the business purpose of 'work_packages' as tasks or units of work, it is plausible that attachments could be associated with specific work packages. The data types are compatible, and this follows a common pattern where attachments are linked to work items.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN work_packages t2 ON t1.container_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachments",
            "from_column": "author_id",
            "to_table": "meeting_journals",
            "to_column": "author_id",
            "condition": "attachments.author_id = meeting_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, suggesting that attachments and meeting journals may be associated with the same author or user. This relationship is based on the assumption that the 'author_id' represents the same entity in both tables, which is a common pattern in database design where multiple records are linked to a user or author entity.",
            "test_sql": "SELECT COUNT(*) FROM attachments t1 JOIN meeting_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachments",
            "from_column": "author_id",
            "to_table": "meetings",
            "to_column": "author_id",
            "condition": "attachments.author_id = meetings.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that attachments and meetings could be associated with the same author or user. This relationship is based on the assumption that the 'author_id' represents the same entity in both tables, such as a user or employee responsible for creating or organizing the respective records.",
            "test_sql": "SELECT COUNT(*) FROM attachments t1 JOIN meetings t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachments",
            "from_column": "author_id",
            "to_table": "members",
            "to_column": "user_id",
            "condition": "attachments.author_id = members.user_id",
            "confidence": "high",
            "reasoning": "The 'author_id' in the 'attachments' table likely represents a user who created or uploaded the attachment, while 'user_id' in the 'members' table represents a user associated with a project or entity. This suggests a potential relationship where the author of an attachment is also a member of a project or entity.",
            "test_sql": "SELECT COUNT(*) FROM attachments t1 JOIN members t2 ON t1.author_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachments",
            "from_column": "author_id",
            "to_table": "news",
            "to_column": "author_id",
            "condition": "attachments.author_id = news.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, suggesting that attachments and news items may be linked to the same author. This relationship is based on the assumption that authors can create both attachments and news articles, and the 'author_id' serves as a common identifier.",
            "test_sql": "SELECT COUNT(*) FROM attachments t1 JOIN news t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachments",
            "from_column": "author_id",
            "to_table": "meeting_agenda_items",
            "to_column": "author_id",
            "condition": "attachments.author_id = meeting_agenda_items.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that attachments and meeting agenda items could be associated with the same author. This relationship is based on the assumption that the same entity (author) is responsible for creating both attachments and agenda items.",
            "test_sql": "SELECT COUNT(*) FROM attachments t1 JOIN meeting_agenda_items t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachments",
            "from_column": "author_id",
            "to_table": "news_journals",
            "to_column": "author_id",
            "condition": "attachments.author_id = news_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, suggesting that attachments and news journal entries could be linked by the same author. This relationship is based on the assumption that authors can create both attachments and news journal entries.",
            "test_sql": "SELECT COUNT(*) FROM attachments t1 JOIN news_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachments",
            "from_column": "container_id",
            "to_table": "relations",
            "to_column": "from_id",
            "condition": "attachments.container_id = relations.from_id",
            "confidence": "high",
            "reasoning": "The 'container_id' in the 'attachments' table could represent an entity that is part of a relationship tracked in the 'relations' table. This suggests a potential link where attachments are associated with entities that have relationships defined by 'from_id'.",
            "test_sql": "SELECT COUNT(*) FROM attachments t1 JOIN relations t2 ON t1.container_id = t2.from_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachments",
            "from_column": "author_id",
            "to_table": "tokens",
            "to_column": "user_id",
            "condition": "attachments.author_id = tokens.user_id",
            "confidence": "high",
            "reasoning": "The 'author_id' in the 'attachments' table likely represents a user who created or uploaded the attachment, while 'user_id' in the 'tokens' table represents a user associated with a token. This suggests a potential relationship where tokens are linked to users who may also be authors of attachments.",
            "test_sql": "SELECT COUNT(*) FROM attachments t1 JOIN tokens t2 ON t1.author_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachments",
            "from_column": "author_id",
            "to_table": "user_passwords",
            "to_column": "user_id",
            "condition": "attachments.author_id = user_passwords.user_id",
            "confidence": "high",
            "reasoning": "The 'author_id' in the 'attachments' table likely refers to a user who created or uploaded the attachment. The 'user_id' in the 'user_passwords' table represents a user account. It is common for systems to link files or documents to the user who created them, and the naming convention suggests a potential relationship between these fields.",
            "test_sql": "SELECT COUNT(*) FROM attachments t1 JOIN user_passwords t2 ON t1.author_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachments",
            "from_column": "author_id",
            "to_table": "user_preferences",
            "to_column": "user_id",
            "condition": "attachments.author_id = user_preferences.user_id",
            "confidence": "high",
            "reasoning": "The 'author_id' in the 'attachments' table likely refers to a user who created or uploaded the attachment. The 'user_id' in the 'user_preferences' table represents a user whose preferences are stored. Although there is no explicit foreign key relationship defined, it is common for systems to associate files or documents with users who have preferences stored in the system.",
            "test_sql": "SELECT COUNT(*) FROM attachments t1 JOIN user_preferences t2 ON t1.author_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachments",
            "from_column": "author_id",
            "to_table": "wiki_page_journals",
            "to_column": "author_id",
            "condition": "attachments.author_id = wiki_page_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that attachments and wiki page journals may be associated with the same authors. This relationship is based on the assumption that the 'author_id' represents the same entity in both tables, possibly indicating that authors who upload attachments may also be responsible for making journal entries on wiki pages.",
            "test_sql": "SELECT COUNT(*) FROM attachments t1 JOIN wiki_page_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachments",
            "from_column": "author_id",
            "to_table": "work_package_journals",
            "to_column": "author_id",
            "condition": "attachments.author_id = work_package_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests a potential relationship where the same author could be responsible for both creating attachments and making journal entries. This is a common pattern in systems where users or authors are involved in multiple activities.",
            "test_sql": "SELECT COUNT(*) FROM attachments t1 JOIN work_package_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 72,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachments",
            "from_column": "container_id",
            "to_table": "work_packages",
            "to_column": "id",
            "condition": "attachments.container_id = work_packages.id",
            "confidence": "high",
            "reasoning": "The 'container_id' in the 'attachments' table suggests a polymorphic association where attachments can be linked to various entities. Given the business purpose of 'work_packages' as tasks or units of work, it is plausible that attachments could be associated with specific work packages. The data type compatibility (both are bigint) supports this potential relationship.",
            "test_sql": "SELECT COUNT(*) FROM attachments t1 JOIN work_packages t2 ON t1.container_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "enabled_modules",
            "to_column": "project_id",
            "condition": "categories.project_id = enabled_modules.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that categories and enabled modules are associated with specific projects. This relationship is logical as both tables could be part of a project management system where categories organize tasks and enabled modules configure project features.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN enabled_modules t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 13,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "grids",
            "to_column": "project_id",
            "condition": "categories.project_id = grids.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that categories and grids might be associated with the same project. This relationship is based on the assumption that both tables are part of a project management system where categories and grids are organized under projects.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN grids t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "meeting_journals",
            "to_column": "project_id",
            "condition": "categories.project_id = meeting_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that categories and meeting journals can be associated with the same project. This relationship is logical as both categories and meetings can be organized or tracked within the context of a project.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN meeting_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "members",
            "to_column": "project_id",
            "condition": "categories.project_id = members.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that categories are associated with projects and members are associated with projects. This relationship connects categories within a project to the members of that project, facilitating project management and collaboration.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN members t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "news_journals",
            "to_column": "project_id",
            "condition": "categories.project_id = news_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that categories and news journal entries might be associated with the same projects. This relationship is inferred based on the common field name and the business purpose of organizing elements within projects.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN news_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "projects_types",
            "to_column": "project_id",
            "condition": "categories.project_id = projects_types.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting a potential relationship where categories are associated with projects that have specific types. This aligns with the business purpose of organizing elements within a project management system and categorizing projects by type.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN projects_types t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "queries",
            "to_column": "project_id",
            "condition": "categories.project_id = queries.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that categories and queries might be associated with the same projects. This relationship is inferred based on the common field name and the business purpose of associating elements with projects.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN queries t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "project_journals",
            "to_column": "id",
            "condition": "categories.project_id = project_journals.id",
            "confidence": "high",
            "reasoning": "The 'project_id' in the 'categories' table likely refers to a project that could be represented in the 'project_journals' table. This relationship is inferred based on the common business logic where categories are often associated with specific projects, and 'project_journals' seems to represent projects.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN project_journals t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "version_settings",
            "to_column": "project_id",
            "condition": "categories.project_id = version_settings.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that categories and version settings might be associated with the same project. This relationship is inferred based on the common business purpose of managing project-related data, even though no explicit foreign key is defined.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN version_settings t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "project_id",
            "to_table": "work_packages",
            "to_column": "project_id",
            "condition": "categories.project_id = work_packages.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, indicating that categories and work packages are associated with projects. This relationship is logical as both entities are likely organized within the same project context.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN work_packages t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "grids",
            "to_column": "project_id",
            "condition": "enabled_modules.project_id = grids.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that modules and grids could be associated with the same project. This relationship is inferred based on the common field name and the business purpose of both tables being related to project configurations.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN grids t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 46,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "meeting_journals",
            "to_column": "project_id",
            "condition": "enabled_modules.project_id = meeting_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that modules and meetings can be associated with specific projects. This relationship is based on the common business logic that both modules and meetings can be linked to projects, allowing for project-specific configurations and documentation.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN meeting_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "journals",
            "to_column": "journable_id",
            "condition": "enabled_modules.project_id = journals.journable_id",
            "confidence": "high",
            "reasoning": "The 'project_id' in 'enabled_modules' and 'journable_id' in 'journals' both use the 'bigint' data type and could represent entities within the same domain. The 'journable_type' field in 'journals' might be used to specify the type of entity being logged, potentially including projects. This suggests a possible relationship where changes to project configurations (enabled modules) are logged in the 'journals' table.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN journals t2 ON t1.project_id = t2.journable_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 72,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "members",
            "to_column": "project_id",
            "condition": "enabled_modules.project_id = members.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that they may be related through the projects they reference. The 'enabled_modules' table configures modules for specific projects, while the 'members' table associates users with projects. This relationship is logical in a project management context where modules are enabled for projects that have members.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN members t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 13,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "meetings",
            "to_column": "project_id",
            "condition": "enabled_modules.project_id = meetings.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that modules and meetings can be associated with specific projects. This relationship is logical given the business purposes of the tables, where enabled modules might be relevant to the meetings scheduled for a particular project.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN meetings t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "news",
            "to_column": "project_id",
            "condition": "enabled_modules.project_id = news.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that they may be related through a common project. This relationship is logical given that both tables could be part of a larger system where projects have associated modules and news items.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN news t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 13,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "news_journals",
            "to_column": "project_id",
            "condition": "enabled_modules.project_id = news_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that entries in both tables could be associated with the same project. This relationship is inferred based on the common field name and the typical database design pattern where multiple entities are linked to a project.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN news_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 13,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "project_journals",
            "to_column": "id",
            "condition": "enabled_modules.project_id = project_journals.id",
            "confidence": "high",
            "reasoning": "The 'project_id' in 'enabled_modules' suggests a potential link to the 'id' in 'project_journals', as both tables are related to projects. This relationship is inferred based on the common theme of projects, where 'enabled_modules' could be enabling modules for specific projects tracked in 'project_journals'. However, without explicit foreign key constraints or more context, the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN project_journals t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 13,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "queries",
            "to_column": "project_id",
            "condition": "enabled_modules.project_id = queries.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that they may be related through the concept of projects. The 'enabled_modules' table configures modules for specific projects, while the 'queries' table stores queries associated with projects. This relationship is logical given the shared field name and business purpose.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN queries t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 170,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "version_settings",
            "to_column": "project_id",
            "condition": "enabled_modules.project_id = version_settings.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that they may be related through the projects they are associated with. This relationship is based on the assumption that both tables are used to configure different aspects of a project, such as enabled modules and version settings.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN version_settings t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 24,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "watchers",
            "to_column": "watchable_id",
            "condition": "enabled_modules.project_id = watchers.watchable_id",
            "confidence": "high",
            "reasoning": "The 'project_id' in 'enabled_modules' and 'watchable_id' in 'watchers' could potentially represent the same entity, assuming that projects are one of the types of entities that can be watched. This relationship is inferred based on the naming convention and the business purpose of tracking entities that users are monitoring.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN watchers t2 ON t1.project_id = t2.watchable_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 20,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enabled_modules",
            "from_column": "project_id",
            "to_table": "work_package_journals",
            "to_column": "project_id",
            "condition": "enabled_modules.project_id = work_package_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that they may be related through the projects they are associated with. The 'enabled_modules' table configures modules for specific projects, while 'work_package_journals' tracks changes to work packages within those projects. This relationship is logical given the shared project context.",
            "test_sql": "SELECT COUNT(*) FROM enabled_modules t1 JOIN work_package_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 229,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enumerations",
            "from_column": "id",
            "to_table": "journals",
            "to_column": "journable_id",
            "condition": "enumerations.id = journals.journable_id",
            "confidence": "high",
            "reasoning": "The 'journable_id' field in the 'journals' table suggests a polymorphic relationship with other entities. Given that 'enumerations' has an 'id' field, it is possible that 'journable_id' could reference 'enumerations.id' if 'journable_type' indicates an enumeration type. However, without explicit information on 'journable_type', this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM enumerations t1 JOIN journals t2 ON t1.id = t2.journable_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 22,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enumerations",
            "from_column": "id",
            "to_table": "relations",
            "to_column": "from_id",
            "condition": "enumerations.id = relations.from_id",
            "confidence": "high",
            "reasoning": "The 'from_id' in the 'relations' table could potentially reference the 'id' in the 'enumerations' table, suggesting that an enumeration might be the source entity in a relationship. This is inferred based on the common practice of using 'id' fields as primary keys and the possibility that enumerations could represent entities involved in relationships.",
            "test_sql": "SELECT COUNT(*) FROM enumerations t1 JOIN relations t2 ON t1.id = t2.from_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enumerations",
            "from_column": "id",
            "to_table": "relations",
            "to_column": "to_id",
            "condition": "enumerations.id = relations.to_id",
            "confidence": "high",
            "reasoning": "Similarly, the 'to_id' in the 'relations' table could reference the 'id' in the 'enumerations' table, indicating that an enumeration might be the target entity in a relationship. This is based on the assumption that enumerations could represent entities that are connected or related.",
            "test_sql": "SELECT COUNT(*) FROM enumerations t1 JOIN relations t2 ON t1.id = t2.to_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enumerations",
            "from_column": "color_id",
            "to_table": "statuses",
            "to_column": "color_id",
            "condition": "enumerations.color_id = statuses.color_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'color_id' field, suggesting a potential relationship where enumerations and statuses might share color attributes for display purposes. This is a common pattern where visual elements are linked to entities for consistent UI representation.",
            "test_sql": "SELECT COUNT(*) FROM enumerations t1 JOIN statuses t2 ON t1.color_id = t2.color_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enumerations",
            "from_column": "id",
            "to_table": "workflows",
            "to_column": "type_id",
            "condition": "enumerations.id = workflows.type_id",
            "confidence": "high",
            "reasoning": "The 'type_id' in the 'workflows' table could potentially refer to an enumeration type defined in the 'enumerations' table. This is based on the common use of enumerations to define types or categories, which aligns with the purpose of the 'type_id' field in the 'workflows' table.",
            "test_sql": "SELECT COUNT(*) FROM enumerations t1 JOIN workflows t2 ON t1.id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1758,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "project_id",
            "to_table": "meetings",
            "to_column": "project_id",
            "condition": "grids.project_id = meetings.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that grids and meetings might be associated with the same projects. This relationship is based on the assumption that both grids and meetings can be part of a larger project context, which is a common pattern in project management systems.",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN meetings t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "project_id",
            "to_table": "meeting_journals",
            "to_column": "project_id",
            "condition": "grids.project_id = meeting_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that grids and meeting journals could be associated with the same projects. This relationship is based on the assumption that both tables are used within the context of project management, where grids might represent layout configurations for project-related tasks, and meeting journals document meetings related to those projects.",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN meeting_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "project_id",
            "to_table": "members",
            "to_column": "project_id",
            "condition": "grids.project_id = members.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, indicating that grids might be part of projects that members are associated with. This relationship is logical given the shared context of projects.",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN members t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "project_id",
            "to_table": "news",
            "to_column": "project_id",
            "condition": "grids.project_id = news.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that grids and news items might be associated with the same projects. This relationship is plausible if grids are used within projects that also have related news articles.",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN news t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "project_id",
            "to_table": "news_journals",
            "to_column": "project_id",
            "condition": "grids.project_id = news_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that grids and news journals might be associated with the same projects. This relationship is inferred based on the common field name and the business purpose of associating entities with projects.",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN news_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "project_id",
            "to_table": "projects_types",
            "to_column": "project_id",
            "condition": "grids.project_id = projects_types.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'grids' table suggests a potential link to projects, and the 'projects_types' table explicitly uses 'project_id' to associate projects with types. This relationship could be used to determine which types are associated with the projects that contain specific grids.",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN projects_types t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 30,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "project_id",
            "to_table": "project_journals",
            "to_column": "id",
            "condition": "grids.project_id = project_journals.id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'grids' table suggests a potential linkage to the 'project_journals' table, where each grid might be associated with a specific project journal. This relationship is inferred based on the naming convention and the business purpose of both tables, where grids could be part of a project management system.",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN project_journals t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "project_id",
            "to_table": "queries",
            "to_column": "project_id",
            "condition": "grids.project_id = queries.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that grids and queries might be associated with the same project. This relationship is logical in a project management or data analysis context where both grid configurations and queries could be part of a project.",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN queries t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 92,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "id",
            "to_table": "relations",
            "to_column": "from_id",
            "condition": "grids.id = relations.from_id",
            "confidence": "high",
            "reasoning": "The 'from_id' in the 'relations' table could potentially reference the 'id' in the 'grids' table, suggesting a relationship where a grid is the starting point of a relation. This is inferred based on the naming convention and the typical use of 'id' as a primary key.",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN relations t2 ON t1.id = t2.from_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "id",
            "to_table": "relations",
            "to_column": "to_id",
            "condition": "grids.id = relations.to_id",
            "confidence": "high",
            "reasoning": "Similarly, the 'to_id' in the 'relations' table could reference the 'id' in the 'grids' table, indicating that a grid is the endpoint of a relation. This is based on the assumption that 'id' is a common primary key and 'to_id' could be a foreign key.",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN relations t2 ON t1.id = t2.to_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "project_id",
            "to_table": "versions",
            "to_column": "project_id",
            "condition": "grids.project_id = versions.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that grids and versions might be associated with the same project. This relationship is inferred based on the common field name and the business purpose of tracking project-related data.",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN versions t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 12,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "project_id",
            "to_table": "version_settings",
            "to_column": "project_id",
            "condition": "grids.project_id = version_settings.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that grids and version settings could be associated with the same project. This relationship is plausible given that grids might be part of a project's layout or configuration, and version settings manage different versions of the same project.",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN version_settings t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 12,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grids",
            "from_column": "project_id",
            "to_table": "work_packages",
            "to_column": "project_id",
            "condition": "grids.project_id = work_packages.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that grids and work packages could be associated with the same project. This relationship is logical in a project management context where grids might be used to visualize or organize work packages within a project.",
            "test_sql": "SELECT COUNT(*) FROM grids t1 JOIN work_packages t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 121,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "journals",
            "from_column": "data_id",
            "to_table": "project_journals",
            "to_column": "id",
            "condition": "journals.data_id = project_journals.id",
            "confidence": "high",
            "reasoning": "The 'data_id' field in the 'journals' table could potentially reference the 'id' field in the 'project_journals' table, suggesting that journal entries might be related to specific projects. This relationship is inferred based on the naming convention and the business purpose of tracking changes related to entities, which could include projects.",
            "test_sql": "SELECT COUNT(*) FROM journals t1 JOIN project_journals t2 ON t1.data_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 10,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "journals",
            "from_column": "data_id",
            "to_table": "projects",
            "to_column": "id",
            "condition": "journals.data_id = projects.id",
            "confidence": "high",
            "reasoning": "The 'data_id' field in the 'journals' table could potentially reference the 'id' field in the 'projects' table, indicating that a journal entry is related to a specific project. This relationship is inferred based on the naming convention and the common practice of logging changes related to specific entities, such as projects.",
            "test_sql": "SELECT COUNT(*) FROM journals t1 JOIN projects t2 ON t1.data_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 10,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "journals",
            "from_column": "data_id",
            "to_table": "relations",
            "to_column": "from_id",
            "condition": "journals.data_id = relations.from_id",
            "confidence": "high",
            "reasoning": "The 'data_id' in the 'journals' table could represent an entity that is part of a relationship in the 'relations' table. The 'from_id' in the 'relations' table might correspond to the same entity, suggesting a potential link between the journal entry and the relationship it documents or affects.",
            "test_sql": "SELECT COUNT(*) FROM journals t1 JOIN relations t2 ON t1.data_id = t2.from_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "journals",
            "from_column": "data_id",
            "to_table": "relations",
            "to_column": "to_id",
            "condition": "journals.data_id = relations.to_id",
            "confidence": "high",
            "reasoning": "Similarly, the 'data_id' in the 'journals' table could also represent an entity that is the target of a relationship in the 'relations' table. The 'to_id' in the 'relations' table might correspond to this entity, indicating a potential link between the journal entry and the relationship it documents or affects.",
            "test_sql": "SELECT COUNT(*) FROM journals t1 JOIN relations t2 ON t1.data_id = t2.to_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "journals",
            "from_column": "data_id",
            "to_table": "versions",
            "to_column": "id",
            "condition": "journals.data_id = versions.id",
            "confidence": "high",
            "reasoning": "The 'data_id' field in the 'journals' table could potentially reference the 'id' field in the 'versions' table, suggesting that journal entries might be logging changes or events related to specific versions of a project. This is inferred from the naming convention and the business purpose of tracking changes related to different entities.",
            "test_sql": "SELECT COUNT(*) FROM journals t1 JOIN versions t2 ON t1.data_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 10,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "journals",
            "from_column": "data_id",
            "to_table": "wiki_pages",
            "to_column": "id",
            "condition": "journals.data_id = wiki_pages.id",
            "confidence": "high",
            "reasoning": "The 'data_id' field in the 'journals' table could potentially refer to the 'id' of a 'wiki_pages' entry, suggesting that journal entries might be tracking changes or events related to specific wiki pages. This relationship is inferred based on the naming convention and the business purpose of tracking changes to entities.",
            "test_sql": "SELECT COUNT(*) FROM journals t1 JOIN wiki_pages t2 ON t1.data_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 10,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "journals",
            "from_column": "journable_id",
            "to_table": "wikis",
            "to_column": "id",
            "condition": "journals.journable_id = wikis.id",
            "confidence": "high",
            "reasoning": "The 'journable_id' in the 'journals' table could potentially reference the 'id' of the 'wikis' table, especially if the 'journable_type' indicates that the journal entry is related to a wiki. This would allow the 'journals' table to log changes or events specifically related to wikis.",
            "test_sql": "SELECT COUNT(*) FROM journals t1 JOIN wikis t2 ON t1.journable_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 11,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "journals",
            "from_column": "data_id",
            "to_table": "work_package_journals",
            "to_column": "id",
            "condition": "journals.data_id = work_package_journals.id",
            "confidence": "high",
            "reasoning": "The 'data_id' field in the 'journals' table could potentially reference the 'id' field in the 'work_package_journals' table. This is based on the assumption that 'journals' might be logging changes related to specific work packages, which are identified by their 'id'. The 'data_type' field in 'journals' could further specify that the entry is related to a work package.",
            "test_sql": "SELECT COUNT(*) FROM journals t1 JOIN work_package_journals t2 ON t1.data_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 41,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "journals",
            "from_column": "journable_id",
            "to_table": "work_packages",
            "to_column": "id",
            "condition": "journals.journable_id = work_packages.id AND journals.journable_type = 'WorkPackage'",
            "confidence": "high",
            "reasoning": "The 'journals' table has a polymorphic relationship indicated by 'journable_type' and 'journable_id'. Given the business purpose of tracking changes, it's plausible that 'journable_type' could refer to 'WorkPackage', and 'journable_id' would then correspond to the 'id' of the 'work_packages' table. This would allow the 'journals' table to log changes related to specific work packages.",
            "test_sql": "SELECT COUNT(*) FROM journals t1 JOIN work_packages t2 ON t1.journable_id = t2.id AND t1.journable_type = 'WorkPackage' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_agenda_items",
            "from_column": "author_id",
            "to_table": "meeting_journals",
            "to_column": "author_id",
            "condition": "meeting_agenda_items.author_id = meeting_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that agenda items and meeting journals could be linked by the author who created or is responsible for them. This relationship is based on the assumption that the same author could be responsible for both agenda items and meeting records.",
            "test_sql": "SELECT COUNT(*) FROM meeting_agenda_items t1 JOIN meeting_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_agenda_items",
            "from_column": "work_package_id",
            "to_table": "work_package_hierarchies",
            "to_column": "ancestor_id",
            "condition": "meeting_agenda_items.work_package_id = work_package_hierarchies.ancestor_id",
            "confidence": "high",
            "reasoning": "The 'work_package_id' in 'meeting_agenda_items' suggests a link to work packages, which are organized hierarchically in 'work_package_hierarchies'. This relationship can be used to associate agenda items with specific work packages and their hierarchical structure.",
            "test_sql": "SELECT COUNT(*) FROM meeting_agenda_items t1 JOIN work_package_hierarchies t2 ON t1.work_package_id = t2.ancestor_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_agenda_items",
            "from_column": "work_package_id",
            "to_table": "work_package_hierarchies",
            "to_column": "descendant_id",
            "condition": "meeting_agenda_items.work_package_id = work_package_hierarchies.descendant_id",
            "confidence": "high",
            "reasoning": "Similar to the previous relationship, 'work_package_id' could also relate to 'descendant_id' in 'work_package_hierarchies', allowing agenda items to be linked to sub-packages within the hierarchy.",
            "test_sql": "SELECT COUNT(*) FROM meeting_agenda_items t1 JOIN work_package_hierarchies t2 ON t1.work_package_id = t2.descendant_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "project_id",
            "to_table": "members",
            "to_column": "project_id",
            "condition": "meeting_journals.project_id = members.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting a potential relationship where meetings are associated with projects and members are part of those projects. This aligns with common business logic where meetings are held for specific projects and members are participants in those projects.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN members t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "author_id",
            "to_table": "meetings",
            "to_column": "author_id",
            "condition": "meeting_journals.author_id = meetings.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, suggesting that meetings in both tables could be associated with the same authors. This relationship is based on the assumption that the 'author_id' represents the same entity in both tables.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN meetings t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "project_id",
            "to_table": "meetings",
            "to_column": "project_id",
            "condition": "meeting_journals.project_id = meetings.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, indicating that meetings in both tables could be linked to the same projects. This relationship is based on the assumption that the 'project_id' represents the same project entity in both tables.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN meetings t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "project_id",
            "to_table": "news_journals",
            "to_column": "project_id",
            "condition": "meeting_journals.project_id = news_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that meetings and news journal entries could be associated with the same projects. This relationship is based on the common business logic that both meetings and news articles can be linked to specific projects within an organization.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN news_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "author_id",
            "to_table": "news_journals",
            "to_column": "author_id",
            "condition": "meeting_journals.author_id = news_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, indicating that the same individuals might be responsible for creating meeting records and news journal entries. This relationship is based on the logical assumption that authors or users within the organization could be involved in both meetings and news content creation.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN news_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "author_id",
            "to_table": "news",
            "to_column": "author_id",
            "condition": "meeting_journals.author_id = news.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, indicating that the same author might be responsible for creating meeting records and news articles. This relationship is plausible if authors are involved in both documenting meetings and writing news articles.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN news t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "project_id",
            "to_table": "projects_types",
            "to_column": "project_id",
            "condition": "meeting_journals.project_id = projects_types.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in both tables suggests a potential relationship where meetings are associated with projects, and projects can be categorized by types. This relationship is inferred based on the common field name and the business purpose of linking meetings to projects.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN projects_types t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "project_id",
            "to_table": "queries",
            "to_column": "project_id",
            "condition": "meeting_journals.project_id = queries.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that meetings and queries can be associated with the same projects. This relationship is logical in a project management context where meetings and queries are often linked to specific projects.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN queries t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 14,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "author_id",
            "to_table": "sessions",
            "to_column": "user_id",
            "condition": "meeting_journals.author_id = sessions.user_id",
            "confidence": "high",
            "reasoning": "The 'author_id' in 'meeting_journals' and 'user_id' in 'sessions' both represent identifiers for individuals. It is plausible that the author of a meeting journal could be the same user who has a session in the system, suggesting a potential relationship based on user identity.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN sessions t2 ON t1.author_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "author_id",
            "to_table": "user_preferences",
            "to_column": "user_id",
            "condition": "meeting_journals.author_id = user_preferences.user_id",
            "confidence": "high",
            "reasoning": "The 'author_id' in the 'meeting_journals' table could correspond to the 'user_id' in the 'user_preferences' table, suggesting that the author of a meeting might have specific preferences stored in the 'user_preferences' table. This relationship is based on the assumption that authors are users who have preferences.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN user_preferences t2 ON t1.author_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "author_id",
            "to_table": "wiki_page_journals",
            "to_column": "author_id",
            "condition": "meeting_journals.author_id = wiki_page_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, suggesting that the same authors may be responsible for creating meeting records and making changes to wiki pages. This relationship is based on the assumption that the 'author_id' represents the same entity in both tables.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN wiki_page_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "author_id",
            "to_table": "wiki_pages",
            "to_column": "author_id",
            "condition": "meeting_journals.author_id = wiki_pages.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests a potential relationship between the authors of meeting journals and wiki pages. This could imply that the same individuals are responsible for creating or managing both types of records, aligning with common business logic where users contribute to multiple areas of documentation and record-keeping.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN wiki_pages t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "project_id",
            "to_table": "work_package_journals",
            "to_column": "project_id",
            "condition": "meeting_journals.project_id = work_package_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that meetings and work packages can be associated with the same projects. This relationship is based on the common business logic that meetings and work packages are often linked to specific projects within an organization.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN work_package_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 13,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_participants",
            "from_column": "user_id",
            "to_table": "members",
            "to_column": "user_id",
            "condition": "meeting_participants.user_id = members.user_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'user_id' field, which suggests that they might be tracking information related to the same users. The 'meeting_participants' table tracks users involved in meetings, while the 'members' table tracks users associated with projects or other entities. This relationship could be useful for understanding user involvement across different contexts.",
            "test_sql": "SELECT COUNT(*) FROM meeting_participants t1 JOIN members t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "author_id",
            "to_table": "work_packages",
            "to_column": "author_id",
            "condition": "meeting_journals.author_id = work_packages.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which could indicate that the same person who authored a meeting journal entry might also be responsible for authoring work packages. This relationship is plausible in systems where users are responsible for both documenting meetings and creating work packages.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN work_packages t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_participants",
            "from_column": "user_id",
            "to_table": "sessions",
            "to_column": "user_id",
            "condition": "meeting_participants.user_id = sessions.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, suggesting a potential relationship where meeting participants might have sessions associated with their user IDs. This relationship is based on the assumption that 'user_id' represents the same entity in both tables, which is a common pattern in database design.",
            "test_sql": "SELECT COUNT(*) FROM meeting_participants t1 JOIN sessions t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_participants",
            "from_column": "user_id",
            "to_table": "user_preferences",
            "to_column": "user_id",
            "condition": "meeting_participants.user_id = user_preferences.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a potential relationship where meeting participants' preferences could be relevant for customizing meeting-related experiences. The 'user_id' field is a common identifier that could logically link user-specific data across different contexts.",
            "test_sql": "SELECT COUNT(*) FROM meeting_participants t1 JOIN user_preferences t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_participants",
            "from_column": "user_id",
            "to_table": "watchers",
            "to_column": "user_id",
            "condition": "meeting_participants.user_id = watchers.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a potential relationship where users who participate in meetings might also be watching certain entities. This relationship is based on the assumption that the 'user_id' in both tables refers to the same set of users, allowing for tracking of user activities across different contexts.",
            "test_sql": "SELECT COUNT(*) FROM meeting_participants t1 JOIN watchers t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "project_id",
            "to_table": "members",
            "to_column": "project_id",
            "condition": "meetings.project_id = members.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that meetings could be associated with projects, and members could be participants in those projects. This relationship aligns with common business logic where meetings are often linked to specific projects, and members are associated with those projects.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN members t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "author_id",
            "to_table": "news",
            "to_column": "author_id",
            "condition": "meetings.author_id = news.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, indicating that the same person could be responsible for organizing meetings and writing news articles. This relationship is plausible in scenarios where individuals have multiple roles, such as project managers or team leads.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN news t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "project_id",
            "to_table": "project_journals",
            "to_column": "id",
            "condition": "meetings.project_id = project_journals.id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'meetings' table suggests a potential linkage to the 'project_journals' table, where each meeting could be associated with a specific project journal entry. This relationship is inferred based on the common business logic of associating meetings with projects, and the compatible data types (both are 'bigint').",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN project_journals t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "project_id",
            "to_table": "news_journals",
            "to_column": "project_id",
            "condition": "meetings.project_id = news_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that meetings and news journals could be associated with the same projects. This relationship is based on the assumption that both tables are part of a larger system where projects are a common entity linking different activities.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN news_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "author_id",
            "to_table": "news_journals",
            "to_column": "author_id",
            "condition": "meetings.author_id = news_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, indicating that the same individuals might be responsible for organizing meetings and authoring news journals. This relationship is inferred based on the commonality of the field name and its typical use in identifying users or authors.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN news_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "project_id",
            "to_table": "projects_types",
            "to_column": "project_id",
            "condition": "meetings.project_id = projects_types.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'meetings' table suggests a potential link to the 'projects_types' table, which also contains a 'project_id' field. This relationship is based on the assumption that meetings are associated with projects, and the 'projects_types' table categorizes these projects. However, without explicit foreign key constraints or additional context, the confidence level is medium.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN projects_types t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "project_id",
            "to_table": "queries",
            "to_column": "project_id",
            "condition": "meetings.project_id = queries.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that meetings and queries can be associated with the same project. This relationship is logical in a project management context where meetings and queries are often linked to specific projects.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN queries t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 14,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "id",
            "to_table": "watchers",
            "to_column": "watchable_id",
            "condition": "meetings.id = watchers.watchable_id AND watchers.watchable_type = 'Meeting'",
            "confidence": "high",
            "reasoning": "The 'watchers' table is designed to track entities that users are monitoring. The 'watchable_id' field in 'watchers' can potentially refer to the 'id' field in 'meetings' if the 'watchable_type' is 'Meeting'. This suggests that users can watch meetings for updates or notifications.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN watchers t2 ON t1.id = t2.watchable_id WHERE t2.watchable_type = 'Meeting' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "author_id",
            "to_table": "wiki_page_journals",
            "to_column": "author_id",
            "condition": "meetings.author_id = wiki_page_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that the same authors or users might be involved in both meetings and wiki page journal entries. This relationship is based on the assumption that the 'author_id' represents the same entity in both tables, such as a user or employee within the organization.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN wiki_page_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "author_id",
            "to_table": "wiki_pages",
            "to_column": "author_id",
            "condition": "meetings.author_id = wiki_pages.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that meetings and wiki pages could be associated with the same author. This relationship is based on the assumption that the same individuals who organize meetings might also contribute to wiki pages. However, without explicit foreign key constraints or additional context, the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN wiki_pages t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "project_id",
            "to_table": "work_package_journals",
            "to_column": "project_id",
            "condition": "meetings.project_id = work_package_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that meetings and work package journals could be associated with the same projects. This relationship is based on the common business logic that meetings and work packages are often linked to specific projects.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN work_package_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 13,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "author_id",
            "to_table": "work_packages",
            "to_column": "author_id",
            "condition": "meetings.author_id = work_packages.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which could imply that the same person who organizes a meeting might also be responsible for creating or managing work packages. This relationship is based on the assumption that authors in both contexts are the same entities.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN work_packages t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "member_roles",
            "from_column": "role_id",
            "to_table": "workflows",
            "to_column": "role_id",
            "condition": "member_roles.role_id = workflows.role_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'role_id' field, which suggests a potential relationship where the roles assigned to members in 'member_roles' could be used to determine which workflows they are authorized to execute in 'workflows'. This aligns with the business logic of controlling access to workflow transitions based on user roles.",
            "test_sql": "SELECT COUNT(*) FROM member_roles t1 JOIN workflows t2 ON t1.role_id = t2.role_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1172,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "project_id",
            "to_table": "news",
            "to_column": "project_id",
            "condition": "members.project_id = news.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that news articles may be related to projects that members are associated with. This relationship is logical in a system where news updates are tied to specific projects, and members are participants in those projects.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN news t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "project_id",
            "to_table": "project_journals",
            "to_column": "id",
            "condition": "members.project_id = project_journals.id",
            "confidence": "high",
            "reasoning": "The 'project_id' in the 'members' table likely corresponds to the 'id' in the 'project_journals' table, suggesting that members are associated with specific projects. This relationship is inferred based on the naming convention and typical database design patterns where a foreign key in one table references the primary key of another table.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN project_journals t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "project_id",
            "to_table": "news_journals",
            "to_column": "project_id",
            "condition": "members.project_id = news_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that members might be associated with projects that have corresponding news journal entries. This relationship aligns with the business logic where members could be involved in projects that are documented in news journals.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN news_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "user_id",
            "to_table": "notification_settings",
            "to_column": "user_id",
            "condition": "members.user_id = notification_settings.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, suggesting that they may be related through the user entity. This relationship is logical as both tables involve user-specific data: 'members' tracks user participation in projects or entities, while 'notification_settings' manages user preferences for notifications. The relationship is not explicitly defined as a foreign key, but it aligns with common business logic where user-specific settings and memberships are linked.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN notification_settings t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "project_id",
            "to_table": "projects_types",
            "to_column": "project_id",
            "condition": "members.project_id = projects_types.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in both tables suggests a potential relationship where members are associated with projects that have specific types. This relationship is inferred based on the common field name and the business purpose of associating users with projects.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN projects_types t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "user_id",
            "to_table": "sessions",
            "to_column": "user_id",
            "condition": "members.user_id = sessions.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a potential relationship where a member's user ID can be linked to a session's user ID. This relationship is logical as it connects user membership details with their session activities, allowing for tracking of user interactions within projects or entities.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN sessions t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "project_id",
            "to_table": "queries",
            "to_column": "project_id",
            "condition": "members.project_id = queries.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that members and queries can be associated with the same project. This relationship is logical in a project management context where users (members) might create queries related to the projects they are involved in.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN queries t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "user_id",
            "to_table": "queries",
            "to_column": "user_id",
            "condition": "members.user_id = queries.user_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'user_id' field, indicating that the same user who is a member of a project might also create queries. This relationship is plausible in systems where users manage their own queries related to their memberships.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN queries t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 52,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "user_id",
            "to_table": "tokens",
            "to_column": "user_id",
            "condition": "members.user_id = tokens.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, suggesting a potential relationship where tokens are associated with users who are also members of projects or entities. This relationship is based on the common business logic that users can have tokens for authentication or authorization purposes while being members of projects or entities.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN tokens t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "project_id",
            "to_table": "versions",
            "to_column": "project_id",
            "condition": "members.project_id = versions.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that members are associated with projects, and versions are different releases of those projects. This implies a logical connection where members could be linked to specific versions of a project.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN versions t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "project_id",
            "to_table": "version_settings",
            "to_column": "project_id",
            "condition": "members.project_id = version_settings.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that they may be related through projects. The 'members' table associates users with projects, while the 'version_settings' table manages settings for different versions of projects. This relationship could be used to determine which users are associated with projects that have specific version settings.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN version_settings t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "user_id",
            "to_table": "wiki_page_journals",
            "to_column": "author_id",
            "condition": "members.user_id = wiki_page_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have fields that reference user-related identifiers ('user_id' in members and 'author_id' in wiki_page_journals). This suggests a potential relationship where a user who is a member of a project might also be an author of wiki page journals. The relationship is inferred based on naming conventions and the common practice of associating user actions across different entities.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN wiki_page_journals t2 ON t1.user_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "user_id",
            "to_table": "wiki_pages",
            "to_column": "author_id",
            "condition": "members.user_id = wiki_pages.author_id",
            "confidence": "high",
            "reasoning": "The 'user_id' in the 'members' table and 'author_id' in the 'wiki_pages' table both refer to users. It is plausible that a user who is a member of a project or entity could also be an author of a wiki page related to that project or entity. This relationship is based on the assumption that users in both tables are the same entities.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN wiki_pages t2 ON t1.user_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "user_id",
            "to_table": "watchers",
            "to_column": "user_id",
            "condition": "members.user_id = watchers.user_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'user_id' field, which suggests that they may be related through the users who are members of projects or entities and who are also watching certain entities. This relationship is based on the assumption that the same user can be both a member and a watcher, which is a common pattern in systems where users can participate in and monitor activities.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN watchers t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "project_id",
            "to_table": "work_package_hierarchies",
            "to_column": "ancestor_id",
            "condition": "members.project_id = work_package_hierarchies.ancestor_id",
            "confidence": "high",
            "reasoning": "The 'project_id' in the 'members' table could represent a work package that is part of a hierarchy in the 'work_package_hierarchies' table. This relationship is inferred based on the potential for projects to be organized into hierarchical structures, where a project could be an ancestor in a hierarchy.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN work_package_hierarchies t2 ON t1.project_id = t2.ancestor_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "project_id",
            "to_table": "work_packages",
            "to_column": "project_id",
            "condition": "members.project_id = work_packages.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that members are associated with projects, and work packages are tasks within those projects. This relationship aligns with common project management practices where users (members) are linked to projects and work packages are tasks within those projects.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN work_packages t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "user_id",
            "to_table": "work_package_journals",
            "to_column": "assigned_to_id",
            "condition": "members.user_id = work_package_journals.assigned_to_id",
            "confidence": "high",
            "reasoning": "The 'members' table includes a 'user_id' field, which likely represents users who are members of projects or entities. The 'work_package_journals' table has an 'assigned_to_id' field, which could represent users assigned to work packages. This relationship suggests that users who are members of a project might be assigned to work packages within that project.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN work_package_journals t2 ON t1.user_id = t2.assigned_to_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 72,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "menu_items",
            "from_column": "navigatable_id",
            "to_table": "wiki_pages",
            "to_column": "id",
            "condition": "menu_items.navigatable_id = wiki_pages.id",
            "confidence": "high",
            "reasoning": "The 'navigatable_id' in the 'menu_items' table suggests a potential link to entities that can be navigated to, such as wiki pages. The 'id' field in the 'wiki_pages' table is a likely candidate for this relationship, as it represents unique identifiers for each wiki page. This relationship would allow menu items to point directly to specific wiki pages, facilitating navigation within a content management system.",
            "test_sql": "SELECT COUNT(*) FROM menu_items t1 JOIN wiki_pages t2 ON t1.navigatable_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "project_id",
            "to_table": "project_journals",
            "to_column": "id",
            "condition": "news.project_id = project_journals.id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'news' table suggests a potential relationship with the 'id' field in the 'project_journals' table. This is based on the business purpose of the 'news' table, which involves associating news articles with specific projects. The 'project_journals' table represents projects, making it logical to link news items to projects via their IDs.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN project_journals t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "project_id",
            "to_table": "projects_types",
            "to_column": "project_id",
            "condition": "news.project_id = projects_types.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'news' table suggests a potential relationship with the 'projects_types' table, as both tables contain this field. This relationship could be used to associate news articles with specific project types, allowing for categorization or filtering of news based on project types.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN projects_types t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "project_id",
            "to_table": "queries",
            "to_column": "project_id",
            "condition": "news.project_id = queries.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that news articles and queries can be associated with the same project. This relationship is based on the common practice of linking records to projects in project management systems.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN queries t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "project_id",
            "to_table": "news_journals",
            "to_column": "project_id",
            "condition": "news.project_id = news_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that news articles and journal entries could be related to the same projects. This relationship is inferred based on the common field name and the business purpose of associating content with projects.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN news_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "author_id",
            "to_table": "news_journals",
            "to_column": "author_id",
            "condition": "news.author_id = news_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, indicating that news articles and journal entries might be authored by the same individuals. This relationship is inferred based on the common field name and the business purpose of linking content to authors.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN news_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "author_id",
            "to_table": "sessions",
            "to_column": "user_id",
            "condition": "news.author_id = sessions.user_id",
            "confidence": "high",
            "reasoning": "The 'author_id' in the 'news' table and 'user_id' in the 'sessions' table both represent user identifiers. It is plausible that authors of news articles are also users who have sessions in the system. This relationship is inferred based on the common use of user identifiers across different tables to link user-related data.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN sessions t2 ON t1.author_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "project_id",
            "to_table": "version_settings",
            "to_column": "project_id",
            "condition": "news.project_id = version_settings.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that news articles and version settings could be associated with the same projects. This relationship is inferred based on the common field name and the business purpose of associating news and version settings with projects.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN version_settings t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "author_id",
            "to_table": "wiki_page_journals",
            "to_column": "author_id",
            "condition": "news.author_id = wiki_page_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables contain an 'author_id' field, suggesting that news articles and wiki page journals may be authored by the same individuals. This relationship is based on the assumption that authors can contribute to both news articles and wiki page journals, even though there is no explicit foreign key constraint defined.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN wiki_page_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "project_id",
            "to_table": "versions",
            "to_column": "project_id",
            "condition": "news.project_id = versions.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that news articles and project versions could be related to the same project. This relationship is based on the assumption that news articles might be updates or announcements related to specific project versions.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN versions t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "author_id",
            "to_table": "wiki_pages",
            "to_column": "author_id",
            "condition": "news.author_id = wiki_pages.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that news articles and wiki pages could be authored by the same individuals. This relationship is based on the assumption that the same authors contribute to both news articles and wiki pages, which is a common pattern in content management systems.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN wiki_pages t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "author_id",
            "to_table": "work_package_journals",
            "to_column": "author_id",
            "condition": "news.author_id = work_package_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which could indicate that the same authors or users are responsible for creating entries in both tables. This relationship is plausible in systems where users can create both news articles and work package journals.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN work_package_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 72,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "project_id",
            "to_table": "project_journals",
            "to_column": "id",
            "condition": "news_journals.project_id = project_journals.id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'news_journals' table suggests a potential linkage to the 'project_journals' table, where each news journal entry is associated with a specific project. The 'id' field in 'project_journals' is a likely candidate for this relationship as it uniquely identifies each project.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN project_journals t2 ON t1.project_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "project_id",
            "to_table": "projects_types",
            "to_column": "project_id",
            "condition": "news_journals.project_id = projects_types.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in both tables suggests a potential relationship where news journal entries are associated with projects that can have multiple types. This relationship is inferred based on the shared field name and the business purpose of categorizing projects.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN projects_types t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "project_id",
            "to_table": "queries",
            "to_column": "project_id",
            "condition": "news_journals.project_id = queries.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that news journal entries and queries may be associated with the same projects. This relationship is plausible in a system where both news content and queries are organized by project.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN queries t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "project_id",
            "to_table": "versions",
            "to_column": "project_id",
            "condition": "news_journals.project_id = versions.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that news journal entries and project versions might be associated with the same projects. This relationship is inferred based on the common field name and the business purpose of tracking project-related information.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN versions t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "project_id",
            "to_table": "version_settings",
            "to_column": "project_id",
            "condition": "news_journals.project_id = version_settings.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that entries in 'news_journals' could be related to specific projects that have version settings in 'version_settings'. This relationship is based on the assumption that both tables are part of a larger system managing projects, where news articles and version settings are linked to the same projects.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN version_settings t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "author_id",
            "to_table": "wiki_pages",
            "to_column": "author_id",
            "condition": "news_journals.author_id = wiki_pages.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that the same author could be responsible for both news journal entries and wiki pages. This relationship is based on the assumption that authors contribute to both types of content, although there is no explicit foreign key constraint linking them.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN wiki_pages t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "author_id",
            "to_table": "wiki_page_journals",
            "to_column": "author_id",
            "condition": "news_journals.author_id = wiki_page_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, suggesting that entries in both tables could be associated with the same author. This relationship is based on the assumption that the same authors contribute to both news journals and wiki page journals.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN wiki_page_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "project_id",
            "to_table": "work_packages",
            "to_column": "project_id",
            "condition": "news_journals.project_id = work_packages.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that news journal entries and work packages may be associated with the same projects. This relationship is based on the assumption that both tables are part of a larger project management system where news articles and work tasks are linked to projects.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN work_packages t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "project_id",
            "to_table": "work_package_journals",
            "to_column": "project_id",
            "condition": "news_journals.project_id = work_package_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that journal entries in both tables could be associated with the same projects. This relationship is based on the common business logic that both news articles and work packages can be part of a project.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN work_package_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "notification_settings",
            "from_column": "user_id",
            "to_table": "sessions",
            "to_column": "user_id",
            "condition": "notification_settings.user_id = sessions.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a potential relationship where notification settings are associated with user sessions. This relationship is based on the assumption that both tables are tracking data related to users, and the 'user_id' serves as a common link. However, since the 'sessions' table does not explicitly define 'user_id' as a foreign key, the confidence level is medium.",
            "test_sql": "SELECT COUNT(*) FROM notification_settings t1 JOIN sessions t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "notification_settings",
            "from_column": "user_id",
            "to_table": "queries",
            "to_column": "user_id",
            "condition": "notification_settings.user_id = queries.user_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'user_id' field, suggesting that notification settings and queries could be associated with the same user. This relationship is logical as users might have specific notification settings and queries related to their activities or preferences within a project management system.",
            "test_sql": "SELECT COUNT(*) FROM notification_settings t1 JOIN queries t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "notification_settings",
            "from_column": "user_id",
            "to_table": "watchers",
            "to_column": "user_id",
            "condition": "notification_settings.user_id = watchers.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests that they may be related through the users who have notification settings and are also watching certain entities. This relationship is logical given the business purposes of both tables, where user-specific actions and preferences are tracked.",
            "test_sql": "SELECT COUNT(*) FROM notification_settings t1 JOIN watchers t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "project_journals",
            "from_column": "identifier",
            "to_table": "projects",
            "to_column": "identifier",
            "condition": "project_journals.identifier = projects.identifier",
            "confidence": "high",
            "reasoning": "Both tables have an 'identifier' field which is marked as NOT NULL and likely serves as a unique identifier for projects. This suggests a potential logical relationship where project journals are associated with projects through a common identifier.",
            "test_sql": "SELECT COUNT(*) FROM project_journals t1 JOIN projects t2 ON t1.identifier = t2.identifier LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "ordered_work_packages",
            "from_column": "work_package_id",
            "to_table": "work_package_journals",
            "to_column": "id",
            "condition": "ordered_work_packages.work_package_id = work_package_journals.id",
            "confidence": "high",
            "reasoning": "The 'work_package_id' in 'ordered_work_packages' could logically correspond to the 'id' in 'work_package_journals' as both tables are related to work packages. This relationship is inferred based on the naming convention and the business purpose of tracking and managing work packages.",
            "test_sql": "SELECT COUNT(*) FROM ordered_work_packages t1 JOIN work_package_journals t2 ON t1.work_package_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "project_journals",
            "from_column": "id",
            "to_table": "queries",
            "to_column": "project_id",
            "condition": "project_journals.id = queries.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in the 'queries' table suggests a linkage to a project-related table. Given the business purpose of 'project_journals' as a system for managing projects, it is reasonable to infer that 'queries' might be associated with specific project journals. The data types are compatible, and this follows common database design patterns where queries are linked to projects.",
            "test_sql": "SELECT COUNT(*) FROM project_journals t1 JOIN queries t2 ON t1.id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "ordered_work_packages",
            "from_column": "work_package_id",
            "to_table": "work_package_hierarchies",
            "to_column": "ancestor_id",
            "condition": "ordered_work_packages.work_package_id = work_package_hierarchies.ancestor_id",
            "confidence": "high",
            "reasoning": "The 'work_package_id' in 'ordered_work_packages' likely corresponds to a work package that could be an ancestor in the 'work_package_hierarchies' table. This relationship makes sense as it allows for the identification of hierarchical structures starting from a specific work package.",
            "test_sql": "SELECT COUNT(*) FROM ordered_work_packages t1 JOIN work_package_hierarchies t2 ON t1.work_package_id = t2.ancestor_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 17,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "ordered_work_packages",
            "from_column": "work_package_id",
            "to_table": "work_package_hierarchies",
            "to_column": "descendant_id",
            "condition": "ordered_work_packages.work_package_id = work_package_hierarchies.descendant_id",
            "confidence": "high",
            "reasoning": "The 'work_package_id' in 'ordered_work_packages' could also correspond to a work package that is a descendant in the 'work_package_hierarchies' table. This relationship is plausible as it allows for the exploration of hierarchical structures where a specific work package is a descendant.",
            "test_sql": "SELECT COUNT(*) FROM ordered_work_packages t1 JOIN work_package_hierarchies t2 ON t1.work_package_id = t2.descendant_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 14,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "project_journals",
            "from_column": "id",
            "to_table": "relations",
            "to_column": "to_id",
            "condition": "project_journals.id = relations.to_id",
            "confidence": "high",
            "reasoning": "Similar to the 'from_id' relationship, 'to_id' could also reference the 'id' of a project in 'project_journals', indicating a connection or dependency between projects.",
            "test_sql": "SELECT COUNT(*) FROM project_journals t1 JOIN relations t2 ON t1.id = t2.to_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "project_journals",
            "from_column": "id",
            "to_table": "version_settings",
            "to_column": "project_id",
            "condition": "project_journals.id = version_settings.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in 'version_settings' suggests a linkage to a project entity, which could be represented by the 'project_journals' table. This relationship is inferred based on the naming convention and typical database design patterns where settings are associated with specific projects.",
            "test_sql": "SELECT COUNT(*) FROM project_journals t1 JOIN version_settings t2 ON t1.id = t2.project_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "project_journals",
            "from_column": "id",
            "to_table": "watchers",
            "to_column": "watchable_id",
            "condition": "project_journals.id = watchers.watchable_id",
            "confidence": "high",
            "reasoning": "The 'watchable_id' field in the 'watchers' table is likely intended to reference the primary key of a table that represents an entity being watched. Given the business purpose of the 'project_journals' table, it is plausible that projects are one of the entities that users can watch, making 'project_journals.id' a potential match for 'watchable_id'.",
            "test_sql": "SELECT COUNT(*) FROM project_journals t1 JOIN watchers t2 ON t1.id = t2.watchable_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "project_journals",
            "from_column": "id",
            "to_table": "work_packages",
            "to_column": "project_id",
            "condition": "project_journals.id = work_packages.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' in the 'work_packages' table likely corresponds to the 'id' in the 'project_journals' table, as work packages are typically associated with specific projects. This relationship is inferred based on the common practice of linking tasks or work items to projects.",
            "test_sql": "SELECT COUNT(*) FROM project_journals t1 JOIN work_packages t2 ON t1.id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "project_journals",
            "from_column": "id",
            "to_table": "work_package_hierarchies",
            "to_column": "ancestor_id",
            "condition": "project_journals.id = work_package_hierarchies.ancestor_id",
            "confidence": "high",
            "reasoning": "The 'project_journals' table represents projects, and the 'work_package_hierarchies' table represents hierarchical relationships between work packages. It is plausible that a project journal could be linked to a work package hierarchy as an ancestor, representing the project as a top-level entity in the hierarchy.",
            "test_sql": "SELECT COUNT(*) FROM project_journals t1 JOIN work_package_hierarchies t2 ON t1.id = t2.ancestor_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "project_journals",
            "from_column": "id",
            "to_table": "work_package_hierarchies",
            "to_column": "descendant_id",
            "condition": "project_journals.id = work_package_hierarchies.descendant_id",
            "confidence": "high",
            "reasoning": "Similar to the ancestor relationship, a project journal could be linked to a work package hierarchy as a descendant, representing the project as a sub-entity within a larger hierarchical structure.",
            "test_sql": "SELECT COUNT(*) FROM project_journals t1 JOIN work_package_hierarchies t2 ON t1.id = t2.descendant_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "projects",
            "from_column": "id",
            "to_table": "relations",
            "to_column": "to_id",
            "condition": "projects.id = relations.to_id",
            "confidence": "high",
            "reasoning": "Similarly, 'to_id' in the 'relations' table could reference the 'id' of a project, indicating that a project can be the endpoint of a relation. This relationship suggests that projects can be interconnected through relations.",
            "test_sql": "SELECT COUNT(*) FROM projects t1 JOIN relations t2 ON t1.id = t2.to_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "projects",
            "from_column": "id",
            "to_table": "wiki_pages",
            "to_column": "wiki_id",
            "condition": "projects.id = wiki_pages.wiki_id",
            "confidence": "high",
            "reasoning": "The 'wiki_id' field in the 'wiki_pages' table could potentially reference the 'id' field in the 'projects' table, suggesting that each project might have an associated wiki for documentation or collaboration purposes. This is a common pattern where projects have related documentation.",
            "test_sql": "SELECT COUNT(*) FROM projects t1 JOIN wiki_pages t2 ON t1.id = t2.wiki_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "projects_types",
            "from_column": "project_id",
            "to_table": "queries",
            "to_column": "project_id",
            "condition": "projects_types.project_id = queries.project_id",
            "confidence": "high",
            "reasoning": "The 'project_id' field in both tables suggests a potential relationship where queries are associated with specific projects. This relationship is logical given that queries might be used to analyze or report on data related to specific projects. However, since the 'project_id' in the 'queries' table is nullable, it indicates that not all queries are necessarily tied to a project, which slightly lowers the confidence level.",
            "test_sql": "SELECT COUNT(*) FROM projects_types t1 JOIN queries t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 114,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "projects_types",
            "from_column": "project_id",
            "to_table": "version_settings",
            "to_column": "project_id",
            "condition": "projects_types.project_id = version_settings.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting a potential relationship where version settings are associated with specific projects. This aligns with the business purpose of managing project versions and their types.",
            "test_sql": "SELECT COUNT(*) FROM projects_types t1 JOIN version_settings t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 24,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "projects_types",
            "from_column": "type_id",
            "to_table": "workflows",
            "to_column": "type_id",
            "condition": "projects_types.type_id = workflows.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' field, which suggests a potential relationship based on the categorization or classification of projects and workflows. This relationship could be used to associate workflows with specific types of projects, allowing for the management of workflow transitions based on project types.",
            "test_sql": "SELECT COUNT(*) FROM projects_types t1 JOIN workflows t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1764,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "projects_types",
            "from_column": "type_id",
            "to_table": "work_packages",
            "to_column": "type_id",
            "condition": "projects_types.type_id = work_packages.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' field that references the 'types' table. This suggests a potential relationship where work packages are categorized by type, and projects can be associated with these types. This relationship is plausible given the need to categorize both projects and work packages by type.",
            "test_sql": "SELECT COUNT(*) FROM projects_types t1 JOIN work_packages t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 58,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "projects_types",
            "from_column": "type_id",
            "to_table": "work_package_journals",
            "to_column": "type_id",
            "condition": "projects_types.type_id = work_package_journals.type_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'type_id' field, which suggests a potential relationship based on the type of project or work package. This relationship might exist if the types in 'projects_types' are used to categorize work packages in 'work_package_journals'.",
            "test_sql": "SELECT COUNT(*) FROM projects_types t1 JOIN work_package_journals t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 58,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "queries",
            "from_column": "user_id",
            "to_table": "sessions",
            "to_column": "user_id",
            "condition": "queries.user_id = sessions.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a potential relationship where queries are associated with the sessions of the users who created them. This relationship is based on the assumption that user activity in creating or managing queries might be tracked through sessions.",
            "test_sql": "SELECT COUNT(*) FROM queries t1 JOIN sessions t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "queries",
            "from_column": "user_id",
            "to_table": "tokens",
            "to_column": "user_id",
            "condition": "queries.user_id = tokens.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a potential relationship based on the user who created the query and the user associated with the token. This relationship is logical given that tokens are often used for user authentication and queries are created by users.",
            "test_sql": "SELECT COUNT(*) FROM queries t1 JOIN tokens t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "queries",
            "from_column": "user_id",
            "to_table": "user_passwords",
            "to_column": "user_id",
            "condition": "queries.user_id = user_passwords.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a potential relationship between the queries created by users and their corresponding password records. This relationship is likely based on the assumption that each query is associated with a user, and the user_passwords table stores authentication details for users. However, without explicit foreign key constraints, the confidence level is medium.",
            "test_sql": "SELECT COUNT(*) FROM queries t1 JOIN user_passwords t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 26,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "queries",
            "from_column": "project_id",
            "to_table": "version_settings",
            "to_column": "project_id",
            "condition": "queries.project_id = version_settings.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that queries and version settings may be associated with the same project. This relationship is plausible in a system where queries are defined within the context of a project, and version settings are used to manage different versions of that project.",
            "test_sql": "SELECT COUNT(*) FROM queries t1 JOIN version_settings t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 48,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "queries",
            "from_column": "project_id",
            "to_table": "versions",
            "to_column": "project_id",
            "condition": "queries.project_id = versions.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that queries and versions are associated with specific projects. This is a common pattern in project management systems where different entities are linked to projects.",
            "test_sql": "SELECT COUNT(*) FROM queries t1 JOIN versions t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 48,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "queries",
            "from_column": "user_id",
            "to_table": "watchers",
            "to_column": "user_id",
            "condition": "queries.user_id = watchers.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a potential relationship where users who create queries might also be watching certain entities. This relationship is based on the assumption that the same user can be involved in both creating queries and watching entities.",
            "test_sql": "SELECT COUNT(*) FROM queries t1 JOIN watchers t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 78,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "queries",
            "from_column": "project_id",
            "to_table": "work_package_journals",
            "to_column": "project_id",
            "condition": "queries.project_id = work_package_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that queries and work package journals may be associated with the same projects. This relationship is common in project management systems where different entities are linked to projects.",
            "test_sql": "SELECT COUNT(*) FROM queries t1 JOIN work_package_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 458,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "relations",
            "from_column": "to_id",
            "to_table": "users",
            "to_column": "id",
            "condition": "relations.to_id = users.id",
            "confidence": "high",
            "reasoning": "The 'to_id' in the 'relations' table could represent a user who is the target or recipient of a relationship or connection, which aligns with the 'id' field in the 'users' table. This is a common pattern where user IDs are used to track relationships directed towards users.",
            "test_sql": "SELECT COUNT(*) FROM relations t1 JOIN users t2 ON t1.to_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "relations",
            "from_column": "from_id",
            "to_table": "work_package_hierarchies",
            "to_column": "ancestor_id",
            "condition": "relations.from_id = work_package_hierarchies.ancestor_id",
            "confidence": "high",
            "reasoning": "The 'from_id' in the 'relations' table could represent a starting point or parent entity, which aligns with the 'ancestor_id' in the 'work_package_hierarchies' table. This suggests a potential hierarchical or dependency relationship where a 'from_id' in 'relations' might correspond to an 'ancestor_id' in 'work_package_hierarchies'.",
            "test_sql": "SELECT COUNT(*) FROM relations t1 JOIN work_package_hierarchies t2 ON t1.from_id = t2.ancestor_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "relations",
            "from_column": "to_id",
            "to_table": "work_package_hierarchies",
            "to_column": "descendant_id",
            "condition": "relations.to_id = work_package_hierarchies.descendant_id",
            "confidence": "high",
            "reasoning": "The 'to_id' in the 'relations' table could represent a target or child entity, which aligns with the 'descendant_id' in the 'work_package_hierarchies' table. This suggests a potential hierarchical or dependency relationship where a 'to_id' in 'relations' might correspond to a 'descendant_id' in 'work_package_hierarchies'.",
            "test_sql": "SELECT COUNT(*) FROM relations t1 JOIN work_package_hierarchies t2 ON t1.to_id = t2.descendant_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "relations",
            "from_column": "from_id",
            "to_table": "work_packages",
            "to_column": "id",
            "condition": "relations.from_id = work_packages.id",
            "confidence": "high",
            "reasoning": "The 'from_id' in the 'relations' table could represent a work package that is the starting point of a relationship. This aligns with the business purpose of tracking dependencies or connections between tasks or work packages.",
            "test_sql": "SELECT COUNT(*) FROM relations t1 JOIN work_packages t2 ON t1.from_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "relations",
            "from_column": "to_id",
            "to_table": "work_packages",
            "to_column": "id",
            "condition": "relations.to_id = work_packages.id",
            "confidence": "high",
            "reasoning": "The 'to_id' in the 'relations' table could represent a work package that is the endpoint of a relationship. This is consistent with the idea of mapping dependencies or sequences between work packages.",
            "test_sql": "SELECT COUNT(*) FROM relations t1 JOIN work_packages t2 ON t1.to_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "sessions",
            "from_column": "user_id",
            "to_table": "tokens",
            "to_column": "user_id",
            "condition": "sessions.user_id = tokens.user_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'user_id' column, suggesting a potential relationship where sessions and tokens are associated with the same user. This is a common pattern in systems where user sessions and authentication tokens are managed separately but linked to the same user.",
            "test_sql": "SELECT COUNT(*) FROM sessions t1 JOIN tokens t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "sessions",
            "from_column": "user_id",
            "to_table": "user_passwords",
            "to_column": "user_id",
            "condition": "sessions.user_id = user_passwords.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a potential relationship where sessions are associated with user accounts. This relationship is logical in the context of user management, where sessions are linked to users who have password entries. However, without explicit foreign key constraints, the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM sessions t1 JOIN user_passwords t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "sessions",
            "from_column": "user_id",
            "to_table": "watchers",
            "to_column": "user_id",
            "condition": "sessions.user_id = watchers.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a potential relationship where sessions are associated with users who are also watching certain entities. This relationship is based on the assumption that the same user can have sessions and can also be a watcher of certain items.",
            "test_sql": "SELECT COUNT(*) FROM sessions t1 JOIN watchers t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "tokens",
            "from_column": "user_id",
            "to_table": "watchers",
            "to_column": "user_id",
            "condition": "tokens.user_id = watchers.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, suggesting a potential relationship where tokens and watchers are associated with the same user. This aligns with common database design patterns where user-related activities are tracked across different tables.",
            "test_sql": "SELECT COUNT(*) FROM tokens t1 JOIN watchers t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "user_passwords",
            "from_column": "user_id",
            "to_table": "watchers",
            "to_column": "user_id",
            "condition": "user_passwords.user_id = watchers.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a potential relationship where the 'user_passwords' table associates password information with users, and the 'watchers' table tracks which entities those users are monitoring. This relationship is inferred based on the common field name and the typical database design pattern where user-related tables share a 'user_id' field.",
            "test_sql": "SELECT COUNT(*) FROM user_passwords t1 JOIN watchers t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "user_preferences",
            "from_column": "user_id",
            "to_table": "watchers",
            "to_column": "user_id",
            "condition": "user_preferences.user_id = watchers.user_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'user_id' field, which suggests a potential relationship where user preferences might be relevant to the entities they are watching. This relationship could be used to personalize notifications or updates based on user preferences.",
            "test_sql": "SELECT COUNT(*) FROM user_preferences t1 JOIN watchers t2 ON t1.user_id = t2.user_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "users",
            "from_column": "id",
            "to_table": "wiki_page_journals",
            "to_column": "author_id",
            "condition": "users.id = wiki_page_journals.author_id",
            "confidence": "high",
            "reasoning": "The 'author_id' field in the 'wiki_page_journals' table suggests a potential relationship with the 'users' table, as it is common for journal or log entries to be associated with user accounts. The 'id' field in the 'users' table is a likely candidate for this relationship, as it is a primary key and uniquely identifies each user.",
            "test_sql": "SELECT COUNT(*) FROM users t1 JOIN wiki_page_journals t2 ON t1.id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "version_settings",
            "from_column": "project_id",
            "to_table": "versions",
            "to_column": "project_id",
            "condition": "version_settings.project_id = versions.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that settings and versions are associated with specific projects. This relationship is logical as it allows for filtering or grouping settings and versions by project.",
            "test_sql": "SELECT COUNT(*) FROM version_settings t1 JOIN versions t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "users",
            "from_column": "id",
            "to_table": "work_package_journals",
            "to_column": "author_id",
            "condition": "users.id = work_package_journals.author_id",
            "confidence": "high",
            "reasoning": "The 'author_id' field in the 'work_package_journals' table likely refers to the user who created or last modified the work package journal entry. Given that 'id' is a primary key in the 'users' table, it is reasonable to infer that 'author_id' could reference 'users.id'. This relationship is common in systems where users are responsible for creating or updating records.",
            "test_sql": "SELECT COUNT(*) FROM users t1 JOIN work_package_journals t2 ON t1.id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "users",
            "from_column": "id",
            "to_table": "work_package_journals",
            "to_column": "assigned_to_id",
            "condition": "users.id = work_package_journals.assigned_to_id",
            "confidence": "high",
            "reasoning": "The 'assigned_to_id' field in the 'work_package_journals' table likely refers to the user to whom the work package is assigned. Since 'id' is a primary key in the 'users' table, it is plausible that 'assigned_to_id' could reference 'users.id'. This is a common pattern in project management systems where tasks or work packages are assigned to users.",
            "test_sql": "SELECT COUNT(*) FROM users t1 JOIN work_package_journals t2 ON t1.id = t2.assigned_to_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "version_settings",
            "from_column": "project_id",
            "to_table": "wikis",
            "to_column": "project_id",
            "condition": "version_settings.project_id = wikis.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, suggesting that they may be related through a common project. This relationship is logical given that version settings and wikis could both be associated with specific projects, even though there is no explicit foreign key constraint defined.",
            "test_sql": "SELECT COUNT(*) FROM version_settings t1 JOIN wikis t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "users",
            "from_column": "id",
            "to_table": "work_packages",
            "to_column": "assigned_to_id",
            "condition": "users.id = work_packages.assigned_to_id",
            "confidence": "high",
            "reasoning": "The 'assigned_to_id' field in the 'work_packages' table likely refers to a user who is responsible for or assigned to a specific work package. The 'id' field in the 'users' table is a unique identifier for each user, making it a plausible candidate for this relationship.",
            "test_sql": "SELECT COUNT(*) FROM users t1 JOIN work_packages t2 ON t1.id = t2.assigned_to_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "users",
            "from_column": "id",
            "to_table": "work_packages",
            "to_column": "author_id",
            "condition": "users.id = work_packages.author_id",
            "confidence": "high",
            "reasoning": "The 'author_id' field in the 'work_packages' table likely refers to the user who created or authored the work package. The 'id' field in the 'users' table serves as a unique identifier for users, making it a logical match for this relationship.",
            "test_sql": "SELECT COUNT(*) FROM users t1 JOIN work_packages t2 ON t1.id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "version_settings",
            "from_column": "version_id",
            "to_table": "work_package_journals",
            "to_column": "version_id",
            "condition": "version_settings.version_id = work_package_journals.version_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'version_id' field, suggesting a potential relationship where work package journals are associated with specific version settings. This could be useful for tracking changes or updates to work packages that are relevant to particular versions of a project.",
            "test_sql": "SELECT COUNT(*) FROM version_settings t1 JOIN work_package_journals t2 ON t1.version_id = t2.version_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "version_settings",
            "from_column": "project_id",
            "to_table": "work_package_journals",
            "to_column": "project_id",
            "condition": "version_settings.project_id = work_package_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, indicating a potential relationship where version settings are linked to work package journals within the same project. This relationship can help in managing and configuring project-specific settings and tracking work packages associated with those projects.",
            "test_sql": "SELECT COUNT(*) FROM version_settings t1 JOIN work_package_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 92,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "version_settings",
            "from_column": "version_id",
            "to_table": "work_packages",
            "to_column": "version_id",
            "condition": "version_settings.version_id = work_packages.version_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'version_id' field, suggesting a potential relationship where work packages are associated with specific version settings. This relationship could be used to track which work packages are relevant to particular versions of a project.",
            "test_sql": "SELECT COUNT(*) FROM version_settings t1 JOIN work_packages t2 ON t1.version_id = t2.version_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "version_settings",
            "from_column": "project_id",
            "to_table": "work_packages",
            "to_column": "project_id",
            "condition": "version_settings.project_id = work_packages.project_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'project_id' field, indicating a potential relationship where version settings are linked to work packages within the same project. This relationship could be used to manage and display work packages according to the version settings of the project they belong to.",
            "test_sql": "SELECT COUNT(*) FROM version_settings t1 JOIN work_packages t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 92,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "versions",
            "from_column": "wiki_page_title",
            "to_table": "wiki_pages",
            "to_column": "title",
            "condition": "versions.wiki_page_title = wiki_pages.title",
            "confidence": "high",
            "reasoning": "The 'wiki_page_title' field in the 'versions' table suggests a potential link to the 'title' field in the 'wiki_pages' table. This relationship is based on the assumption that each version may have associated documentation or notes stored in a wiki page, and the title of the wiki page could match the 'wiki_page_title' in the 'versions' table.",
            "test_sql": "SELECT COUNT(*) FROM versions t1 JOIN wiki_pages t2 ON t1.wiki_page_title = t2.title LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "versions",
            "from_column": "id",
            "to_table": "work_packages",
            "to_column": "version_id",
            "condition": "versions.id = work_packages.version_id",
            "confidence": "high",
            "reasoning": "The 'version_id' field in the 'work_packages' table suggests a potential relationship with the 'versions' table, where each work package could be associated with a specific version of a project. This is a common pattern in project management systems where tasks or work packages are linked to specific versions or releases.",
            "test_sql": "SELECT COUNT(*) FROM versions t1 JOIN work_packages t2 ON t1.id = t2.version_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "watchers",
            "from_column": "watchable_id",
            "to_table": "wikis",
            "to_column": "id",
            "condition": "watchers.watchable_id = wikis.id",
            "confidence": "high",
            "reasoning": "The 'watchable_id' in the 'watchers' table could potentially refer to the 'id' of a wiki in the 'wikis' table, especially if wikis are one of the entities that users can watch. This is supported by the polymorphic nature of the 'watchable_type' field, which might include 'wiki' as a type.",
            "test_sql": "SELECT COUNT(*) FROM watchers t1 JOIN wikis t2 ON t1.watchable_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "watchers",
            "from_column": "watchable_id",
            "to_table": "work_package_journals",
            "to_column": "id",
            "condition": "watchers.watchable_id = work_package_journals.id",
            "confidence": "high",
            "reasoning": "The 'watchable_id' in the 'watchers' table could potentially refer to the 'id' of a work package in the 'work_package_journals' table. This is based on the business logic that users might want to watch specific work packages for updates. However, the 'watchable_type' field in the 'watchers' table would need to indicate that the entity being watched is a work package, which is not explicitly defined in the schema.",
            "test_sql": "SELECT COUNT(*) FROM watchers t1 JOIN work_package_journals t2 ON t1.watchable_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "watchers",
            "from_column": "watchable_id",
            "to_table": "wiki_pages",
            "to_column": "id",
            "condition": "watchers.watchable_id = wiki_pages.id",
            "confidence": "high",
            "reasoning": "The 'watchable_id' in the 'watchers' table could correspond to the 'id' of a 'wiki_pages' entry, suggesting that users might be watching specific wiki pages for updates. This relationship is inferred based on the business purpose of tracking entities that users are monitoring, and the 'wiki_pages' table representing a collection of pages that could be monitored.",
            "test_sql": "SELECT COUNT(*) FROM watchers t1 JOIN wiki_pages t2 ON t1.watchable_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "wiki_page_journals",
            "from_column": "author_id",
            "to_table": "wiki_pages",
            "to_column": "author_id",
            "condition": "wiki_page_journals.author_id = wiki_pages.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests a potential relationship where journal entries are linked to the pages authored by the same user. This relationship is based on the assumption that the 'author_id' in both tables refers to the same entity, likely a user or author.",
            "test_sql": "SELECT COUNT(*) FROM wiki_page_journals t1 JOIN wiki_pages t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "wiki_page_journals",
            "from_column": "author_id",
            "to_table": "work_packages",
            "to_column": "author_id",
            "condition": "wiki_page_journals.author_id = work_packages.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that entries in the 'wiki_page_journals' table could be related to work packages authored by the same individual. This relationship is based on the assumption that the 'author_id' represents the same entity in both tables.",
            "test_sql": "SELECT COUNT(*) FROM wiki_page_journals t1 JOIN work_packages t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "wiki_page_journals",
            "from_column": "author_id",
            "to_table": "work_package_journals",
            "to_column": "author_id",
            "condition": "wiki_page_journals.author_id = work_package_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which suggests that entries in both tables could be associated with the same author. This relationship is based on the assumption that the 'author_id' represents the same entity in both tables, such as a user or author who is responsible for creating or modifying entries.",
            "test_sql": "SELECT COUNT(*) FROM wiki_page_journals t1 JOIN work_package_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "wikis",
            "from_column": "project_id",
            "to_table": "work_package_journals",
            "to_column": "project_id",
            "condition": "wikis.project_id = work_package_journals.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, suggesting that wikis and work package journals are associated with projects. This relationship is based on the common business logic that both wikis and work packages are likely linked to specific projects, allowing for documentation and task tracking within the same project context.",
            "test_sql": "SELECT COUNT(*) FROM wikis t1 JOIN work_package_journals t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "work_package_hierarchies",
            "from_column": "ancestor_id",
            "to_table": "work_package_journals",
            "to_column": "id",
            "condition": "work_package_hierarchies.ancestor_id = work_package_journals.id",
            "confidence": "high",
            "reasoning": "The 'ancestor_id' in 'work_package_hierarchies' likely represents a work package that could be detailed in 'work_package_journals'. The 'id' field in 'work_package_journals' is a primary key that uniquely identifies each work package journal entry. This relationship suggests that the ancestor work package is documented in the journals.",
            "test_sql": "SELECT COUNT(*) FROM work_package_hierarchies t1 JOIN work_package_journals t2 ON t1.ancestor_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 24,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "work_package_hierarchies",
            "from_column": "descendant_id",
            "to_table": "work_package_journals",
            "to_column": "id",
            "condition": "work_package_hierarchies.descendant_id = work_package_journals.id",
            "confidence": "high",
            "reasoning": "The 'descendant_id' in 'work_package_hierarchies' likely represents a sub-package or task that could be detailed in 'work_package_journals'. The 'id' field in 'work_package_journals' is a primary key that uniquely identifies each work package journal entry. This relationship suggests that the descendant work package is documented in the journals.",
            "test_sql": "SELECT COUNT(*) FROM work_package_hierarchies t1 JOIN work_package_journals t2 ON t1.descendant_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 28,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "work_packages",
            "from_column": "type_id",
            "to_table": "workflows",
            "to_column": "type_id",
            "condition": "work_packages.type_id = workflows.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' field, suggesting that workflows may be defined for specific types of work packages. This relationship is based on the assumption that workflows are used to manage transitions for work packages of specific types.",
            "test_sql": "SELECT COUNT(*) FROM work_packages t1 JOIN workflows t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7398,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "work_package_journals",
            "from_column": "type_id",
            "to_table": "workflows",
            "to_column": "type_id",
            "condition": "work_package_journals.type_id = workflows.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' field, which suggests a potential relationship based on the type of work package and the type of workflow. This could imply that workflows are defined for specific types of work packages.",
            "test_sql": "SELECT COUNT(*) FROM work_package_journals t1 JOIN workflows t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7398,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "work_package_journals",
            "from_column": "status_id",
            "to_table": "workflows",
            "to_column": "old_status_id",
            "condition": "work_package_journals.status_id = workflows.old_status_id",
            "confidence": "high",
            "reasoning": "The 'status_id' in 'work_package_journals' could correspond to the 'old_status_id' in 'workflows', indicating that a workflow transition might be applicable to work packages currently in a specific status.",
            "test_sql": "SELECT COUNT(*) FROM work_package_journals t1 JOIN workflows t2 ON t1.status_id = t2.old_status_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 5295,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "work_package_journals",
            "from_column": "project_id",
            "to_table": "work_packages",
            "to_column": "project_id",
            "condition": "work_package_journals.project_id = work_packages.project_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'project_id' field, which suggests that work package journals are associated with specific projects, similar to work packages. This relationship is common in project management systems where changes to work packages are tracked within the context of a project.",
            "test_sql": "SELECT COUNT(*) FROM work_package_journals t1 JOIN work_packages t2 ON t1.project_id = t2.project_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 698,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "work_package_journals",
            "from_column": "type_id",
            "to_table": "work_packages",
            "to_column": "type_id",
            "condition": "work_package_journals.type_id = work_packages.type_id",
            "confidence": "high",
            "reasoning": "The 'type_id' field in both tables indicates the type of work package. This suggests a logical relationship where journals track changes to work packages of specific types, aligning with the business logic of managing different types of work packages.",
            "test_sql": "SELECT COUNT(*) FROM work_package_journals t1 JOIN work_packages t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 308,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "work_package_journals",
            "from_column": "status_id",
            "to_table": "work_packages",
            "to_column": "status_id",
            "condition": "work_package_journals.status_id = work_packages.status_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'status_id' field, which suggests that the status of work packages is tracked in both the current state and historical changes. This relationship is logical in systems where the status of work packages is a key attribute being monitored.",
            "test_sql": "SELECT COUNT(*) FROM work_package_journals t1 JOIN work_packages t2 ON t1.status_id = t2.status_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 258,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "author_id",
            "to_table": "attachments",
            "to_column": "author_id",
            "condition": "attachment_journals.author_id = attachments.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which could imply that the same author or user is responsible for creating or uploading attachments in both tables. However, without additional context or a common user table, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN attachments t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "attachment_journals",
            "from_column": "author_id",
            "to_table": "work_packages",
            "to_column": "author_id",
            "condition": "attachment_journals.author_id = work_packages.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which could suggest a relationship where attachments are linked to work packages created by the same author. However, without additional context or explicit foreign key constraints, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM attachment_journals t1 JOIN work_packages t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 72,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "categories",
            "from_column": "id",
            "to_table": "relations",
            "to_column": "to_id",
            "condition": "categories.id = relations.to_id",
            "confidence": "high",
            "reasoning": "Similarly, the 'to_id' in the 'relations' table could reference the 'id' in the 'categories' table if categories are endpoints of relationships. This is speculative without further context.",
            "test_sql": "SELECT COUNT(*) FROM categories t1 JOIN relations t2 ON t1.id = t2.to_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enumerations",
            "from_column": "id",
            "to_table": "work_package_journals",
            "to_column": "type_id",
            "condition": "enumerations.id = work_package_journals.type_id",
            "confidence": "high",
            "reasoning": "The 'type_id' in work_package_journals could potentially refer to an enumeration of types, where each type is defined in the enumerations table. However, without explicit naming conventions or additional context, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM enumerations t1 JOIN work_package_journals t2 ON t1.id = t2.type_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "enumerations",
            "from_column": "id",
            "to_table": "work_package_journals",
            "to_column": "status_id",
            "condition": "enumerations.id = work_package_journals.status_id",
            "confidence": "high",
            "reasoning": "The 'status_id' in work_package_journals might correspond to an enumeration of statuses, where each status is defined in the enumerations table. This is a common pattern, but without explicit evidence, the confidence is low.",
            "test_sql": "SELECT COUNT(*) FROM enumerations t1 JOIN work_package_journals t2 ON t1.id = t2.status_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 35,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grid_widgets",
            "from_column": "id",
            "to_table": "relations",
            "to_column": "from_id",
            "condition": "grid_widgets.id = relations.from_id",
            "confidence": "high",
            "reasoning": "The 'from_id' in the 'relations' table could potentially reference the 'id' of the 'grid_widgets' table if the widgets themselves are entities that can have relationships. However, without explicit foreign key constraints or additional context, this is speculative.",
            "test_sql": "SELECT COUNT(*) FROM grid_widgets t1 JOIN relations t2 ON t1.id = t2.from_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "grid_widgets",
            "from_column": "id",
            "to_table": "relations",
            "to_column": "to_id",
            "condition": "grid_widgets.id = relations.to_id",
            "confidence": "high",
            "reasoning": "Similarly, the 'to_id' in the 'relations' table could reference the 'id' of the 'grid_widgets' table if the widgets are entities that can be targets of relationships. This is speculative without further context.",
            "test_sql": "SELECT COUNT(*) FROM grid_widgets t1 JOIN relations t2 ON t1.id = t2.to_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "journals",
            "from_column": "data_id",
            "to_table": "meeting_journals",
            "to_column": "project_id",
            "condition": "journals.data_id = meeting_journals.project_id",
            "confidence": "high",
            "reasoning": "The 'data_id' in the 'journals' table and 'project_id' in the 'meeting_journals' table could potentially relate if 'data_id' represents project-related data. However, without explicit context, this relationship is speculative and based on naming conventions.",
            "test_sql": "SELECT COUNT(*) FROM journals t1 JOIN meeting_journals t2 ON t1.data_id = t2.project_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "journals",
            "from_column": "data_id",
            "to_table": "meeting_agenda_items",
            "to_column": "id",
            "condition": "journals.data_id = meeting_agenda_items.id",
            "confidence": "high",
            "reasoning": "The 'journals' table has a 'data_id' column that could potentially reference various entities, and the 'meeting_agenda_items' table has an 'id' column. Without explicit foreign key constraints or additional context, this relationship is speculative and based on the possibility that journal entries might log changes related to specific agenda items.",
            "test_sql": "SELECT COUNT(*) FROM journals t1 JOIN meeting_agenda_items t2 ON t1.data_id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 12,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "journals",
            "from_column": "journable_type",
            "to_table": "watchers",
            "to_column": "watchable_type",
            "condition": "journals.journable_type = watchers.watchable_type",
            "confidence": "high",
            "reasoning": "The naming convention of 'journable_type' and 'watchable_type' suggests a potential relationship where both tables might be dealing with similar types of entities. However, without more context, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM journals t1 JOIN watchers t2 ON t1.journable_type = t2.watchable_type LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "journals",
            "from_column": "journable_id",
            "to_table": "watchers",
            "to_column": "watchable_id",
            "condition": "journals.journable_id = watchers.watchable_id",
            "confidence": "high",
            "reasoning": "Similar to the 'type' fields, the 'id' fields suggest a potential relationship where both tables might be referencing the same entities. This is speculative without additional context.",
            "test_sql": "SELECT COUNT(*) FROM journals t1 JOIN watchers t2 ON t1.journable_id = t2.watchable_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 17,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "id",
            "to_table": "meetings",
            "to_column": "id",
            "condition": "meeting_journals.id = meetings.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field, but without explicit foreign keys or additional context, this relationship is speculative. It assumes that the 'meeting_journals' and 'meetings' tables might be different representations or versions of the same meeting records.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN meetings t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meeting_journals",
            "from_column": "author_id",
            "to_table": "work_package_journals",
            "to_column": "author_id",
            "condition": "meeting_journals.author_id = work_package_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which could imply that the same person is responsible for creating or managing both meetings and work packages. However, without additional context, this relationship is speculative and based on the assumption that authors are tracked similarly in both tables.",
            "test_sql": "SELECT COUNT(*) FROM meeting_journals t1 JOIN work_package_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "meetings",
            "from_column": "author_id",
            "to_table": "work_package_journals",
            "to_column": "author_id",
            "condition": "meetings.author_id = work_package_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which might indicate a relationship where the same person is responsible for creating or organizing meetings and work package journals. However, without additional context, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM meetings t1 JOIN work_package_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 36,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "user_id",
            "to_table": "news",
            "to_column": "author_id",
            "condition": "members.user_id = news.author_id",
            "confidence": "high",
            "reasoning": "The 'user_id' in the 'members' table and 'author_id' in the 'news' table could potentially relate if users who are members of projects are also authors of news articles. However, without explicit foreign key constraints or additional context, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN news t2 ON t1.user_id = t2.author_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "user_id",
            "to_table": "news_journals",
            "to_column": "author_id",
            "condition": "members.user_id = news_journals.author_id",
            "confidence": "high",
            "reasoning": "The 'user_id' in the 'members' table and 'author_id' in the 'news_journals' table could potentially relate if users who are members are also authors of news journals. However, without explicit foreign keys or additional context, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN news_journals t2 ON t1.user_id = t2.author_id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "members",
            "from_column": "user_id",
            "to_table": "work_packages",
            "to_column": "assigned_to_id",
            "condition": "members.user_id = work_packages.assigned_to_id",
            "confidence": "high",
            "reasoning": "The 'user_id' in the members table and 'assigned_to_id' in the work_packages table both refer to users. This suggests a potential relationship where members could be assigned to work packages. However, without explicit foreign keys or additional context, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM members t1 JOIN work_packages t2 ON t1.user_id = t2.assigned_to_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 72,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "menu_items",
            "from_column": "id",
            "to_table": "relations",
            "to_column": "to_id",
            "condition": "menu_items.id = relations.to_id",
            "confidence": "high",
            "reasoning": "Similarly, the 'to_id' in the 'relations' table could potentially reference the 'id' in the 'menu_items' table if the 'relations' table is used to track relationships between menu items. Again, there is no explicit indication of this relationship, and the data types are not directly compatible.",
            "test_sql": "SELECT COUNT(*) FROM menu_items t1 JOIN relations t2 ON t1.id = t2.to_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news",
            "from_column": "author_id",
            "to_table": "notification_settings",
            "to_column": "user_id",
            "condition": "news.author_id = notification_settings.user_id",
            "confidence": "high",
            "reasoning": "The 'author_id' in the 'news' table and 'user_id' in the 'notification_settings' table could potentially relate if authors of news articles are also users who have notification settings. However, without explicit foreign key constraints or additional context, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM news t1 JOIN notification_settings t2 ON t1.author_id = t2.user_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "id",
            "to_table": "relations",
            "to_column": "to_id",
            "condition": "news_journals.id = relations.to_id",
            "confidence": "high",
            "reasoning": "Similarly, the 'to_id' in the 'relations' table might reference the 'id' of the 'news_journals' table, indicating a relationship where a journal entry is the target of a relation. This is also speculative without further context.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN relations t2 ON t1.id = t2.to_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "author_id",
            "to_table": "work_packages",
            "to_column": "author_id",
            "condition": "news_journals.author_id = work_packages.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which might indicate that the same individuals can author both news journal entries and work packages. However, without additional context or a common 'authors' table, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN work_packages t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 72,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "news_journals",
            "from_column": "author_id",
            "to_table": "work_package_journals",
            "to_column": "author_id",
            "condition": "news_journals.author_id = work_package_journals.author_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'author_id' field, which might indicate that the same individuals are responsible for creating entries in both tables. However, without additional context, this relationship is speculative and based on the assumption that authors of news journals might also be involved in work package journals.",
            "test_sql": "SELECT COUNT(*) FROM news_journals t1 JOIN work_package_journals t2 ON t1.author_id = t2.author_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 72,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "roles",
            "from_column": "id",
            "to_table": "users",
            "to_column": "id",
            "condition": "roles.id = users.id",
            "confidence": "high",
            "reasoning": "There is no direct field in the 'users' table that suggests a relationship with the 'roles' table based on the provided schemas. Typically, a 'user_roles' table would exist to map users to roles, but without such a table or a foreign key in the 'users' table referencing 'roles', this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM roles t1 JOIN users t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "work_packages",
            "from_column": "status_id",
            "to_table": "workflows",
            "to_column": "old_status_id",
            "condition": "work_packages.status_id = workflows.old_status_id",
            "confidence": "high",
            "reasoning": "The 'status_id' in work_packages and 'old_status_id' in workflows could be related if workflows are used to manage transitions from the current status of a work package. However, this is speculative without more context.",
            "test_sql": "SELECT COUNT(*) FROM work_packages t1 JOIN workflows t2 ON t1.status_id = t2.old_status_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 5295,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "work_package_journals",
            "from_column": "id",
            "to_table": "work_packages",
            "to_column": "id",
            "condition": "work_package_journals.id = work_packages.id",
            "confidence": "high",
            "reasoning": "While both tables have an 'id' field, it is unlikely that these fields directly correspond to each other as primary keys. However, if the 'id' in work_package_journals is intended to track changes to specific work packages, there might be a statistical relationship. This is speculative without further context.",
            "test_sql": "SELECT COUNT(*) FROM work_package_journals t1 JOIN work_packages t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 19,
            "verification_method": "sql_test"
        }
    ]
}