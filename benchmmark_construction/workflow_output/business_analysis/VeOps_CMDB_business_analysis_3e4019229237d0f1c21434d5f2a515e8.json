{
    "core_tables": [
        "acl_apps",
        "acl_audit_login_logs",
        "acl_audit_permission_logs",
        "acl_audit_resource_logs",
        "acl_audit_role_logs",
        "acl_operation_records",
        "acl_permissions",
        "acl_resource_types",
        "acl_resources",
        "acl_role_permissions",
        "acl_role_relations",
        "acl_roles",
        "c_ad_ci_types",
        "c_ad_rules",
        "c_attribute_histories",
        "c_attributes",
        "c_choice_texts",
        "c_ci_relations",
        "c_ci_type_attribute_group_items",
        "c_ci_type_attribute_groups",
        "c_ci_type_attributes",
        "c_ci_type_groups",
        "c_ci_type_relations",
        "c_ci_types",
        "c_cis",
        "c_prv",
        "c_psa",
        "c_ptv",
        "c_records",
        "c_relation_histories",
        "c_relation_types",
        "c_sc",
        "c_value_index_integers",
        "c_value_index_texts",
        "c_value_texts",
        "common_department",
        "common_employee",
        "users"
    ],
    "table_analysis": {
        "acl_apps": {
            "business_purpose": "The 'acl_apps' table represents applications or clients that are registered within an Access Control List (ACL) system. Each record likely corresponds to an application that requires authentication and authorization to access certain resources or APIs. The table stores metadata about each application, including its name, description, unique identifier (app_id), and secret key for secure access. It also includes fields for soft deletion and auditing (created_at, updated_at, deleted_at, deleted).",
            "key_fields": [
                "id",
                "name",
                "app_id",
                "secret_key",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "One-to-many: This table could be referenced by other tables that store permissions, roles, or access logs related to each application.",
                "Many-to-many: It might participate in join tables that associate applications with resources, permissions, or other entities in an ACL system."
            ],
            "business_operations": [
                "Registering new applications/clients for access control",
                "Authenticating applications using app_id and secret_key",
                "Managing (updating, soft-deleting, restoring) application records",
                "Auditing application creation, updates, and deletions",
                "Listing or searching applications by name or status"
            ]
        },
        "acl_audit_login_logs": {
            "business_purpose": "This table represents an audit log for user login activities within an access control or authentication system. It records detailed information about each login attempt, including the time, user identity, access channel, IP address, browser details, outcome, and session timestamps. The purpose is to provide traceability, security monitoring, and compliance reporting for login events.",
            "key_fields": [
                "id",
                "created_at",
                "username",
                "channel",
                "ip",
                "browser",
                "is_ok",
                "login_at",
                "logout_at"
            ],
            "potential_relationships": [
                "May serve as a child or detail table in a one-to-many relationship with an entity representing users or identities (if such a table exists).",
                "Could be referenced by security or audit summary tables for reporting or aggregation.",
                "Might be linked to incident or alert tables in a security monitoring context."
            ],
            "business_operations": [
                "Recording each login attempt for auditing and compliance.",
                "Monitoring and analyzing failed or suspicious login attempts.",
                "Generating reports on user access patterns and session durations.",
                "Supporting investigations into security incidents by providing login traceability.",
                "Enabling administrators to review login history for troubleshooting or user support."
            ]
        },
        "acl_audit_permission_logs": {
            "business_purpose": "This table represents an audit log for permission-related operations within an access control system. It records detailed information about actions performed on permissions, such as granting, revoking, or modifying access rights, including metadata about the operation, the resources and groups affected, and the context in which the operation occurred. The table is designed to support traceability, compliance, and security auditing for permission changes.",
            "key_fields": [
                "id",
                "created_at",
                "operate_uid",
                "operate_type",
                "app_id",
                "rid",
                "resource_type_id",
                "resource_ids",
                "group_ids",
                "permission_ids",
                "source",
                "deleted",
                "deleted_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship to an application entity (via app_id)",
                "Many-to-one relationship to an operator entity (via operate_uid)",
                "Many-to-one relationship to a role or permission entity (via rid, permission_ids)",
                "Many-to-one relationship to a resource type entity (via resource_type_id)",
                "Many-to-many relationships to resources and groups (via resource_ids, group_ids JSON fields)",
                "Soft-delete relationship (deleted, deleted_at) for logical deletion tracking"
            ],
            "business_operations": [
                "Auditing and tracking permission changes for compliance and security",
                "Investigating who performed specific permission-related actions and when",
                "Generating reports on permission modifications across applications or resources",
                "Supporting rollback or review of permission changes",
                "Filtering or searching audit logs by operator, resource, group, or permission",
                "Implementing soft-delete and restoration of audit log entries"
            ]
        },
        "acl_audit_resource_logs": {
            "business_purpose": "This table represents an audit log for resource access control operations. It is designed to track and record changes or actions performed on resources within an application, capturing details such as who performed the operation, what type of operation was performed, the scope of the operation, and the before/after state of the resource. The table supports soft deletion and maintains timestamps for auditing purposes.",
            "key_fields": [
                "id",
                "app_id",
                "operate_uid",
                "operate_type",
                "scope",
                "link_id",
                "origin",
                "current",
                "created_at",
                "updated_at",
                "deleted",
                "deleted_at"
            ],
            "potential_relationships": [
                "May reference resources or entities via 'link_id' (generic foreign key to a resource)",
                "May be associated with applications via 'app_id'",
                "May be associated with operators or users via 'operate_uid'",
                "May be filtered or grouped by 'operate_type' and 'scope' for reporting or auditing"
            ],
            "business_operations": [
                "Auditing changes to resources (tracking before and after states)",
                "Monitoring user or operator actions on resources",
                "Generating compliance or security reports",
                "Supporting rollback or investigation of changes",
                "Filtering logs by application, operator, operation type, or resource",
                "Soft deletion and restoration of audit log entries"
            ]
        },
        "acl_audit_role_logs": {
            "business_purpose": "This table represents an audit log for role-related actions within an access control system. It is designed to track and record changes or operations performed on roles, capturing details such as who performed the action, what type of operation was executed, the context or scope, and the before/after state of the data. The table supports soft deletion and maintains timestamps for auditing purposes.",
            "key_fields": [
                "id",
                "app_id",
                "operate_uid",
                "operate_type",
                "scope",
                "link_id",
                "origin",
                "current",
                "created_at",
                "updated_at",
                "deleted",
                "deleted_at"
            ],
            "potential_relationships": [
                "May reference an application entity via app_id",
                "May reference an operator entity (such as a user or system process) via operate_uid",
                "May reference a specific role or related object via link_id",
                "Can be filtered or grouped by operate_type and scope for reporting or auditing"
            ],
            "business_operations": [
                "Auditing changes to roles or permissions",
                "Tracking who performed specific role-related actions and when",
                "Comparing previous and current states of roles for compliance or troubleshooting",
                "Supporting soft deletion and recovery of audit records",
                "Generating reports on access control changes for security reviews"
            ]
        },
        "acl_operation_records": {
            "business_purpose": "This table records operation logs related to access control actions within an application. Each record represents an action performed (such as granting, revoking, or modifying permissions) associated with a specific role and application context. The table is designed to track changes or events in the access control layer, likely for auditing, compliance, or security monitoring purposes.",
            "key_fields": [
                "id",
                "app",
                "rolename",
                "operate",
                "obj",
                "created_at",
                "deleted",
                "deleted_at"
            ],
            "potential_relationships": [
                "May reference or be referenced by tables representing applications (via 'app')",
                "May reference or be referenced by tables representing roles (via 'rolename')",
                "Could be used in conjunction with audit or log aggregation tables",
                "Could be filtered or grouped by operation type ('operate')"
            ],
            "business_operations": [
                "Auditing access control changes or events",
                "Tracking which roles performed which operations in which applications",
                "Reviewing or investigating security-related incidents",
                "Generating reports on access control activities",
                "Soft-deleting operation records for compliance or retention policies"
            ]
        },
        "acl_permissions": {
            "business_purpose": "The 'acl_permissions' table represents a catalog of permissions within an access control system, defining specific actions or rights that can be granted within an application context. Each permission is associated with a particular resource type and optionally scoped to a specific application, supporting fine-grained access management.",
            "key_fields": [
                "id",
                "name",
                "resource_type_id",
                "app_id",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship to 'acl_resource_types' via 'resource_type_id' (each permission is linked to a resource type)",
                "Many-to-one relationship to 'acl_apps' via 'app_id' (each permission can be scoped to an application)",
                "Potential one-to-many relationships from other tables that reference permissions (e.g., permission assignments), though not shown here"
            ],
            "business_operations": [
                "Defining new permissions for resource types and applications",
                "Modifying or updating existing permissions",
                "Soft-deleting permissions (marking as deleted without physical removal)",
                "Auditing permission creation, updates, and deletions via timestamps",
                "Querying available permissions for a given resource type or application"
            ]
        },
        "acl_resource_types": {
            "business_purpose": "The 'acl_resource_types' table represents different types of resources that can be managed or protected within an access control system, likely as part of an application-level access control list (ACL) framework. Each record defines a resource type, possibly specifying what kind of entities (e.g., documents, endpoints, features) can be subject to access control policies within a specific application context.",
            "key_fields": [
                "id",
                "name",
                "app_id",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship with 'acl_apps' via 'app_id' (each resource type belongs to one application)",
                "One-to-many relationship with other tables that might reference resource types (e.g., ACL rules, permissions, or resource instances), though such tables are not specified here"
            ],
            "business_operations": [
                "Defining new resource types for access control within an application",
                "Associating resource types with specific applications",
                "Soft-deleting or archiving resource types (using 'deleted' and 'deleted_at')",
                "Auditing or tracking changes to resource types (using 'created_at' and 'updated_at')",
                "Querying resource types by name or application for management or policy assignment"
            ]
        },
        "acl_resources": {
            "business_purpose": "The 'acl_resources' table represents individual resources that are subject to access control within an application or system. Each resource is categorized by type and may be associated with a specific application and user. The table supports soft deletion and tracks creation and update timestamps, indicating its use in managing the lifecycle and permissions of resources in an access control context.",
            "key_fields": [
                "id",
                "name",
                "resource_type_id",
                "app_id",
                "uid",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship with 'acl_resource_types' via 'resource_type_id' (each resource has a type)",
                "Many-to-one relationship with 'acl_apps' via 'app_id' (each resource may belong to an application)",
                "Possible association with a user or entity via 'uid' (though the referenced table is not specified in the schema)"
            ],
            "business_operations": [
                "Registering or creating new resources for access control",
                "Categorizing resources by type and associating them with applications",
                "Soft-deleting resources (marking as deleted without physical removal)",
                "Auditing resource creation, updates, and deletions via timestamps",
                "Querying resources by type, application, or user for permission checks",
                "Restoring or permanently deleting resources as part of lifecycle management"
            ]
        },
        "acl_role_permissions": {
            "business_purpose": "This table represents the assignment of permissions to roles within an access control system, potentially scoped to specific resources, resource groups, and applications. It acts as a mapping table that defines which roles have which permissions on which resources or groups, possibly within the context of a particular application. The table also supports soft deletion and auditing via timestamp fields.",
            "key_fields": [
                "id",
                "rid",
                "resource_id",
                "group_id",
                "perm_id",
                "app_id",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship to acl_roles via rid",
                "Many-to-one relationship to acl_resources via resource_id",
                "Many-to-one relationship to acl_resource_groups via group_id",
                "Many-to-one relationship to acl_permissions via perm_id",
                "Many-to-one relationship to acl_apps via app_id"
            ],
            "business_operations": [
                "Assigning permissions to roles for specific resources, groups, or applications",
                "Revoking or modifying permissions for roles",
                "Auditing permission assignments and changes over time",
                "Filtering or querying active (non-deleted) permission assignments",
                "Soft-deleting permission assignments (marking as deleted without physical removal)"
            ]
        },
        "acl_role_relations": {
            "business_purpose": "The acl_role_relations table models hierarchical or dependency relationships between access control roles within the context of specific applications. It is designed to represent parent-child relationships between roles, allowing for inheritance or delegation of permissions, and supports soft deletion and auditing of these relationships.",
            "key_fields": [
                "id",
                "parent_id",
                "child_id",
                "app_id",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-many or hierarchical (tree-like) relationships between roles, where a role can be a parent or child of another role",
                "Association of role relationships with specific applications, indicating that the hierarchy or linkage is scoped to an application"
            ],
            "business_operations": [
                "Defining or modifying role hierarchies for access control within an application",
                "Querying effective permissions by traversing parent-child role relationships",
                "Soft-deleting or restoring role relationships for audit and rollback purposes",
                "Auditing changes to role relationships over time (creation, update, deletion timestamps)",
                "Scoping role relationships to specific applications for multi-tenant or modular systems"
            ]
        },
        "acl_roles": {
            "business_purpose": "The acl_roles table represents a system for managing access control roles within an application. It is designed to define roles that can be assigned to users, potentially scoped to specific applications, and may include credentials or permissions for administrative access. The table supports soft deletion and tracks creation and update timestamps, indicating its use in a dynamic, auditable access control environment.",
            "key_fields": [
                "id",
                "name",
                "app_id",
                "uid",
                "is_app_admin",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at",
                "password",
                "key",
                "secret"
            ],
            "potential_relationships": [
                "Many-to-one relationship with acl_apps via app_id (each role may be associated with a specific application)",
                "Many-to-one relationship with users via uid (each role may be assigned to a specific user)",
                "Potential one-to-many relationship from acl_roles to other access control or permissions tables (not shown here), as roles are often referenced by other entities"
            ],
            "business_operations": [
                "Creating new access control roles for applications or users",
                "Assigning roles to users within the context of an application",
                "Granting or revoking administrative privileges (is_app_admin)",
                "Managing credentials or secrets associated with roles (password, key, secret)",
                "Soft-deleting roles (using deleted and deleted_at fields) for audit and recovery purposes",
                "Auditing role creation and modification (created_at, updated_at)",
                "Filtering or querying roles by application, user, or deletion status"
            ]
        },
        "c_ad_ci_types": {
            "business_purpose": "The c_ad_ci_types table appears to represent a configuration or mapping between 'CI types' (likely Configuration Item types) and 'AD rules' (possibly Active Directory rules or similar automation/authorization rules). It is designed to manage, schedule, and control the association and behavior of these types, possibly for automated processes, integrations, or policy enforcement. The table supports soft deletion, scheduling (via cron/interval), dynamic attributes, and relations, indicating its use in a flexible, rule-driven system.",
            "key_fields": [
                "id",
                "type_id",
                "adr_id",
                "attributes",
                "relation",
                "auto_accept",
                "agent_id",
                "query_expr",
                "interval",
                "cron",
                "extra_option",
                "enabled",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship to c_ci_types via type_id (each record links to a CI type)",
                "Many-to-one relationship to c_ad_rules via adr_id (each record links to an AD rule)",
                "Possible one-to-many or many-to-many relationships with agents (via agent_id), if agents are a business entity",
                "Potential for dynamic relationships to other entities via the 'relation' JSON field"
            ],
            "business_operations": [
                "Defining and managing the association between CI types and AD rules",
                "Enabling or disabling specific CI type-rule associations",
                "Scheduling automated actions or checks using cron or interval fields",
                "Storing and updating dynamic attributes and options for each association",
                "Soft-deleting and restoring associations (using deleted and deleted_at)",
                "Querying or filtering associations based on agent, user (uid), or other criteria",
                "Executing or evaluating query expressions for dynamic or conditional logic"
            ]
        },
        "c_ad_rules": {
            "business_purpose": "The c_ad_rules table represents a set of configurable rules, likely for controlling or monitoring automated processes, integrations, or data collection mechanisms. The rules can be of different types (such as http, agent, components, snmp), may be owned by different entities, and can be extended with plugins or custom scripts. The table supports soft deletion and versioning, and allows for flexible configuration via JSON fields.",
            "key_fields": [
                "id",
                "name",
                "type",
                "owner",
                "option",
                "attributes",
                "is_inner",
                "is_plugin",
                "plugin_script",
                "unique_key",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "May be referenced by other tables that assign or apply rules to entities or processes",
                "May be linked to logs or audit tables tracking rule execution or changes",
                "The 'owner' field suggests a possible association with an entity (such as a user, group, or system component), but the specific relationship is not defined in this schema"
            ],
            "business_operations": [
                "Creating, updating, and deleting (soft delete) rules for automated processes or integrations",
                "Configuring rule options and attributes for flexible behavior",
                "Enabling or disabling rules via the 'deleted' or 'is_inner' flags",
                "Managing plugin-based or script-based rules",
                "Auditing rule changes and tracking rule lifecycle events"
            ]
        },
        "c_attribute_histories": {
            "business_purpose": "The c_attribute_histories table is designed to track the history of changes made to specific attributes associated with records (likely configuration items or similar entities). It logs each change event, including the type of operation performed, the previous and new values, and relevant timestamps. This enables auditing, rollback, and traceability of attribute modifications over time.",
            "key_fields": [
                "id",
                "record_id",
                "ci_id",
                "attr_id",
                "operate_type",
                "old",
                "new",
                "created_at",
                "updated_at",
                "deleted",
                "deleted_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship with c_records via record_id (each history entry belongs to a record)",
                "Possible many-to-one relationships with entities referenced by ci_id and attr_id (if these refer to other tables, such as configuration items and attributes)",
                "Acts as a child or log table for tracking changes to parent records"
            ],
            "business_operations": [
                "Auditing changes to record attributes",
                "Tracking the lifecycle and modifications of attributes for compliance or troubleshooting",
                "Supporting rollback or recovery of previous attribute values",
                "Generating reports on attribute change history",
                "Soft deletion and restoration of history entries (using deleted and deleted_at fields)"
            ]
        },
        "c_attributes": {
            "business_purpose": "The c_attributes table represents a dynamic, metadata-driven definition of attributes or fields that can be attached to other business entities or records in a system. It is designed to allow flexible, configurable, and possibly user-defined attributes, supporting various data types, constraints, computed values, and options. This enables the system to extend its data model without altering the core schema, supporting use cases such as custom fields, dynamic forms, or extensible entity properties.",
            "key_fields": [
                "id",
                "name",
                "alias",
                "value_type",
                "is_choice",
                "is_list",
                "is_unique",
                "is_index",
                "is_link",
                "is_password",
                "is_computed",
                "compute_script",
                "compute_expr",
                "option",
                "default",
                "is_reference",
                "reference_type_id",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Defines attribute metadata that could be referenced by other tables/entities to describe their fields",
                "May be used as a lookup or configuration table for dynamic data models",
                "reference_type_id suggests a possible link to another type or entity definition, enabling reference-type attributes",
                "uid may indicate ownership or grouping, possibly relating to a user, organization, or context, but its meaning is not explicit"
            ],
            "business_operations": [
                "Defining new custom attributes or fields for entities",
                "Configuring attribute properties such as data type, uniqueness, indexing, and default values",
                "Managing attribute lifecycle (creation, update, soft deletion)",
                "Supporting dynamic forms or data entry screens where fields are not hardcoded",
                "Enabling computed or derived attributes using scripts or expressions",
                "Configuring choice lists, options, and reference relationships for attributes",
                "Filtering, sorting, and searching data based on dynamic attributes"
            ]
        },
        "c_choice_texts": {
            "business_purpose": "The c_choice_texts table represents a set of selectable text choices or options associated with specific attributes (as referenced by attr_id). It is likely used to store possible values or options for configurable attributes in a system, such as dropdown choices, selectable answers, or predefined text options for a given attribute.",
            "key_fields": [
                "id",
                "attr_id",
                "value",
                "option",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship with the c_attributes table via attr_id (each choice text belongs to a specific attribute)",
                "Potential one-to-many relationship from c_attributes to c_choice_texts (each attribute can have multiple choice texts)"
            ],
            "business_operations": [
                "Defining and managing selectable options for attributes",
                "Retrieving available choices for a given attribute for display in forms or interfaces",
                "Soft-deleting or archiving choice texts (using deleted and deleted_at fields)",
                "Auditing or tracking creation and modification times for choice texts",
                "Storing additional configuration or metadata for each choice via the option (json) field"
            ]
        },
        "c_ci_relations": {
            "business_purpose": "This table models relationships between two configuration items (CIs), likely representing dependencies, associations, or hierarchies between assets or entities tracked in a configuration management system. Each record defines a specific type of relationship between two CIs, with metadata for auditing and soft deletion.",
            "key_fields": [
                "id",
                "first_ci_id",
                "second_ci_id",
                "relation_type_id",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at",
                "ancestor_ids"
            ],
            "potential_relationships": [
                "Many-to-one: Each relation references two CIs (first_ci_id, second_ci_id), indicating that multiple relations can exist for the same CI.",
                "Many-to-one: Each relation references a relation type (relation_type_id), allowing categorization of the relationship.",
                "Optional many-to-one: The 'more' field may reference an additional CI, possibly for extended relationship context.",
                "Hierarchical/self-referential: The 'ancestor_ids' field suggests the ability to track relationship lineage or nested relationships."
            ],
            "business_operations": [
                "Creating, updating, or deleting relationships between configuration items.",
                "Querying all relationships for a given configuration item.",
                "Auditing changes to relationships (using created_at, updated_at, deleted, deleted_at).",
                "Filtering or categorizing relationships by type.",
                "Tracing relationship hierarchies or dependencies using ancestor_ids.",
                "Soft-deleting relationships for historical tracking without physical removal."
            ]
        },
        "c_ci_type_attribute_group_items": {
            "business_purpose": "This table represents the association between attribute groups and individual attributes, likely within a configuration or classification system. It is used to organize which attributes belong to which attribute groups, possibly for defining types of configuration items or entities, and to specify the order in which these attributes appear within a group.",
            "key_fields": [
                "id",
                "group_id",
                "attr_id",
                "order",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship from this table to c_ci_type_attribute_groups via group_id",
                "Many-to-one relationship from this table to c_attributes via attr_id",
                "Acts as a junction (associative) table between attribute groups and attributes"
            ],
            "business_operations": [
                "Assigning attributes to attribute groups",
                "Reordering attributes within a group",
                "Soft-deleting or restoring attribute-group associations",
                "Auditing changes to attribute-group associations (creation, update, deletion timestamps)",
                "Retrieving all attributes for a given group, in a specified order"
            ]
        },
        "c_ci_type_attribute_groups": {
            "business_purpose": "This table represents groups of attributes associated with a specific 'type' of configuration item (CI). It is likely used to organize or categorize attributes for different CI types, supporting structured management and display of CI attributes in a system such as a configuration management database (CMDB) or asset management platform.",
            "key_fields": [
                "id",
                "name",
                "type_id",
                "order",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship with the c_ci_types table via type_id, indicating that each attribute group belongs to a specific CI type.",
                "Potential one-to-many relationship with a table that stores individual attributes, where each attribute would reference the attribute group (not shown in this schema)."
            ],
            "business_operations": [
                "Creating, updating, or deleting attribute groups for a given CI type.",
                "Organizing and ordering attribute groups for display or logical grouping in user interfaces.",
                "Filtering or retrieving attribute groups for a specific CI type.",
                "Soft-deleting attribute groups (using deleted and deleted_at fields) to maintain historical data or support undo operations.",
                "Auditing changes to attribute groups using created_at and updated_at timestamps."
            ]
        },
        "c_ci_type_attributes": {
            "business_purpose": "This table represents the mapping and configuration of attributes for different configuration item (CI) types. It defines which attributes are associated with each CI type, along with metadata such as display order, whether the attribute is required, and if it should be shown by default. This is typically used in systems that manage configurable entities, such as asset management, inventory, or CMDB (Configuration Management Database) systems.",
            "key_fields": [
                "id",
                "type_id",
                "attr_id",
                "order",
                "is_required",
                "default_show",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship to a CI type entity (via type_id)",
                "Many-to-one relationship to an attribute definition entity (via attr_id)",
                "Acts as a junction (association) table between CI types and attributes"
            ],
            "business_operations": [
                "Defining which attributes are available for each CI type",
                "Configuring the display order and visibility of attributes for CI types",
                "Marking attributes as required or optional for specific CI types",
                "Soft-deleting attribute associations from CI types",
                "Auditing changes to attribute associations (via created_at, updated_at, deleted_at)"
            ]
        },
        "c_ci_type_groups": {
            "business_purpose": "The c_ci_type_groups table represents a grouping or categorization mechanism for configuration item (CI) types or similar entities. It is designed to organize types into named groups, likely for classification, display ordering, or management purposes within a system that tracks or manages different types of items or assets.",
            "key_fields": [
                "id",
                "name",
                "order",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as a parent or grouping table for another table that stores individual CI types or items, with those records referencing the id of this table.",
                "Lookup/reference: Other tables might reference this table to assign a group to a record, enabling categorization or filtering by group."
            ],
            "business_operations": [
                "Creating new type groups for organizational or classification purposes.",
                "Updating group names or their display order.",
                "Soft-deleting groups (using the deleted and deleted_at fields) to retain historical data while hiding inactive groups.",
                "Retrieving lists of groups for display, filtering, or reporting.",
                "Auditing changes to group definitions via created_at and updated_at timestamps."
            ]
        },
        "c_ci_type_relations": {
            "business_purpose": "The c_ci_type_relations table models the relationships between different configuration item types (CI types) within a system, likely for a configuration management or asset management context. It defines how one CI type (parent) is related to another CI type (child), the type of relationship, and any constraints or attribute mappings that govern this relationship. This enables the system to represent complex hierarchies or associations between different types of items or entities.",
            "key_fields": [
                "id",
                "parent_id",
                "child_id",
                "relation_type_id",
                "constraint",
                "parent_attr_id",
                "child_attr_id",
                "parent_attr_ids",
                "child_attr_ids",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-many or hierarchical relationships between CI types (parent_id and child_id both reference CI types)",
                "Relationship classification or categorization via relation_type_id",
                "Attribute-level mapping or constraints between parent and child CI types (parent_attr_id, child_attr_id, parent_attr_ids, child_attr_ids)"
            ],
            "business_operations": [
                "Defining and managing the allowed relationships between different CI types",
                "Querying or visualizing the structure or hierarchy of CI types",
                "Enforcing constraints or rules when linking CI types in business processes",
                "Soft-deleting or auditing changes to CI type relationships (using deleted, deleted_at, created_at, updated_at)",
                "Mapping or transforming attributes between related CI types for integration or reporting purposes"
            ]
        },
        "c_ci_types": {
            "business_purpose": "The c_ci_types table represents a catalog of configuration item (CI) types or categories within a system, likely used to define and manage different types of entities or assets. Each record describes a specific CI type, including its name, alias, display properties, and status flags. This enables the system to classify and organize various items or resources according to their type, supporting configuration management, asset tracking, or similar business processes.",
            "key_fields": [
                "id",
                "name",
                "alias",
                "unique_id",
                "enabled",
                "is_attached",
                "order",
                "icon_url",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship with c_attributes via unique_id (each CI type references a specific attribute definition)",
                "Potential one-to-many relationship from this table to other tables that reference CI types (e.g., items or assets classified by type), though such tables are not specified here"
            ],
            "business_operations": [
                "Defining and managing the catalog of configuration item types",
                "Enabling or disabling specific CI types for use in the system",
                "Soft-deleting CI types (using deleted and deleted_at fields)",
                "Ordering CI types for display or processing purposes",
                "Associating CI types with specific attributes (via unique_id)",
                "Displaying CI types with associated icons and display properties",
                "Auditing creation and modification times for CI types"
            ]
        },
        "c_cis": {
            "business_purpose": "The c_cis table appears to represent a set of configuration items or entities that are categorized by type (via type_id), can be soft-deleted, and have status and activity tracking. The presence of fields like heartbeat and status suggests these items may be monitored for activity or health, possibly in an IT, asset management, or monitoring context.",
            "key_fields": [
                "id",
                "type_id",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at",
                "status",
                "heartbeat",
                "a",
                "updated_by"
            ],
            "potential_relationships": [
                "Many-to-one relationship with c_ci_types via type_id (each record is associated with a type)",
                "Potential one-to-many or many-to-many relationships with other tables that reference this table's id as a foreign key (not shown in this schema)"
            ],
            "business_operations": [
                "Creating new configuration items/entities",
                "Updating status, heartbeat, or other attributes of items",
                "Soft-deleting items (marking as deleted without physical removal)",
                "Auditing changes (tracking created_at, updated_at, updated_by)",
                "Filtering or querying items by type, status, or deletion state",
                "Monitoring item activity or health via the heartbeat field"
            ]
        },
        "c_prv": {
            "business_purpose": "The c_prv table appears to represent a collection of named entities or resources, possibly 'profiles', 'privileges', or 'provisions', that are associated with a specific user or owner (uid). Each record can be public or private, can be soft-deleted, and may reference related resources via cr_ids. The table supports extensibility through a JSON 'option' field, suggesting customizable or additional attributes per record.",
            "key_fields": [
                "id",
                "uid",
                "name",
                "cr_ids",
                "is_public",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at",
                "option"
            ],
            "potential_relationships": [
                "One-to-many: Each uid may own multiple c_prv records.",
                "Many-to-many or one-to-many: The cr_ids JSON field likely stores references to other entities, indicating a relationship to multiple resources or records elsewhere.",
                "Soft-delete: The deleted and deleted_at fields enable logical deletion, affecting how this table relates to queries and data integrity."
            ],
            "business_operations": [
                "Creating new named entities/resources for a user or owner.",
                "Updating attributes or options for these entities.",
                "Soft-deleting and restoring records (using deleted and deleted_at).",
                "Querying for public or private entities (using is_public).",
                "Associating or disassociating related resources via cr_ids.",
                "Auditing or tracking changes with created_at and updated_at."
            ]
        },
        "c_psa": {
            "business_purpose": "The c_psa table appears to represent a mapping or configuration entity that links a 'type' (from c_ci_types) to an 'attribute' (from c_attributes), possibly defining which attributes are associated with which types in a configurable system. It supports soft deletion, ordering, and the distinction between fixed and built-in attributes, suggesting it is used to manage dynamic or customizable properties for different types of items or entities.",
            "key_fields": [
                "id",
                "uid",
                "type_id",
                "attr_id",
                "order",
                "is_fixed",
                "builtin_attr",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship to c_ci_types via type_id (each record is associated with a type)",
                "Many-to-one relationship to c_attributes via attr_id (each record may be associated with an attribute)",
                "Potential one-to-many relationship from c_ci_types and c_attributes to c_psa (each type or attribute can have multiple c_psa records)"
            ],
            "business_operations": [
                "Configuring which attributes are available or required for a given type",
                "Ordering or prioritizing attributes for display or processing",
                "Marking attributes as fixed or built-in for a type",
                "Soft-deleting attribute-type associations (without removing them from the database)",
                "Auditing changes to attribute-type associations via timestamps",
                "Retrieving attribute configurations for a given type for use in forms, validation, or business logic"
            ]
        },
        "c_ptv": {
            "business_purpose": "The c_ptv table appears to represent a core business entity that tracks items or records with a specific type (referenced by type_id), an associated uid (likely a unique identifier for a related entity), and a set of hierarchical or multi-level attributes stored in the levels JSON field. The table supports soft deletion (deleted, deleted_at) and audit tracking (created_at, updated_at), suggesting it is used for managing records that may change over time and require traceability.",
            "key_fields": [
                "id",
                "uid",
                "type_id",
                "levels",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship with c_ci_types via type_id (each record is associated with a type)",
                "Potential one-to-many or many-to-one relationship with another entity via uid (the nature of uid is not specified, but it is indexed and required)"
            ],
            "business_operations": [
                "Creating new records with specific types and hierarchical attributes",
                "Updating records to reflect changes in attributes or type",
                "Soft deleting records (marking as deleted without physical removal)",
                "Auditing record creation and modification times",
                "Querying records by type, uid, or deletion status",
                "Storing and retrieving complex, multi-level data structures in the levels field"
            ]
        },
        "c_records": {
            "business_purpose": "The c_records table appears to represent a log or record-keeping entity for actions, events, or cases associated with unique users or entities (uid). It tracks the creation, update, and (soft) deletion of records, possibly related to tickets, events, or incidents, with additional classification via type_id and descriptive information via reason and origin. The table is designed to support auditability and traceability of actions or cases within a business process.",
            "key_fields": [
                "id",
                "uid",
                "type_id",
                "ticket_id",
                "origin",
                "reason",
                "created_at",
                "updated_at",
                "deleted",
                "deleted_at"
            ],
            "potential_relationships": [
                "One-to-many: Each uid may have multiple records in this table.",
                "Many-to-one: Multiple records may share the same type_id, indicating categorization or classification.",
                "Possible linkage to external systems or processes via ticket_id and origin, though not enforced by foreign keys."
            ],
            "business_operations": [
                "Creating new records to log or track events, actions, or cases.",
                "Updating records to reflect changes in status, details, or classification.",
                "Soft-deleting records (marking as deleted without physical removal) for audit or compliance purposes.",
                "Querying records by uid, type_id, or deletion status for reporting, auditing, or operational workflows.",
                "Storing reasons or justifications for actions/events for compliance or business analysis."
            ]
        },
        "c_relation_histories": {
            "business_purpose": "The c_relation_histories table is designed to track the history of relationships between two entities (likely configuration items or similar objects) over time. It records changes or operations (such as creation or deletion) performed on these relationships, providing an audit trail for relationship management within a system.",
            "key_fields": [
                "id",
                "record_id",
                "relation_id",
                "relation_type_id",
                "first_ci_id",
                "second_ci_id",
                "operate_type",
                "created_at",
                "updated_at",
                "deleted",
                "deleted_at"
            ],
            "potential_relationships": [
                "Links to a record in c_records via record_id, indicating the primary record this history entry is associated with.",
                "Links to a relation type in c_relation_types via relation_type_id, specifying the type of relationship being tracked.",
                "Associates two entities (first_ci_id and second_ci_id) that are involved in the relationship, possibly referencing other tables not specified here.",
                "Tracks the specific relationship instance via relation_id, which may correspond to a relationship record in another table."
            ],
            "business_operations": [
                "Auditing changes to relationships between entities (e.g., when a relationship is created, modified, or deleted).",
                "Tracking the lifecycle and status of relationships for compliance or historical analysis.",
                "Supporting soft deletion and restoration of relationship history records (using deleted and deleted_at fields).",
                "Reporting on the types and frequency of relationship changes over time.",
                "Enabling rollback or review of past relationship states for troubleshooting or governance."
            ]
        },
        "c_relation_types": {
            "business_purpose": "The c_relation_types table defines and manages different types of relationships that can exist within the business domain. Each record represents a unique relationship type, such as 'parent', 'partner', or 'supplier', which can be referenced elsewhere in the system to categorize or describe connections between entities.",
            "key_fields": [
                "id",
                "name",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Referenced as a lookup or enumeration table by other tables to standardize relationship types",
                "Used as a foreign key in other tables to indicate the type of relationship between entities",
                "Supports soft deletion and auditing, suggesting it may be joined with tables tracking relationship instances"
            ],
            "business_operations": [
                "Creating new relationship types for use throughout the system",
                "Updating existing relationship type definitions",
                "Soft-deleting relationship types (marking as deleted without physical removal)",
                "Auditing changes to relationship types via timestamps",
                "Filtering or retrieving active (non-deleted) relationship types for use in business processes"
            ]
        },
        "c_sc": {
            "business_purpose": "The c_sc table appears to represent a generic, possibly configurable entity within a business application. The presence of a 'name' field, a flexible 'option' JSON column, and standard audit fields (created_at, updated_at, deleted_at, deleted, deleted_at) suggests it is used to store records that may have variable attributes or settings, such as configurations, settings, or categorizations that can be soft-deleted and tracked over time.",
            "key_fields": [
                "id",
                "name",
                "option",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Could serve as a lookup or reference table for other entities",
                "May be used in a one-to-many relationship where other tables reference this table's id",
                "Could be a parent in a configuration or settings hierarchy"
            ],
            "business_operations": [
                "Creating new configurable or named records",
                "Updating existing records and their options/settings",
                "Soft-deleting records (marking as deleted without physical removal)",
                "Querying for active or deleted records",
                "Auditing changes over time via timestamps"
            ]
        },
        "c_value_index_integers": {
            "business_purpose": "This table represents a mapping of integer attribute values to specific configuration items (CIs). It is designed to store integer-type attribute values for various entities (likely configuration items) in a flexible, extensible way, supporting a dynamic attribute model where each CI can have multiple attributes, and each attribute can have a value of integer type. The table also supports soft deletion and auditing via timestamp fields.",
            "key_fields": [
                "id",
                "ci_id",
                "attr_id",
                "value",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship from c_value_index_integers to c_cis via ci_id (each value belongs to one CI)",
                "Many-to-one relationship from c_value_index_integers to c_attributes via attr_id (each value is for one attribute)",
                "One-to-many relationship from c_cis to c_value_index_integers (each CI can have multiple attribute values)",
                "One-to-many relationship from c_attributes to c_value_index_integers (each attribute can be assigned to multiple CIs)"
            ],
            "business_operations": [
                "Assigning or updating integer attribute values for configuration items",
                "Querying all integer attribute values for a given configuration item",
                "Auditing changes to attribute values over time (using created_at, updated_at)",
                "Soft-deleting attribute values (using deleted and deleted_at)",
                "Filtering or searching configuration items based on specific attribute values"
            ]
        },
        "c_value_index_texts": {
            "business_purpose": "The c_value_index_texts table is designed to store textual attribute values associated with specific entities (likely configuration items or similar objects) and their attributes. Each record links a particular entity (ci_id) and an attribute (attr_id) to a specific text value, supporting flexible, attribute-driven data modeling. The table also supports soft deletion and auditing via timestamp fields.",
            "key_fields": [
                "id",
                "ci_id",
                "attr_id",
                "value",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship from c_value_index_texts to c_cis via ci_id",
                "Many-to-one relationship from c_value_index_texts to c_attributes via attr_id"
            ],
            "business_operations": [
                "Storing and retrieving attribute values for specific entities",
                "Auditing changes to attribute values (created_at, updated_at)",
                "Soft deletion and restoration of attribute values (deleted, deleted_at)",
                "Querying all attribute values for a given entity or attribute",
                "Indexing or searching textual attribute values for reporting or filtering"
            ]
        },
        "c_value_texts": {
            "business_purpose": "The c_value_texts table is designed to store text-based attribute values associated with specific entities (likely configuration items or similar objects) and their attributes. It acts as a flexible data store for capturing textual information tied to a combination of an entity (ci_id) and an attribute definition (attr_id), supporting soft deletion and audit tracking.",
            "key_fields": [
                "id",
                "ci_id",
                "attr_id",
                "value",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at"
            ],
            "potential_relationships": [
                "Many-to-one relationship from c_value_texts to c_cis via ci_id (each value belongs to one entity, but an entity can have many values)",
                "Many-to-one relationship from c_value_texts to c_attributes via attr_id (each value is for one attribute, but an attribute can have many values across entities)"
            ],
            "business_operations": [
                "Storing new text values for attributes of entities",
                "Retrieving attribute values for a given entity",
                "Updating existing attribute values",
                "Soft-deleting attribute values (marking as deleted without physical removal)",
                "Auditing changes to attribute values (tracking creation, update, and deletion timestamps)"
            ]
        },
        "common_department": {
            "business_purpose": "The 'common_department' table represents organizational departments within a business or institution. It is designed to store information about each department, including its name, hierarchy, director, and status (active or deleted). The table supports soft deletion and tracks creation and update timestamps, indicating its use in managing the structure and lifecycle of departments.",
            "key_fields": [
                "department_id",
                "department_name",
                "department_director_id",
                "department_parent_id",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at",
                "sort_value",
                "acl_rid"
            ],
            "potential_relationships": [
                "Self-referencing hierarchy via 'department_parent_id' (departments can be nested under parent departments)",
                "Potential linkage to access control or permissions via 'acl_rid'",
                "Potential association with a director entity via 'department_director_id' (could reference a person or role, but not specified here)"
            ],
            "business_operations": [
                "Creating new departments",
                "Updating department details (name, director, parent, etc.)",
                "Organizing departments into hierarchical structures",
                "Soft-deleting and restoring departments",
                "Sorting or ordering departments for display or processing",
                "Managing access control or permissions at the department level"
            ]
        },
        "common_employee": {
            "business_purpose": "The 'common_employee' table represents individual employees within an organization. It is designed to store core employee information, including personal details, contact information, employment status, and access control attributes. The table also supports soft deletion and tracks metadata such as creation and update timestamps.",
            "key_fields": [
                "employee_id",
                "email",
                "username",
                "nickname",
                "sex",
                "position_name",
                "mobile",
                "avatar",
                "direct_supervisor_id",
                "department_id",
                "acl_uid",
                "acl_rid",
                "acl_virtual_rid",
                "last_login",
                "deleted",
                "deleted_at",
                "created_at",
                "updated_at",
                "block",
                "notice_info"
            ],
            "potential_relationships": [
                "Belongs-to relationship with 'common_department' via 'department_id' (foreign key)",
                "Self-referencing relationship for reporting structure via 'direct_supervisor_id' (an employee can be supervised by another employee)",
                "Possible relationships to access control or permissions systems via 'acl_uid', 'acl_rid', and 'acl_virtual_rid' (if such tables exist)",
                "Potential for use in hierarchical or organizational chart structures due to supervisor and department references"
            ],
            "business_operations": [
                "Employee onboarding and offboarding (creation and soft deletion of employee records)",
                "Employee profile management (updating personal and contact information)",
                "Organizational reporting (retrieving employees by department or supervisor)",
                "Access control and permissions management (using ACL-related fields)",
                "Authentication and login tracking (using 'last_login')",
                "Internal communications or notifications (using 'notice_info')",
                "Blocking or restricting employee access (using 'block')"
            ]
        },
        "users": {
            "business_purpose": "This table represents a user or account registry for an application or system, likely supporting both internal (employee) and external (possibly customer or partner) users. It manages authentication, identification, and user profile information, including access control (block, deleted), contact details, and organizational context (department, employee_id). The presence of fields like 'key' and 'secret' suggests support for API access or programmatic authentication.",
            "key_fields": [
                "uid",
                "username",
                "email",
                "mobile",
                "password",
                "key",
                "secret",
                "department",
                "employee_id",
                "block",
                "deleted",
                "date_joined",
                "last_login"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as the parent in relationships where users own or create other entities (e.g., records, resources, logs).",
                "Many-to-one: Users may belong to a department or catalog, suggesting possible links to organizational or classification tables.",
                "One-to-one: Each user may have a unique profile or settings record in another table.",
                "Many-to-many: Users could be associated with roles, permissions, or groups in other tables."
            ],
            "business_operations": [
                "User registration and onboarding",
                "User authentication and login",
                "Password and credential management",
                "User profile updates (contact info, avatar, nickname)",
                "Account status management (blocking, soft deletion)",
                "Tracking user activity (last login, has_logined)",
                "Integration with external systems (wx_id, API key/secret usage)",
                "Employee management and organizational reporting"
            ]
        }
    },
    "relationships": [
        {
            "type": "foreign_key",
            "from_table": "acl_permissions",
            "from_column": "app_id",
            "to_table": "acl_apps",
            "to_column": "id",
            "condition": "acl_permissions.app_id = acl_apps.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "acl_resource_types",
            "from_column": "app_id",
            "to_table": "acl_apps",
            "to_column": "id",
            "condition": "acl_resource_types.app_id = acl_apps.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "acl_resources",
            "from_column": "app_id",
            "to_table": "acl_apps",
            "to_column": "id",
            "condition": "acl_resources.app_id = acl_apps.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "acl_role_permissions",
            "from_column": "app_id",
            "to_table": "acl_apps",
            "to_column": "id",
            "condition": "acl_role_permissions.app_id = acl_apps.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "acl_role_relations",
            "from_column": "app_id",
            "to_table": "acl_apps",
            "to_column": "id",
            "condition": "acl_role_relations.app_id = acl_apps.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "acl_roles",
            "from_column": "app_id",
            "to_table": "acl_apps",
            "to_column": "id",
            "condition": "acl_roles.app_id = acl_apps.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "acl_apps",
            "from_column": "id",
            "to_table": "acl_audit_permission_logs",
            "to_column": "app_id",
            "condition": "acl_apps.id = acl_audit_permission_logs.app_id",
            "confidence": "high",
            "reasoning": "The acl_audit_permission_logs table contains an app_id field of type int, which matches the primary key id of acl_apps. The business logic suggests that each audit log entry is associated with a specific application, and the naming and data type conventions strongly indicate that app_id in the logs references the id in acl_apps. This is a common foreign key pattern, even though the constraint is not explicitly defined.",
            "test_sql": "SELECT COUNT(*) FROM acl_apps t1 JOIN acl_audit_permission_logs t2 ON t1.id = t2.app_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_apps",
            "from_column": "id",
            "to_table": "acl_audit_role_logs",
            "to_column": "app_id",
            "condition": "acl_apps.id = acl_audit_role_logs.app_id",
            "confidence": "high",
            "reasoning": "The acl_audit_role_logs table contains an app_id column of type int, which matches the primary key id of acl_apps. The business purpose of acl_audit_role_logs is to audit role-related actions within the context of a specific application, and the app_id field likely references the application being audited. This is a common foreign key pattern, even though the foreign key is not explicitly defined in the schema.",
            "test_sql": "SELECT COUNT(*) FROM acl_apps t1 JOIN acl_audit_role_logs t2 ON t1.id = t2.app_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_apps",
            "from_column": "id",
            "to_table": "acl_audit_resource_logs",
            "to_column": "app_id",
            "condition": "acl_apps.id = acl_audit_resource_logs.app_id",
            "confidence": "high",
            "reasoning": "The acl_audit_resource_logs table contains an app_id column of type int, which matches the primary key id of acl_apps. The business logic suggests that each audit log entry is associated with a specific application registered in acl_apps. This is a common pattern where logs reference the entity (application) they pertain to. The naming convention and data type compatibility further support this relationship, even though no explicit foreign key is defined.",
            "test_sql": "SELECT COUNT(*) FROM acl_apps t1 JOIN acl_audit_resource_logs t2 ON t1.id = t2.app_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_login_logs",
            "from_column": "username",
            "to_table": "users",
            "to_column": "username",
            "condition": "acl_audit_login_logs.username = users.username",
            "confidence": "high",
            "reasoning": "Both tables have a 'username' field with similar naming and compatible data types (varchar). The business logic of login logs typically references the user account by username. The 'username' field in 'users' is unique, making it a suitable candidate for joining login events to user profiles. This is a common pattern in authentication/audit systems.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_login_logs t1 JOIN users t2 ON t1.username = t2.username LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "resource_type_id",
            "to_table": "acl_resource_types",
            "to_column": "id",
            "condition": "acl_audit_permission_logs.resource_type_id = acl_resource_types.id",
            "confidence": "high",
            "reasoning": "Both tables use the field 'resource_type_id' (in acl_audit_permission_logs) and 'id' (in acl_resource_types) with compatible integer types. The business logic indicates that audit logs reference the type of resource affected by a permission operation, and resource types are defined in acl_resource_types. This is a common foreign key pattern, even though the foreign key is not explicitly declared.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_resource_types t2 ON t1.resource_type_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "app_id",
            "to_table": "acl_role_permissions",
            "to_column": "app_id",
            "condition": "acl_audit_permission_logs.app_id = acl_role_permissions.app_id",
            "confidence": "high",
            "reasoning": "Both tables use the field 'app_id' to reference an application context. This is a common pattern in access control systems to scope permissions and audit logs to a specific application. The data types are compatible (int), and the business logic suggests that permission changes (logged in acl_audit_permission_logs) are likely related to permission assignments (in acl_role_permissions) within the same application.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_role_permissions t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1072,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "rid",
            "to_table": "acl_role_permissions",
            "to_column": "rid",
            "condition": "acl_audit_permission_logs.rid = acl_role_permissions.rid",
            "confidence": "high",
            "reasoning": "The 'rid' field in both tables likely refers to a role identifier. In acl_role_permissions, it is used to assign permissions to roles, and in acl_audit_permission_logs, it is used to log actions related to roles. The matching field names and types (int) strongly suggest a logical relationship, where audit logs can be joined to permission assignments by role.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_role_permissions t2 ON t1.rid = t2.rid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 498,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "app_id",
            "to_table": "acl_audit_resource_logs",
            "to_column": "app_id",
            "condition": "acl_audit_permission_logs.app_id = acl_audit_resource_logs.app_id",
            "confidence": "high",
            "reasoning": "Both tables use 'app_id' to reference the application context for the audit log entry. This is a common pattern for multi-tenant or multi-application systems, and joining on 'app_id' allows correlation of permission and resource audit logs within the same application.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_audit_resource_logs t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 144,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "operate_uid",
            "to_table": "acl_audit_resource_logs",
            "to_column": "operate_uid",
            "condition": "acl_audit_permission_logs.operate_uid = acl_audit_resource_logs.operate_uid",
            "confidence": "high",
            "reasoning": "Both tables record the user/operator who performed the action using the 'operate_uid' field. Joining on this field allows analysis of all actions performed by a specific operator across both permission and resource audit logs.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_audit_resource_logs t2 ON t1.operate_uid = t2.operate_uid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 42,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "operate_uid",
            "to_table": "users",
            "to_column": "uid",
            "condition": "acl_audit_permission_logs.operate_uid = users.uid",
            "confidence": "high",
            "reasoning": "The field 'operate_uid' in acl_audit_permission_logs is an integer and likely represents the user ID of the operator who performed the permission-related action. The 'uid' field in users is the primary key for user records. This is a common pattern in audit logging, where actions are attributed to users by their unique IDs.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN users t2 ON t1.operate_uid = t2.uid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "operate_uid",
            "to_table": "common_employee",
            "to_column": "acl_uid",
            "condition": "acl_audit_permission_logs.operate_uid = common_employee.acl_uid",
            "confidence": "high",
            "reasoning": "The 'operate_uid' field in 'acl_audit_permission_logs' likely represents the unique identifier of the employee who performed the permission operation. In 'common_employee', 'acl_uid' appears to be the access control system's unique identifier for an employee. Both are of type int and serve as unique identifiers in the context of access control. This is a common pattern in audit logging, where actions are attributed to users/employees via their unique IDs.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN common_employee t2 ON t1.operate_uid = t2.acl_uid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "link_id",
            "to_table": "acl_resources",
            "to_column": "id",
            "condition": "acl_audit_resource_logs.link_id = acl_resources.id",
            "confidence": "high",
            "reasoning": "The 'link_id' field in 'acl_audit_resource_logs' is likely intended to reference the primary key 'id' of a resource in 'acl_resources'. This is supported by the business purpose of the audit log table, which is to track changes to resources, and by the common database pattern of using a generic 'link_id' to point to the affected entity. Both fields are of type 'int', and the naming convention suggests a direct relationship.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN acl_resources t2 ON t1.link_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "app_id",
            "to_table": "acl_audit_role_logs",
            "to_column": "app_id",
            "condition": "acl_audit_resource_logs.app_id = acl_audit_role_logs.app_id",
            "confidence": "high",
            "reasoning": "Both tables track audit logs within the context of an application, as indicated by the 'app_id' field. This field is present in both tables, has the same data type, and is likely to represent the same application entity. Joining on 'app_id' allows correlation of resource and role audit logs within the same application context.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN acl_audit_role_logs t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "operate_uid",
            "to_table": "users",
            "to_column": "uid",
            "condition": "acl_audit_resource_logs.operate_uid = users.uid",
            "confidence": "high",
            "reasoning": "The field 'operate_uid' in acl_audit_resource_logs is an integer and likely represents the user who performed the operation. The 'uid' field in users is the primary key for user identification. The naming convention, data type compatibility, and business logic (tracking which user performed an action) strongly suggest a foreign key or logical relationship between these fields.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN users t2 ON t1.operate_uid = t2.uid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_role_logs",
            "from_column": "link_id",
            "to_table": "acl_roles",
            "to_column": "id",
            "condition": "acl_audit_role_logs.link_id = acl_roles.id",
            "confidence": "high",
            "reasoning": "The acl_audit_role_logs table is an audit log for role-related actions. The field link_id is likely intended to reference the id of the role being acted upon in acl_roles, as this is a common pattern in audit logging (linking log entries to the primary key of the affected entity). Both fields are of type int, and the business logic supports tracking changes to roles.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_role_logs t1 JOIN acl_roles t2 ON t1.link_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "acl_permissions",
            "from_column": "resource_type_id",
            "to_table": "acl_resource_types",
            "to_column": "id",
            "condition": "acl_permissions.resource_type_id = acl_resource_types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "acl_role_permissions",
            "from_column": "perm_id",
            "to_table": "acl_permissions",
            "to_column": "id",
            "condition": "acl_role_permissions.perm_id = acl_permissions.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "acl_resources",
            "from_column": "resource_type_id",
            "to_table": "acl_resource_types",
            "to_column": "id",
            "condition": "acl_resources.resource_type_id = acl_resource_types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "acl_role_permissions",
            "from_column": "resource_id",
            "to_table": "acl_resources",
            "to_column": "id",
            "condition": "acl_role_permissions.resource_id = acl_resources.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "acl_role_permissions",
            "from_column": "rid",
            "to_table": "acl_roles",
            "to_column": "id",
            "condition": "acl_role_permissions.rid = acl_roles.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "acl_role_relations",
            "from_column": "parent_id",
            "to_table": "acl_roles",
            "to_column": "id",
            "condition": "acl_role_relations.parent_id = acl_roles.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "acl_role_relations",
            "from_column": "child_id",
            "to_table": "acl_roles",
            "to_column": "id",
            "condition": "acl_role_relations.child_id = acl_roles.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "acl_role_permissions",
            "from_column": "app_id",
            "to_table": "acl_role_relations",
            "to_column": "app_id",
            "condition": "acl_role_permissions.app_id = acl_role_relations.app_id",
            "confidence": "high",
            "reasoning": "Both tables use app_id to scope their data to a specific application. This join is useful for filtering or aggregating data within the same application context, and is a common pattern in multi-tenant or modular systems.",
            "test_sql": "SELECT COUNT(*) FROM acl_role_permissions t1 JOIN acl_role_relations t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 134,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "acl_roles",
            "from_column": "uid",
            "to_table": "users",
            "to_column": "uid",
            "condition": "acl_roles.uid = users.uid",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_ad_ci_types",
            "from_column": "adr_id",
            "to_table": "c_ad_rules",
            "to_column": "id",
            "condition": "c_ad_ci_types.adr_id = c_ad_rules.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_ad_ci_types",
            "from_column": "type_id",
            "to_table": "c_ci_types",
            "to_column": "id",
            "condition": "c_ad_ci_types.type_id = c_ci_types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "c_ad_ci_types",
            "from_column": "type_id",
            "to_table": "c_ci_type_attributes",
            "to_column": "type_id",
            "condition": "c_ad_ci_types.type_id = c_ci_type_attributes.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' column of the same data type (int), and both reference the concept of a CI type. In c_ad_ci_types, 'type_id' links a CI type to an AD rule, while in c_ci_type_attributes, 'type_id' links a CI type to its attributes. This suggests that records in c_ad_ci_types can be joined to c_ci_type_attributes to retrieve the attributes associated with the CI type involved in the AD rule mapping. This is a common pattern in configuration management systems.",
            "test_sql": "SELECT COUNT(*) FROM c_ad_ci_types t1 JOIN c_ci_type_attributes t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 22,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ad_ci_types",
            "from_column": "type_id",
            "to_table": "c_ci_type_attribute_groups",
            "to_column": "type_id",
            "condition": "c_ad_ci_types.type_id = c_ci_type_attribute_groups.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' column of type int, and both reference the same business concept: a CI type. The business purpose of c_ad_ci_types is to map CI types to AD rules, while c_ci_type_attribute_groups organizes attribute groups for CI types. It is logical to join these tables on 'type_id' to analyze or display all attribute groups relevant to a CI type that is also mapped to an AD rule.",
            "test_sql": "SELECT COUNT(*) FROM c_ad_ci_types t1 JOIN c_ci_type_attribute_groups t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_roles",
            "from_column": "id",
            "to_table": "common_employee",
            "to_column": "acl_rid",
            "condition": "acl_roles.id = common_employee.acl_rid",
            "confidence": "high",
            "reasoning": "The field 'acl_rid' in 'common_employee' is likely intended to reference the primary key 'id' of 'acl_roles', based on naming conventions (acl_rid = ACL Role ID), data type compatibility (both are int), and common access control patterns where an employee is assigned a role. This is a typical foreign key relationship, even though it is not explicitly defined in the schema.",
            "test_sql": "SELECT COUNT(*) FROM acl_roles t1 JOIN common_employee t2 ON t1.id = t2.acl_rid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ad_ci_types",
            "from_column": "type_id",
            "to_table": "c_psa",
            "to_column": "type_id",
            "condition": "c_ad_ci_types.type_id = c_psa.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' field of the same data type (int), and both reference the concept of a 'type' in their business purposes. 'type_id' is a foreign key in both tables (to the same external table, not shown here), and it is reasonable to infer that records in both tables can be related by their shared 'type_id' value. This allows for joining all configuration/rule associations (c_ad_ci_types) with all attribute mappings (c_psa) for the same type.",
            "test_sql": "SELECT COUNT(*) FROM c_ad_ci_types t1 JOIN c_psa t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 14,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ad_ci_types",
            "from_column": "uid",
            "to_table": "users",
            "to_column": "uid",
            "condition": "c_ad_ci_types.uid = users.uid",
            "confidence": "high",
            "reasoning": "Both tables have a column named 'uid' of type int. In c_ad_ci_types, 'uid' is a nullable, indexed field, and in users, 'uid' is the primary key. The business logic suggests that 'uid' in c_ad_ci_types likely references the user who created, owns, or is responsible for the CI type-rule association. This is a common pattern for tracking ownership or authorship in configuration or mapping tables.",
            "test_sql": "SELECT COUNT(*) FROM c_ad_ci_types t1 JOIN users t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "attr_id",
            "to_table": "c_attributes",
            "to_column": "id",
            "condition": "c_attribute_histories.attr_id = c_attributes.id",
            "confidence": "high",
            "reasoning": "The field c_attribute_histories.attr_id is named and typed identically to c_attributes.id, which is the primary key of c_attributes. The business purpose of c_attribute_histories is to track changes to attributes, and attr_id would logically reference the attribute being changed. This is a common database pattern for audit/history tables referencing the definition table.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_attributes t2 ON t1.attr_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 14160,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "ci_id",
            "to_table": "c_cis",
            "to_column": "id",
            "condition": "c_attribute_histories.ci_id = c_cis.id",
            "confidence": "high",
            "reasoning": "The field c_attribute_histories.ci_id is an integer and matches the primary key c_cis.id. The naming convention ('ci' likely stands for 'configuration item'), data type compatibility, and business logic (tracking attribute changes for configuration items) strongly suggest that ci_id references c_cis.id. This is a common pattern in configuration management databases, where attribute history is linked to the configuration item it describes.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_cis t2 ON t1.ci_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 11600,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "c_attribute_histories",
            "from_column": "record_id",
            "to_table": "c_records",
            "to_column": "id",
            "condition": "c_attribute_histories.record_id = c_records.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_choice_texts",
            "from_column": "attr_id",
            "to_table": "c_attributes",
            "to_column": "id",
            "condition": "c_choice_texts.attr_id = c_attributes.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_ci_type_attribute_group_items",
            "from_column": "attr_id",
            "to_table": "c_attributes",
            "to_column": "id",
            "condition": "c_ci_type_attribute_group_items.attr_id = c_attributes.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_ci_type_attributes",
            "from_column": "attr_id",
            "to_table": "c_attributes",
            "to_column": "id",
            "condition": "c_ci_type_attributes.attr_id = c_attributes.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "ci_id, attr_id",
            "to_table": "c_value_index_integers",
            "to_column": "ci_id, attr_id",
            "condition": "c_attribute_histories.ci_id = c_value_index_integers.ci_id AND c_attribute_histories.attr_id = c_value_index_integers.attr_id",
            "confidence": "high",
            "reasoning": "The combination of ci_id and attr_id in both tables strongly suggests a direct relationship: both tables track data about the same attribute of the same configuration item. This enables joining history records to current values for auditing or comparison. This is a common pattern in attribute-value data models.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_value_index_integers t2 ON t1.ci_id = t2.ci_id AND t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1536,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "c_ci_types",
            "from_column": "unique_id",
            "to_table": "c_attributes",
            "to_column": "id",
            "condition": "c_ci_types.unique_id = c_attributes.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_psa",
            "from_column": "attr_id",
            "to_table": "c_attributes",
            "to_column": "id",
            "condition": "c_psa.attr_id = c_attributes.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "ci_id, attr_id",
            "to_table": "c_value_texts",
            "to_column": "ci_id, attr_id",
            "condition": "c_attribute_histories.ci_id = c_value_texts.ci_id AND c_attribute_histories.attr_id = c_value_texts.attr_id",
            "confidence": "high",
            "reasoning": "The combination of ci_id and attr_id in both tables strongly suggests a logical relationship: c_attribute_histories tracks changes to attribute values for a specific entity and attribute, while c_value_texts stores the current value for that same entity-attribute pair. This is a common pattern in audit/history tracking systems.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_value_texts t2 ON t1.ci_id = t2.ci_id AND t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2304,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "c_value_index_integers",
            "from_column": "attr_id",
            "to_table": "c_attributes",
            "to_column": "id",
            "condition": "c_value_index_integers.attr_id = c_attributes.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_value_index_texts",
            "from_column": "attr_id",
            "to_table": "c_attributes",
            "to_column": "id",
            "condition": "c_value_index_texts.attr_id = c_attributes.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_value_texts",
            "from_column": "attr_id",
            "to_table": "c_attributes",
            "to_column": "id",
            "condition": "c_value_texts.attr_id = c_attributes.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "c_choice_texts",
            "from_column": "attr_id",
            "to_table": "c_ci_type_attribute_group_items",
            "to_column": "attr_id",
            "condition": "c_choice_texts.attr_id = c_ci_type_attribute_group_items.attr_id",
            "confidence": "high",
            "reasoning": "Both tables have an attr_id field of the same data type (int), and both reference the concept of an attribute. In c_choice_texts, attr_id identifies which attribute a choice belongs to; in c_ci_type_attribute_group_items, attr_id identifies which attribute is assigned to a group. This suggests a logical relationship: for any attribute assigned to a group, you may want to retrieve its selectable choices. This is a common business logic pattern in configuration or form systems.",
            "test_sql": "SELECT COUNT(*) FROM c_choice_texts t1 JOIN c_ci_type_attribute_group_items t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 10,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_choice_texts",
            "from_column": "attr_id",
            "to_table": "c_ci_type_attributes",
            "to_column": "attr_id",
            "condition": "c_choice_texts.attr_id = c_ci_type_attributes.attr_id",
            "confidence": "high",
            "reasoning": "Both tables have an attr_id field of type int, and both reference the concept of an attribute. In c_choice_texts, attr_id identifies which attribute the choice belongs to; in c_ci_type_attributes, attr_id identifies which attribute is associated with a CI type. This suggests that for a given attribute (attr_id), you can find both its selectable choices (from c_choice_texts) and its association with CI types (from c_ci_type_attributes). This is a common pattern in systems where attributes have both metadata (association to types) and value options (choices).",
            "test_sql": "SELECT COUNT(*) FROM c_choice_texts t1 JOIN c_ci_type_attributes t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 18,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "c_ci_relations",
            "from_column": "first_ci_id",
            "to_table": "c_cis",
            "to_column": "id",
            "condition": "c_ci_relations.first_ci_id = c_cis.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_ci_relations",
            "from_column": "second_ci_id",
            "to_table": "c_cis",
            "to_column": "id",
            "condition": "c_ci_relations.second_ci_id = c_cis.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_ci_relations",
            "from_column": "more",
            "to_table": "c_cis",
            "to_column": "id",
            "condition": "c_ci_relations.more = c_cis.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_ci_relations",
            "from_column": "relation_type_id",
            "to_table": "c_relation_types",
            "to_column": "id",
            "condition": "c_ci_relations.relation_type_id = c_relation_types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "c_choice_texts",
            "from_column": "attr_id",
            "to_table": "c_value_index_texts",
            "to_column": "attr_id",
            "condition": "c_choice_texts.attr_id = c_value_index_texts.attr_id",
            "confidence": "high",
            "reasoning": "Both tables use the attr_id field to reference the same attribute concept. c_choice_texts defines possible selectable values for an attribute, while c_value_index_texts stores the actual value chosen for that attribute for a specific entity. This is a common pattern in attribute-driven systems, where one table defines the options and another records the selected value. The data types are compatible (both int), and the business logic aligns.",
            "test_sql": "SELECT COUNT(*) FROM c_choice_texts t1 JOIN c_value_index_texts t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7680,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_choice_texts",
            "from_column": "attr_id, value",
            "to_table": "c_value_index_texts",
            "to_column": "attr_id, value",
            "condition": "c_choice_texts.attr_id = c_value_index_texts.attr_id AND c_choice_texts.value = c_value_index_texts.value",
            "confidence": "high",
            "reasoning": "Combining both attr_id and value provides a strong logical relationship: for a given attribute, the value stored in c_value_index_texts should correspond to one of the allowed choices in c_choice_texts. This is a common pattern for enforcing referential integrity in systems with selectable options. The data types are compatible, and the business logic is clear.",
            "test_sql": "SELECT COUNT(*) FROM c_choice_texts t1 JOIN c_value_index_texts t2 ON t1.attr_id = t2.attr_id AND t1.value = t2.value LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2304,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_relations",
            "from_column": "id",
            "to_table": "c_relation_histories",
            "to_column": "relation_id",
            "condition": "c_ci_relations.id = c_relation_histories.relation_id",
            "confidence": "high",
            "reasoning": "The c_relation_histories table contains a field named relation_id, which by naming convention and business logic likely refers to the primary key (id) of the c_ci_relations table. This is a common pattern for tracking the history of changes to a record in another table. Both fields are of type int and non-nullable, supporting a direct join. The business purpose of c_relation_histories is to audit changes to relationships, which are defined in c_ci_relations.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_relations t1 JOIN c_relation_histories t2 ON t1.id = t2.relation_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 840,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "c_ci_type_attribute_group_items",
            "from_column": "group_id",
            "to_table": "c_ci_type_attribute_groups",
            "to_column": "id",
            "condition": "c_ci_type_attribute_group_items.group_id = c_ci_type_attribute_groups.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "c_ci_relations",
            "from_column": "first_ci_id",
            "to_table": "c_value_index_texts",
            "to_column": "ci_id",
            "condition": "c_ci_relations.first_ci_id = c_value_index_texts.ci_id",
            "confidence": "high",
            "reasoning": "Both fields represent a reference to a configuration item (CI) by its ID. It is logical to join on these fields to retrieve attribute values for the 'first' CI in a relationship.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_relations t1 JOIN c_value_index_texts t2 ON t1.first_ci_id = t2.ci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 840,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_relations",
            "from_column": "second_ci_id",
            "to_table": "c_value_index_texts",
            "to_column": "ci_id",
            "condition": "c_ci_relations.second_ci_id = c_value_index_texts.ci_id",
            "confidence": "high",
            "reasoning": "Both fields represent a reference to a configuration item (CI) by its ID. It is logical to join on these fields to retrieve attribute values for the 'second' CI in a relationship.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_relations t1 JOIN c_value_index_texts t2 ON t1.second_ci_id = t2.ci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7753,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_relations",
            "from_column": "second_ci_id",
            "to_table": "c_value_index_integers",
            "to_column": "ci_id",
            "condition": "c_ci_relations.second_ci_id = c_value_index_integers.ci_id",
            "confidence": "high",
            "reasoning": "Both fields represent a reference to a configuration item (CI) by its ID. This join enables retrieval of attribute values for the 'second' CI in a relationship, which is a common pattern in configuration management systems for analyzing related assets.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_relations t1 JOIN c_value_index_integers t2 ON t1.second_ci_id = t2.ci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1536,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attribute_group_items",
            "from_column": "attr_id",
            "to_table": "c_value_index_integers",
            "to_column": "attr_id",
            "condition": "c_ci_type_attribute_group_items.attr_id = c_value_index_integers.attr_id",
            "confidence": "high",
            "reasoning": "Both tables reference an 'attr_id' field of type int, which links to the same conceptual entity: an attribute. In c_ci_type_attribute_group_items, 'attr_id' associates an attribute with a group; in c_value_index_integers, 'attr_id' associates an attribute with a value for a configuration item. This allows for joining to find, for example, all values for attributes that belong to a specific group, or to check which attributes in a group have values assigned for a CI. This is a common business logic relationship in dynamic attribute models.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attribute_group_items t1 JOIN c_value_index_integers t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1536,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "c_ci_type_attribute_groups",
            "from_column": "type_id",
            "to_table": "c_ci_types",
            "to_column": "id",
            "condition": "c_ci_type_attribute_groups.type_id = c_ci_types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_ci_type_attributes",
            "from_column": "type_id",
            "to_table": "c_ci_types",
            "to_column": "id",
            "condition": "c_ci_type_attributes.type_id = c_ci_types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attributes",
            "from_column": "type_id",
            "to_table": "c_cis",
            "to_column": "type_id",
            "condition": "c_ci_type_attributes.type_id = c_cis.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' field of the same data type (int), and both reference the concept of a CI type. 'c_ci_type_attributes' defines which attributes are available for each CI type, while 'c_cis' stores individual configuration items and their type. Joining on 'type_id' allows you to determine which attributes are relevant for each configuration item based on its type. This is a common pattern in configuration management and asset management systems.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attributes t1 JOIN c_cis t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 17300,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attributes",
            "from_column": "type_id",
            "to_table": "c_ptv",
            "to_column": "type_id",
            "condition": "c_ci_type_type_attributes.type_id = c_ptv.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' field of type int, and both reference the concept of a CI type. In c_ci_type_attributes, 'type_id' defines which CI type the attribute mapping applies to. In c_ptv, 'type_id' defines the type of the record. This suggests that records in c_ptv are instances of a CI type, and c_ci_type_attributes defines the attributes for that type. Joining on 'type_id' allows you to retrieve the attribute configuration for each c_ptv record's type.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attributes t1 JOIN c_ptv t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 22,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attributes",
            "from_column": "attr_id",
            "to_table": "c_value_index_integers",
            "to_column": "attr_id",
            "condition": "c_ci_type_attributes.attr_id = c_value_index_integers.attr_id",
            "confidence": "high",
            "reasoning": "Both tables use attr_id as a foreign key to reference attribute definitions. In business logic, c_ci_type_attributes defines which attributes are available for each CI type, while c_value_index_integers stores the values for those attributes for specific CIs. Joining on attr_id allows analysis of which attribute values are present for attributes configured for CI types.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attributes t1 JOIN c_value_index_integers t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1536,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attributes",
            "from_column": "attr_id",
            "to_table": "c_value_index_texts",
            "to_column": "attr_id",
            "condition": "c_ci_type_attributes.attr_id = c_value_index_texts.attr_id",
            "confidence": "high",
            "reasoning": "Both tables reference the same attribute identifier (attr_id), which links attribute definitions/configurations (in c_ci_type_attributes) to actual attribute values (in c_value_index_texts). This is a common pattern in systems where one table defines which attributes are available for a type, and another stores the values for those attributes. The data types are compatible (int), and the business logic aligns with attribute-driven data modeling.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attributes t1 JOIN c_value_index_texts t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 11595,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "c_ci_type_relations",
            "from_column": "parent_id",
            "to_table": "c_ci_types",
            "to_column": "id",
            "condition": "c_ci_type_relations.parent_id = c_ci_types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_ci_type_relations",
            "from_column": "child_id",
            "to_table": "c_ci_types",
            "to_column": "id",
            "condition": "c_ci_type_relations.child_id = c_ci_types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attributes",
            "from_column": "type_id",
            "to_table": "c_psa",
            "to_column": "type_id",
            "condition": "c_ci_type_attributes.type_id = c_psa.type_id",
            "confidence": "high",
            "reasoning": "Both tables use 'type_id' as a foreign key to reference the same conceptual entity (a CI type). This suggests that records in both tables can be meaningfully grouped or joined by 'type_id' to analyze or configure attributes for a given type. This is a common pattern in configuration management systems.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attributes t1 JOIN c_psa t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 352,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attributes",
            "from_column": "type_id, attr_id",
            "to_table": "c_psa",
            "to_column": "type_id, attr_id",
            "condition": "c_ci_type_attributes.type_id = c_psa.type_id AND c_ci_type_attributes.attr_id = c_psa.attr_id",
            "confidence": "high",
            "reasoning": "Both tables represent mappings between CI types and attributes, and both have 'type_id' and 'attr_id' columns. Joining on both fields allows for direct comparison or correlation of the same type-attribute pair across both tables. This is a classic many-to-many mapping pattern and is likely to be meaningful for business logic or data integrity checks.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attributes t1 JOIN c_psa t2 ON t1.type_id = t2.type_id AND t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 24,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "c_ci_type_relations",
            "from_column": "relation_type_id",
            "to_table": "c_relation_types",
            "to_column": "id",
            "condition": "c_ci_type_relations.relation_type_id = c_relation_types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_cis",
            "from_column": "type_id",
            "to_table": "c_ci_types",
            "to_column": "id",
            "condition": "c_cis.type_id = c_ci_types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_psa",
            "from_column": "type_id",
            "to_table": "c_ci_types",
            "to_column": "id",
            "condition": "c_psa.type_id = c_ci_types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_ptv",
            "from_column": "type_id",
            "to_table": "c_ci_types",
            "to_column": "id",
            "condition": "c_ptv.type_id = c_ci_types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_relations",
            "from_column": "parent_id",
            "to_table": "c_cis",
            "to_column": "type_id",
            "condition": "c_ci_type_relations.parent_id = c_cis.type_id",
            "confidence": "high",
            "reasoning": "Both fields represent a reference to a CI type. c_ci_type_relations models relationships between CI types (parent_id and child_id), while c_cis.type_id indicates the type of a configuration item. This join allows you to find all configuration items (CIs) that are of a type which is a 'parent' in a CI type relationship.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_relations t1 JOIN c_cis t2 ON t1.parent_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2442,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_relations",
            "from_column": "child_id",
            "to_table": "c_cis",
            "to_column": "type_id",
            "condition": "c_ci_type_relations.child_id = c_cis.type_id",
            "confidence": "high",
            "reasoning": "Similarly, child_id in c_ci_type_relations references a CI type, and c_cis.type_id is the type of a configuration item. This join allows you to find all configuration items that are of a type which is a 'child' in a CI type relationship.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_relations t1 JOIN c_cis t2 ON t1.child_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 840,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "c_value_index_integers",
            "from_column": "ci_id",
            "to_table": "c_cis",
            "to_column": "id",
            "condition": "c_value_index_integers.ci_id = c_cis.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_value_index_texts",
            "from_column": "ci_id",
            "to_table": "c_cis",
            "to_column": "id",
            "condition": "c_value_index_texts.ci_id = c_cis.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "foreign_key",
            "from_table": "c_value_texts",
            "from_column": "ci_id",
            "to_table": "c_cis",
            "to_column": "id",
            "condition": "c_value_texts.ci_id = c_cis.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "c_prv",
            "from_column": "uid",
            "to_table": "users",
            "to_column": "uid",
            "condition": "c_prv.uid = users.uid",
            "confidence": "high",
            "reasoning": "Both tables have a field named 'uid' of type int, and the business logic suggests that c_prv records are owned or created by users. The 'uid' in c_prv is a non-nullable field and is indexed, which is typical for a foreign key reference to a user table's primary key. This is a standard one-to-many relationship where each user (users.uid) can have multiple c_prv records (c_prv.uid).",
            "test_sql": "SELECT COUNT(*) FROM c_prv t1 JOIN users t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_psa",
            "from_column": "type_id",
            "to_table": "c_ptv",
            "to_column": "type_id",
            "condition": "c_psa.type_id = c_ptv.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a non-nullable type_id field of the same data type (int), and both reference the concept of a 'type' in their business purposes. The c_psa table configures which attributes are available for a given type, while c_ptv stores records of that type. It is common in database design to join configuration/mapping tables to data tables via a shared type_id to retrieve attribute configurations for records of a given type.",
            "test_sql": "SELECT COUNT(*) FROM c_psa t1 JOIN c_ptv t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 14,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_psa",
            "from_column": "uid",
            "to_table": "users",
            "to_column": "uid",
            "condition": "c_psa.uid = users.uid",
            "confidence": "high",
            "reasoning": "Both tables have a field named 'uid' of type int, and in c_psa, 'uid' is a required (NOT NULL) field with an index. In users, 'uid' is the primary key. This strongly suggests that c_psa.uid is a foreign key referencing users.uid, likely indicating which user created, owns, or is associated with the c_psa record. This is a common pattern for tracking ownership or authorship in configuration or mapping tables.",
            "test_sql": "SELECT COUNT(*) FROM c_psa t1 JOIN users t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 24,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "c_relation_histories",
            "from_column": "record_id",
            "to_table": "c_records",
            "to_column": "id",
            "condition": "c_relation_histories.record_id = c_records.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "c_ptv",
            "from_column": "uid",
            "to_table": "users",
            "to_column": "uid",
            "condition": "c_ptv.uid = users.uid",
            "confidence": "high",
            "reasoning": "Both tables have a column named 'uid' of type int and not nullable. In c_ptv, 'uid' is indexed and required, and in users, 'uid' is the primary key. The business logic suggests that c_ptv records are associated with a user (e.g., created by, owned by, or related to a user). This is a common pattern where a business entity references the user who owns or is responsible for the record.",
            "test_sql": "SELECT COUNT(*) FROM c_ptv t1 JOIN users t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "c_relation_histories",
            "from_column": "relation_type_id",
            "to_table": "c_relation_types",
            "to_column": "id",
            "condition": "c_relation_histories.relation_type_id = c_relation_types.id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "c_records",
            "from_column": "uid",
            "to_table": "users",
            "to_column": "uid",
            "condition": "c_records.uid = users.uid",
            "confidence": "high",
            "reasoning": "Both tables have a column named 'uid' of type int, with 'uid' being the primary key in users and a non-null, indexed field in c_records. The business logic suggests that c_records logs actions or events associated with users, making it likely that c_records.uid references users.uid. This is a common foreign key pattern, even though it is not explicitly defined.",
            "test_sql": "SELECT COUNT(*) FROM c_records t1 JOIN users t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 15256,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_records",
            "from_column": "uid",
            "to_table": "common_employee",
            "to_column": "employee_id",
            "condition": "c_records.uid = common_employee.employee_id",
            "confidence": "high",
            "reasoning": "The field c_records.uid is an integer, non-null, and indexed, which matches the primary key common_employee.employee_id. The business purpose of c_records is to log actions or events associated with unique users or entities, and common_employee represents employees. It is a common pattern for a log or record table to reference the primary key of an employee table to associate records with specific employees. The naming convention (uid vs employee_id) is not identical but is compatible, and the data types match.",
            "test_sql": "SELECT COUNT(*) FROM c_records t1 JOIN common_employee t2 ON t1.uid = t2.employee_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 15251,
            "verification_method": "sql_test"
        },
        {
            "type": "foreign_key",
            "from_table": "common_employee",
            "from_column": "department_id",
            "to_table": "common_department",
            "to_column": "department_id",
            "condition": "common_employee.department_id = common_department.department_id",
            "confidence": "high",
            "reasoning": "Explicit foreign key constraint",
            "relationship_type": "foreign_key",
            "verified": true
        },
        {
            "type": "inferred",
            "from_table": "acl_apps",
            "from_column": "name",
            "to_table": "acl_operation_records",
            "to_column": "app",
            "condition": "acl_apps.name = acl_operation_records.app",
            "confidence": "high",
            "reasoning": "The 'app' field in 'acl_operation_records' likely refers to an application context. The closest matching field in 'acl_apps' is 'name' (both are varchar, and 'name' is indexed). While there is no explicit foreign key, it is common for operation logs to reference applications by name or code. However, the data type length differs (64 vs 32), and there is no guarantee of strict referential integrity, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM acl_apps t1 JOIN acl_operation_records t2 ON t1.name = t2.app LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 27,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_login_logs",
            "from_column": "username",
            "to_table": "common_employee",
            "to_column": "username",
            "condition": "acl_audit_login_logs.username = common_employee.username",
            "confidence": "high",
            "reasoning": "Both tables have a 'username' field of compatible types (varchar). In the context of login auditing and employee management, it is common for login logs to reference the username of the employee attempting to log in. While there is no explicit foreign key, the business logic suggests that login events are likely associated with employees via their usernames.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_login_logs t1 JOIN common_employee t2 ON t1.username = t2.username LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "app_id",
            "to_table": "acl_audit_role_logs",
            "to_column": "app_id",
            "condition": "acl_audit_permission_logs.app_id = acl_audit_role_logs.app_id",
            "confidence": "high",
            "reasoning": "Both tables track audit logs for access control actions and include an app_id field of the same type and name, likely referencing the same application context. This allows for correlating permission and role changes within the same application.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_audit_role_logs t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "app_id",
            "to_table": "acl_resources",
            "to_column": "app_id",
            "condition": "acl_audit_permission_logs.app_id = acl_resources.app_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'app_id' field of the same type, likely referencing the same application context. This allows filtering or joining audit logs with resources belonging to the same application, which is a common business requirement in access control systems.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_resources t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 176,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "resource_type_id",
            "to_table": "acl_resources",
            "to_column": "resource_type_id",
            "condition": "acl_audit_permission_logs.resource_type_id = acl_resources.resource_type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'resource_type_id' field, which likely refers to the type of resource involved in the audit log or defined in the resources table. This enables analysis of audit logs by resource type and is a common pattern in access control systems.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_resources t2 ON t1.resource_type_id = t2.resource_type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 122,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "permission_ids",
            "to_table": "acl_permissions",
            "to_column": "id",
            "condition": "JSON_CONTAINS(acl_audit_permission_logs.permission_ids, CAST(acl_permissions.id AS JSON), '$')",
            "confidence": "high",
            "reasoning": "The 'permission_ids' field in 'acl_audit_permission_logs' is a JSON array that likely stores one or more permission IDs affected by an audit event. The 'id' field in 'acl_permissions' is the primary key for permissions. The business logic and naming conventions suggest that audit log entries reference permissions by their IDs, even though the relationship is not enforced by a foreign key. The data types are compatible (int in JSON array vs int PK), and this is a common pattern for logging many-to-many relationships.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_permissions t2 ON JSON_CONTAINS(t1.permission_ids, CAST(t2.id AS JSON), '$') LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 51,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "app_id",
            "to_table": "acl_permissions",
            "to_column": "app_id",
            "condition": "acl_audit_permission_logs.app_id = acl_permissions.app_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'app_id' field of type int, which likely refers to the application context for both the audit log and the permission. While this does not uniquely identify a permission, it allows for filtering or joining audit logs and permissions within the same application context. This is a common business logic relationship in access control systems.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_permissions t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 336,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "resource_type_id",
            "to_table": "acl_permissions",
            "to_column": "resource_type_id",
            "condition": "acl_audit_permission_logs.resource_type_id = acl_permissions.resource_type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'resource_type_id' field, which likely refers to the type of resource affected by the permission or the audit event. This allows for joining or filtering audit logs and permissions by resource type, which is a common pattern in access control systems.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_permissions t2 ON t1.resource_type_id = t2.resource_type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 95,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "app_id",
            "to_table": "acl_roles",
            "to_column": "app_id",
            "condition": "acl_audit_permission_logs.app_id = acl_roles.app_id",
            "confidence": "high",
            "reasoning": "Both tables have an app_id field of the same type (int), and both use it to reference the application context for their records. While this does not establish a direct entity-to-entity relationship, it allows for joining audit logs to roles within the same application, which is a common business requirement for filtering or reporting.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_roles t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 80,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "rid",
            "to_table": "acl_roles",
            "to_column": "id",
            "condition": "acl_audit_permission_logs.rid = acl_roles.id",
            "confidence": "high",
            "reasoning": "The acl_audit_permission_logs table has a field named rid (likely 'role id'), which matches the primary key id of acl_roles. This suggests that audit log entries may reference a specific role affected by a permission operation. The data types are compatible (both int), and the naming convention supports this inference.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_roles t2 ON t1.rid = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "source",
            "to_table": "acl_audit_resource_logs",
            "to_column": "source",
            "condition": "acl_audit_permission_logs.source = acl_audit_resource_logs.source",
            "confidence": "high",
            "reasoning": "The 'source' field in both tables may indicate the origin of the operation (e.g., API, UI, system). Joining on this field can help analyze audit logs by the source of the action, though the field's semantics are not fully defined.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_audit_resource_logs t2 ON t1.source = t2.source LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 144,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "app_id",
            "to_table": "acl_role_relations",
            "to_column": "app_id",
            "condition": "acl_audit_permission_logs.app_id = acl_role_relations.app_id",
            "confidence": "high",
            "reasoning": "Both tables contain an app_id field of the same type (int), and both are scoped to applications. While this does not represent a strict foreign key relationship, it is common to join audit logs with related entities by application context for reporting or filtering. However, this join alone does not establish a direct entity relationship between the two tables, only a shared context.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_role_relations t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 32,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "resource_type_id",
            "to_table": "c_ci_types",
            "to_column": "id",
            "condition": "acl_audit_permission_logs.resource_type_id = c_ci_types.id",
            "confidence": "high",
            "reasoning": "The field 'resource_type_id' in acl_audit_permission_logs is likely intended to reference the type or category of a resource involved in a permission operation. The c_ci_types table defines types of configuration items (which can be interpreted as resource types). Both fields are of type int and serve as identifiers for types, making this a plausible business logic relationship, even though no explicit foreign key is defined.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN c_ci_types t2 ON t1.resource_type_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "operate_uid",
            "to_table": "c_records",
            "to_column": "uid",
            "condition": "acl_audit_permission_logs.operate_uid = c_records.uid",
            "confidence": "high",
            "reasoning": "Both fields are of type int and represent user identifiers involved in actions: 'operate_uid' in acl_audit_permission_logs is the operator performing a permission change, while 'uid' in c_records is the user associated with a record. There is a plausible business logic relationship if c_records logs events or cases related to the same users who perform permission operations. However, without explicit foreign keys or more context, this is an inferred relationship based on naming and typical access control audit patterns.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN c_records t2 ON t1.operate_uid = t2.uid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 42,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "operate_uid",
            "to_table": "c_prv",
            "to_column": "uid",
            "condition": "acl_audit_permission_logs.operate_uid = c_prv.uid",
            "confidence": "high",
            "reasoning": "Both fields are named as user identifiers (operate_uid and uid) and are of the same integer type. While 'operate_uid' in the audit log likely refers to the user performing the operation, and 'uid' in c_prv refers to the owner of the record, there could be business logic to join audit logs with the entities owned by the same user. However, there is no explicit foreign key or guarantee that these represent the same domain entity, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN c_prv t2 ON t1.operate_uid = t2.uid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "app_id",
            "to_table": "acl_resource_types",
            "to_column": "app_id",
            "condition": "acl_audit_resource_logs.app_id = acl_resource_types.app_id",
            "confidence": "high",
            "reasoning": "Both tables contain an 'app_id' field of the same data type (int), and both use it to associate records with a specific application. While this does not establish a direct foreign key relationship between the two tables, it allows for logical grouping or filtering of audit logs and resource types by application. This is a common pattern in multi-tenant or application-scoped systems.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN acl_resource_types t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 63,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "app_id",
            "to_table": "acl_permissions",
            "to_column": "app_id",
            "condition": "acl_audit_resource_logs.app_id = acl_permissions.app_id",
            "confidence": "high",
            "reasoning": "Both tables contain an 'app_id' field of the same data type (int), and both are used to scope records to a specific application. While this does not represent a strict foreign key relationship, it is a common business logic pattern to join audit logs with permissions based on the application context. This join could be useful for reporting or filtering audit logs by permissions available within the same application.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN acl_permissions t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 189,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "app_id",
            "to_table": "acl_role_permissions",
            "to_column": "app_id",
            "condition": "acl_audit_resource_logs.app_id = acl_role_permissions.app_id",
            "confidence": "high",
            "reasoning": "Both tables contain an 'app_id' field of the same data type (int), and both are used to scope records to a specific application. While not a strict foreign key, joining on 'app_id' can be useful for correlating audit logs with permission assignments within the same application context.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN acl_role_permissions t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 603,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "app_id",
            "to_table": "acl_resources",
            "to_column": "app_id",
            "condition": "acl_audit_resource_logs.app_id = acl_resources.app_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'app_id' field of type 'int', which likely references the same application context. While this does not uniquely identify a resource, it allows grouping or filtering audit logs and resources by application. This is a common business logic relationship for multi-tenant or multi-application systems.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN acl_resources t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 99,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "app_id",
            "to_table": "acl_roles",
            "to_column": "app_id",
            "condition": "acl_audit_resource_logs.app_id = acl_roles.app_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'app_id' field of type int, and both are scoped to applications. While 'app_id' is not a unique key in either table, it is likely that audit logs are often filtered or grouped by application, and roles are also defined per application. This relationship allows for analysis of audit logs in the context of roles defined for the same application.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN acl_roles t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 45,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "link_id",
            "to_table": "c_ad_rules",
            "to_column": "id",
            "condition": "acl_audit_resource_logs.link_id = c_ad_rules.id",
            "confidence": "high",
            "reasoning": "The 'link_id' field in acl_audit_resource_logs is a generic integer that may reference a resource in another table. Given the business purpose of logging resource changes and the fact that c_ad_rules represents configurable rules (which are likely to be audited), it is plausible that some audit log entries track changes to ad rules, using 'link_id' to reference the rule's 'id'. However, since 'link_id' is generic and not explicitly defined as a foreign key to c_ad_rules, the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN c_ad_rules t2 ON t1.link_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "app_id",
            "to_table": "acl_role_relations",
            "to_column": "app_id",
            "condition": "acl_audit_resource_logs.app_id = acl_role_relations.app_id",
            "confidence": "high",
            "reasoning": "Both tables contain an 'app_id' field of the same type, which likely references the same application context. This allows filtering or joining audit logs and role relationships within the same application. However, this is not a strict foreign key relationship between the two tables, but rather a logical association based on application scope.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN acl_role_relations t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 18,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "operate_uid",
            "to_table": "c_prv",
            "to_column": "uid",
            "condition": "acl_audit_resource_logs.operate_uid = c_prv.uid",
            "confidence": "high",
            "reasoning": "Both fields are named to represent a user/operator ID and are of the same integer type. The audit log tracks actions performed by a user (operate_uid), while c_prv records are owned by a user (uid). It is plausible that actions in the audit log could be filtered or joined to the resources owned by the same user. However, there is no explicit foreign key or guarantee that operate_uid always matches c_prv.uid, so the relationship is inferred based on naming and business logic.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN c_prv t2 ON t1.operate_uid = t2.uid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "link_id",
            "to_table": "c_records",
            "to_column": "id",
            "condition": "acl_audit_resource_logs.link_id = c_records.id",
            "confidence": "high",
            "reasoning": "The field 'link_id' in acl_audit_resource_logs is an integer and likely serves as a generic foreign key to reference a resource. The 'id' field in c_records is the primary key. Given the business purposes, it is plausible that audit logs may reference specific records in c_records via link_id to track changes or actions performed on those records. However, this is not enforced by a foreign key constraint and is inferred based on naming and common design patterns.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN c_records t2 ON t1.link_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_role_logs",
            "from_column": "app_id",
            "to_table": "acl_permissions",
            "to_column": "app_id",
            "condition": "acl_audit_role_logs.app_id = acl_permissions.app_id",
            "confidence": "high",
            "reasoning": "Both tables contain an 'app_id' field of the same data type (int), which likely references the same application context. This allows for filtering or joining audit logs with permissions within the same application. However, this is not a strict foreign key relationship, as 'app_id' is not unique in either table and does not directly link a specific audit log to a specific permission.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_role_logs t1 JOIN acl_permissions t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 21,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_role_logs",
            "from_column": "app_id",
            "to_table": "acl_resources",
            "to_column": "app_id",
            "condition": "acl_audit_role_logs.app_id = acl_resources.app_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'app_id' field of the same type and name, likely referencing the same application context. This allows filtering or joining audit logs with resources belonging to the same application, which is a common pattern in access control systems.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_role_logs t1 JOIN acl_resources t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 11,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_role_logs",
            "from_column": "app_id",
            "to_table": "acl_resource_types",
            "to_column": "app_id",
            "condition": "acl_audit_role_logs.app_id = acl_resource_types.app_id",
            "confidence": "high",
            "reasoning": "Both tables contain an 'app_id' field of the same data type (int), which likely references the same application context. This suggests that audit logs and resource types can be associated with the same application, enabling queries such as 'show all resource types relevant to the application for which this audit log was recorded.' However, this is not a strict foreign key relationship between the two tables, but rather a logical association based on shared application context.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_role_logs t1 JOIN acl_resource_types t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_role_logs",
            "from_column": "app_id",
            "to_table": "acl_roles",
            "to_column": "app_id",
            "condition": "acl_audit_role_logs.app_id = acl_roles.app_id",
            "confidence": "high",
            "reasoning": "Both tables have an app_id field of type int, which likely refers to the same application context. While this does not uniquely identify a role, it allows for grouping or filtering audit logs and roles by application. This is a common pattern in multi-tenant or multi-application systems.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_role_logs t1 JOIN acl_roles t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_role_logs",
            "from_column": "app_id",
            "to_table": "acl_role_permissions",
            "to_column": "app_id",
            "condition": "acl_audit_role_logs.app_id = acl_role_permissions.app_id",
            "confidence": "high",
            "reasoning": "Both tables contain an app_id field of the same type, likely referencing the same application context. This allows filtering or joining audit logs with permission assignments within the same application. However, app_id alone does not uniquely identify a record in either table, so this is a contextual or grouping relationship rather than a strict foreign key.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_role_logs t1 JOIN acl_role_permissions t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 67,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_role_logs",
            "from_column": "link_id",
            "to_table": "acl_role_permissions",
            "to_column": "id",
            "condition": "acl_audit_role_logs.link_id = acl_role_permissions.id",
            "confidence": "high",
            "reasoning": "The field link_id in acl_audit_role_logs is likely used to reference the primary key of a related object. Given the business context (auditing role-related actions) and the naming, it is plausible that link_id refers to the id of acl_role_permissions when the audit log is about a permission assignment or change. This is a common audit pattern, but without explicit foreign keys, the relationship is inferred.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_role_logs t1 JOIN acl_role_permissions t2 ON t1.link_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_role_logs",
            "from_column": "app_id",
            "to_table": "acl_role_relations",
            "to_column": "app_id",
            "condition": "acl_audit_role_logs.app_id = acl_role_relations.app_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'app_id' field of type int, which is used to scope records to a specific application. While this is not a foreign key relationship, it is common to join on this field for reporting or filtering purposes, especially in multi-tenant systems. This join would allow analysis of audit logs and role relationships within the same application context.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_role_logs t1 JOIN acl_role_relations t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_operation_records",
            "from_column": "rolename",
            "to_table": "acl_roles",
            "to_column": "name",
            "condition": "acl_operation_records.rolename = acl_roles.name",
            "confidence": "high",
            "reasoning": "The 'rolename' field in acl_operation_records likely refers to the 'name' field in acl_roles, as both represent the name of a role. This is a common pattern in access control systems where operation logs reference roles by name. However, the data types differ ('varchar(32)' vs 'text'), and there is no explicit foreign key, so the relationship is inferred based on naming convention and business logic.",
            "test_sql": "SELECT COUNT(*) FROM acl_operation_records t1 JOIN acl_roles t2 ON t1.rolename = t2.name LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 32,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_permissions",
            "from_column": "resource_type_id",
            "to_table": "acl_resources",
            "to_column": "resource_type_id",
            "condition": "acl_permissions.resource_type_id = acl_resources.resource_type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'resource_type_id' field of the same data type and naming convention, and both reference the concept of resource types in their business purposes. While this is not a direct foreign key relationship between these two tables, it is likely that permissions are defined for resource types, and resources are instances of those types. This join could be used to find all resources of a type for which a permission exists, or vice versa.",
            "test_sql": "SELECT COUNT(*) FROM acl_permissions t1 JOIN acl_resources t2 ON t1.resource_type_id = t2.resource_type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 59,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_permissions",
            "from_column": "app_id",
            "to_table": "acl_resources",
            "to_column": "app_id",
            "condition": "acl_permissions.app_id = acl_resources.app_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'app_id' field, which likely references the same application context. This join could be used to scope permissions and resources to the same application, supporting queries such as 'which permissions apply to resources in a given app'.",
            "test_sql": "SELECT COUNT(*) FROM acl_permissions t1 JOIN acl_resources t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 231,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_resource_types",
            "from_column": "app_id",
            "to_table": "acl_role_permissions",
            "to_column": "app_id",
            "condition": "acl_resource_types.app_id = acl_role_permissions.app_id",
            "confidence": "high",
            "reasoning": "Both tables contain an 'app_id' field of the same data type (int), and both reference the application context for their respective records. While this does not represent a direct foreign key relationship between the two tables, it is common in access control systems to scope resource types and role permissions to the same application. This join would allow analysis of which resource types are defined for applications where role permissions are assigned.",
            "test_sql": "SELECT COUNT(*) FROM acl_resource_types t1 JOIN acl_role_permissions t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 469,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_resource_types",
            "from_column": "app_id",
            "to_table": "acl_role_relations",
            "to_column": "app_id",
            "condition": "acl_resource_types.app_id = acl_role_relations.app_id",
            "confidence": "high",
            "reasoning": "Both tables contain an 'app_id' field of the same data type (int), which references the same conceptual entity (an application context). While this does not establish a direct foreign key relationship between the two tables, it does allow for logical association or filtering of records that belong to the same application. This is a common pattern in multi-tenant or modular systems, where different entities are scoped to the same application.",
            "test_sql": "SELECT COUNT(*) FROM acl_resource_types t1 JOIN acl_role_relations t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 14,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_resource_types",
            "from_column": "app_id",
            "to_table": "acl_roles",
            "to_column": "app_id",
            "condition": "acl_resource_types.app_id = acl_roles.app_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'app_id' field of the same data type (int), and both reference the same business concept: an application context. While this does not directly link a resource type to a role, it allows for joining all resource types and roles that belong to the same application. This is a common pattern in multi-tenant or application-scoped ACL systems, where roles and resource types are both scoped to the same application.",
            "test_sql": "SELECT COUNT(*) FROM acl_resource_types t1 JOIN acl_roles t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 35,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_resources",
            "from_column": "app_id",
            "to_table": "acl_role_relations",
            "to_column": "app_id",
            "condition": "acl_resources.app_id = acl_role_relations.app_id",
            "confidence": "high",
            "reasoning": "Both tables contain an 'app_id' field of the same data type (int), and both reference the concept of an application context. While 'app_id' is a foreign key to 'acl_apps' in both tables, within the scope of these two tables, joining on 'app_id' could be used to analyze or report on resources and role relationships within the same application. However, this is a contextual or business logic relationship rather than a direct foreign key relationship between these two tables.",
            "test_sql": "SELECT COUNT(*) FROM acl_resources t1 JOIN acl_role_relations t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 22,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_resources",
            "from_column": "app_id",
            "to_table": "acl_roles",
            "to_column": "app_id",
            "condition": "acl_resources.app_id = acl_roles.app_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'app_id' field of the same data type (int), and both reference the concept of an application in their business purposes. While 'app_id' is a foreign key to another table in both schemas, it is plausible that resources and roles are scoped or grouped by application, making this a common join for filtering or reporting within the same application context.",
            "test_sql": "SELECT COUNT(*) FROM acl_resources t1 JOIN acl_roles t2 ON t1.app_id = t2.app_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 55,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_role_permissions",
            "from_column": "rid",
            "to_table": "acl_role_relations",
            "to_column": "parent_id",
            "condition": "acl_role_permissions.rid = acl_role_relations.parent_id",
            "confidence": "high",
            "reasoning": "Both fields reference roles (by id) and are likely to be used together when determining which permissions are inherited or assigned to a parent role in a hierarchy. This join would be useful for finding all permissions assigned to parent roles in a role hierarchy.",
            "test_sql": "SELECT COUNT(*) FROM acl_role_permissions t1 JOIN acl_role_relations t2 ON t1.rid = t2.parent_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 19,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_role_permissions",
            "from_column": "rid",
            "to_table": "acl_role_relations",
            "to_column": "child_id",
            "condition": "acl_role_permissions.rid = acl_role_relations.child_id",
            "confidence": "high",
            "reasoning": "Both fields reference roles (by id) and this join would be useful for finding all permissions directly assigned to child roles in a hierarchy, or for traversing the hierarchy to aggregate permissions.",
            "test_sql": "SELECT COUNT(*) FROM acl_role_permissions t1 JOIN acl_role_relations t2 ON t1.rid = t2.child_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 96,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_role_permissions",
            "from_column": "rid",
            "to_table": "common_employee",
            "to_column": "acl_rid",
            "condition": "acl_role_permissions.rid = common_employee.acl_rid",
            "confidence": "high",
            "reasoning": "Both tables contain fields that appear to represent a role identifier: 'rid' in 'acl_role_permissions' and 'acl_rid' in 'common_employee'. While there is no explicit foreign key between these tables, it is a common access control pattern for employees to be assigned a role, and for permissions to be granted to roles. The data types are compatible (both int), and the naming convention suggests a logical link. This would allow querying which employees have which permissions via their role.",
            "test_sql": "SELECT COUNT(*) FROM acl_role_permissions t1 JOIN common_employee t2 ON t1.rid = t2.acl_rid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 48,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_roles",
            "from_column": "uid",
            "to_table": "c_ad_ci_types",
            "to_column": "uid",
            "condition": "acl_roles.uid = c_ad_ci_types.uid",
            "confidence": "high",
            "reasoning": "Both tables contain a 'uid' column of type int, which likely represents a user identifier. While there is no explicit foreign key between these tables, it is plausible that both reference the same user entity for tracking ownership, responsibility, or creation. This is a common pattern in systems where both access control and configuration items are user-scoped or user-owned.",
            "test_sql": "SELECT COUNT(*) FROM acl_roles t1 JOIN c_ad_ci_types t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_role_relations",
            "from_column": "child_id",
            "to_table": "common_employee",
            "to_column": "acl_rid",
            "condition": "acl_role_relations.child_id = common_employee.acl_rid",
            "confidence": "high",
            "reasoning": "Both tables contain fields that appear to represent role IDs: 'child_id' in 'acl_role_relations' (which references a role) and 'acl_rid' in 'common_employee' (which likely represents the employee's assigned role). This suggests a possible business logic relationship where an employee's role could be linked to a role in the role hierarchy.",
            "test_sql": "SELECT COUNT(*) FROM acl_role_relations t1 JOIN common_employee t2 ON t1.child_id = t2.acl_rid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_roles",
            "from_column": "uid",
            "to_table": "c_prv",
            "to_column": "uid",
            "condition": "acl_roles.uid = c_prv.uid",
            "confidence": "high",
            "reasoning": "Both tables contain a 'uid' field of type int, which likely represents a user identifier. In acl_roles, 'uid' is nullable and may indicate the user to whom a role is assigned. In c_prv, 'uid' is not nullable and likely represents the owner of the resource. While there is no explicit foreign key, the shared naming, data type, and business logic suggest a possible relationship where roles and resources are associated with the same user.",
            "test_sql": "SELECT COUNT(*) FROM acl_roles t1 JOIN c_prv t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_roles",
            "from_column": "uid",
            "to_table": "c_ptv",
            "to_column": "uid",
            "condition": "acl_roles.uid = c_ptv.uid",
            "confidence": "high",
            "reasoning": "Both tables contain a column named 'uid' of type int, and both are indexed. While 'uid' is not explicitly defined as a foreign key in either table, the naming convention and data type suggest a possible logical or business relationship. In acl_roles, 'uid' likely refers to an entity (possibly a user or related object), and in c_ptv, 'uid' is a required field, possibly referencing the same or a related entity. Without more context, this is the only plausible join candidate.",
            "test_sql": "SELECT COUNT(*) FROM acl_roles t1 JOIN c_ptv t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_roles",
            "from_column": "uid",
            "to_table": "c_records",
            "to_column": "uid",
            "condition": "acl_roles.uid = c_records.uid",
            "confidence": "high",
            "reasoning": "Both tables contain a 'uid' field of type int, which likely represents a user or entity identifier. In acl_roles, 'uid' is nullable and may represent the user assigned to a role; in c_records, 'uid' is not nullable and likely represents the user associated with a record. While there is no explicit foreign key, the naming, data type, and business logic suggest that records in c_records could be related to the same user referenced in acl_roles. This is a common pattern in systems where user actions or cases are logged and roles are assigned to users.",
            "test_sql": "SELECT COUNT(*) FROM acl_roles t1 JOIN c_records t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ad_ci_types",
            "from_column": "type_id",
            "to_table": "c_cis",
            "to_column": "type_id",
            "condition": "c_ad_ci_types.type_id = c_cis.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' field of type int, which references the same concept of a CI type. While 'type_id' is a foreign key to another table (not provided), it is reasonable to infer that records in both tables with the same 'type_id' are related by their shared CI type. This relationship is not a direct foreign key between these two tables, but it is a logical connection based on business logic and naming conventions.",
            "test_sql": "SELECT COUNT(*) FROM c_ad_ci_types t1 JOIN c_cis t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 768,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ad_ci_types",
            "from_column": "type_id",
            "to_table": "c_ci_type_relations",
            "to_column": "parent_id",
            "condition": "c_ad_ci_types.type_id = c_ci_type_relations.parent_id",
            "confidence": "high",
            "reasoning": "Both fields reference CI type IDs, and business logic suggests that c_ad_ci_types associates a CI type (type_id) with rules, while c_ci_type_relations defines relationships between CI types (parent_id/child_id). Joining on type_id and parent_id could reveal which CI type-rule associations are relevant for parent CI types in relationships.",
            "test_sql": "SELECT COUNT(*) FROM c_ad_ci_types t1 JOIN c_ci_type_relations t2 ON t1.type_id = t2.parent_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ad_ci_types",
            "from_column": "type_id",
            "to_table": "c_ci_type_relations",
            "to_column": "child_id",
            "condition": "c_ad_ci_types.type_id = c_ci_type_relations.child_id",
            "confidence": "high",
            "reasoning": "Similarly, joining c_ad_ci_types.type_id to c_ci_type_relations.child_id can show which CI type-rule associations are relevant for child CI types in relationships. This is logical given the shared reference to CI type IDs.",
            "test_sql": "SELECT COUNT(*) FROM c_ad_ci_types t1 JOIN c_ci_type_relations t2 ON t1.type_id = t2.child_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ad_ci_types",
            "from_column": "uid",
            "to_table": "c_prv",
            "to_column": "uid",
            "condition": "c_ad_ci_types.uid = c_prv.uid",
            "confidence": "high",
            "reasoning": "Both tables have a 'uid' field of type int, which likely represents a user or owner. While there is no explicit foreign key, it is common for related records to be associated by a user ID. This could be used to find all c_ad_ci_types and c_prv records belonging to the same user. However, without more context, it is not certain that these are always intended to be joined, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM c_ad_ci_types t1 JOIN c_prv t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ad_ci_types",
            "from_column": "type_id",
            "to_table": "c_ptv",
            "to_column": "type_id",
            "condition": "c_ad_ci_types.type_id = c_ptv.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' field of the same data type (int), and both reference the same conceptual entity (CI type). While 'type_id' is a foreign key to another table in both cases, it is plausible that business logic may require joining these tables on 'type_id' to analyze or report on all records of a given CI type across both tables. However, there is no explicit foreign key relationship between these two tables, so the relationship is inferred based on naming, data type, and business context.",
            "test_sql": "SELECT COUNT(*) FROM c_ad_ci_types t1 JOIN c_ptv t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "attr_id",
            "to_table": "c_choice_texts",
            "to_column": "attr_id",
            "condition": "c_attribute_histories.attr_id = c_choice_texts.attr_id",
            "confidence": "high",
            "reasoning": "Both tables contain an 'attr_id' field of type int, which likely references the same attribute concept. In c_attribute_histories, 'attr_id' tracks which attribute was changed, while in c_choice_texts, 'attr_id' indicates which attribute the choice belongs to. This suggests a logical relationship where attribute histories may reference attributes that have selectable choices defined in c_choice_texts. However, there is no explicit foreign key between these two tables, and the relationship is based on business logic and naming conventions.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_choice_texts t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8968,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "attr_id",
            "to_table": "c_ci_type_attributes",
            "to_column": "attr_id",
            "condition": "c_attribute_histories.attr_id = c_ci_type_attributes.attr_id",
            "confidence": "high",
            "reasoning": "Both tables contain an attr_id field of type int, which likely refers to the same concept of an attribute. In c_attribute_histories, attr_id tracks which attribute was changed, while in c_ci_type_attributes, attr_id defines which attributes are associated with CI types. This suggests a logical relationship where attribute history entries can be joined to attribute definitions/configurations. However, since attr_id in c_attribute_histories is nullable and not a declared foreign key, and because c_ci_type_attributes may contain multiple rows per attr_id (for different type_id values), the relationship is not guaranteed to be one-to-one or always present, but is a common business logic join.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_ci_type_attributes t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 19795,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "ci_id",
            "to_table": "c_ci_types",
            "to_column": "id",
            "condition": "c_attribute_histories.ci_id = c_ci_types.id",
            "confidence": "high",
            "reasoning": "The field 'ci_id' in c_attribute_histories and 'id' in c_ci_types are both of type int and likely represent a reference from an attribute history entry to a specific configuration item type. The naming convention ('ci' commonly stands for 'configuration item') and the business logic (tracking changes to attributes of configuration items) suggest that attribute histories may be linked to CI types. However, there is no explicit foreign key or documentation confirming this, so the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_ci_types t2 ON t1.ci_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "attr_id",
            "to_table": "c_ci_type_attribute_group_items",
            "to_column": "attr_id",
            "condition": "c_attribute_histories.attr_id = c_ci_type_attribute_group_items.attr_id",
            "confidence": "high",
            "reasoning": "Both tables contain an attr_id field of type int, which likely references the same conceptual entity: an attribute. In c_attribute_histories, attr_id represents the attribute whose value changed; in c_ci_type_attribute_group_items, attr_id represents an attribute assigned to a group. This suggests a logical relationship where attribute history entries can be associated with attribute groupings via attr_id. However, there is no explicit foreign key or business rule directly connecting these tables, so the relationship is inferred based on naming, data type, and business context.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_ci_type_attribute_group_items t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 14086,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "ci_id",
            "to_table": "c_ptv",
            "to_column": "id",
            "condition": "c_attribute_histories.ci_id = c_ptv.id",
            "confidence": "high",
            "reasoning": "Both tables have an integer column named 'ci_id' (in c_attribute_histories) and 'id' (primary key in c_ptv). The naming convention 'ci_id' suggests it could reference a configuration item, and c_ptv appears to represent such items. This is a common pattern where a history/log table references the main entity table by its primary key. However, there is no explicit foreign key constraint, so this is inferred based on naming and business logic.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_ptv t2 ON t1.ci_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "attr_id",
            "to_table": "c_psa",
            "to_column": "attr_id",
            "condition": "c_attribute_histories.attr_id = c_psa.attr_id",
            "confidence": "high",
            "reasoning": "Both tables have an attr_id field of the same data type (int), and both are used in the context of attributes. In c_attribute_histories, attr_id refers to the attribute being changed, while in c_psa, attr_id refers to the attribute associated with a type. This suggests a possible business logic relationship where attribute history entries could be joined to attribute-type associations for reporting or configuration purposes. However, there is no explicit foreign key or guarantee that the attr_id values align perfectly between the two tables, so the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_psa t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 12371,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "ci_id",
            "to_table": "c_ci_relations",
            "to_column": "first_ci_id",
            "condition": "c_attribute_histories.ci_id = c_ci_relations.first_ci_id",
            "confidence": "high",
            "reasoning": "Both tables use the field name 'ci_id' (in c_attribute_histories) and 'first_ci_id' (in c_ci_relations), both of type int, likely referencing the same domain concept of a configuration item (CI). It is plausible that attribute history entries are related to the CI that participates as the 'first' CI in a relationship. However, there is no explicit foreign key, and the business logic does not guarantee that every attribute history must correspond to a CI in a relationship, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_ci_relations t2 ON t1.ci_id = t2.first_ci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 840,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "ci_id",
            "to_table": "c_ci_relations",
            "to_column": "second_ci_id",
            "condition": "c_attribute_histories.ci_id = c_ci_relations.second_ci_id",
            "confidence": "high",
            "reasoning": "Similarly, 'ci_id' in c_attribute_histories and 'second_ci_id' in c_ci_relations are both int and likely refer to the same CI domain. This join would allow tracking attribute changes for CIs that appear as the 'second' CI in a relationship. As with the previous relationship, there is no explicit foreign key, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_ci_relations t2 ON t1.ci_id = t2.second_ci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 11598,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "ci_id",
            "to_table": "c_value_index_integers",
            "to_column": "ci_id",
            "condition": "c_attribute_histories.ci_id = c_value_index_integers.ci_id",
            "confidence": "high",
            "reasoning": "Both tables use the field ci_id, which likely refers to the same business entity (a configuration item). This suggests that attribute history records and current attribute values can be related by the configuration item they reference. However, without explicit foreign keys or further context, the relationship is inferred based on naming and business logic.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_value_index_integers t2 ON t1.ci_id = t2.ci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 23052,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "attr_id",
            "to_table": "c_value_index_integers",
            "to_column": "attr_id",
            "condition": "c_attribute_histories.attr_id = c_value_index_integers.attr_id",
            "confidence": "high",
            "reasoning": "Both tables have an attr_id field, which likely refers to the same attribute definition. This allows for relating attribute history records to current attribute values by attribute. The relationship is logical and based on naming conventions and business purpose.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_value_index_integers t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1572864,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "ci_id",
            "to_table": "c_value_index_texts",
            "to_column": "ci_id",
            "condition": "c_attribute_histories.ci_id = c_value_index_texts.ci_id",
            "confidence": "high",
            "reasoning": "Both tables use the field ci_id, which likely refers to the same entity (such as a configuration item). This suggests that attribute history records and current attribute values can be related by the entity they reference. However, without explicit foreign keys or further context, the relationship is inferred based on naming and business logic.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_value_index_texts t2 ON t1.ci_id = t2.ci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 115355,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "attr_id",
            "to_table": "c_value_index_texts",
            "to_column": "attr_id",
            "condition": "c_attribute_histories.attr_id = c_value_index_texts.attr_id",
            "confidence": "high",
            "reasoning": "Both tables use the field attr_id, which likely refers to the same attribute definition. This allows for relating attribute history records to current attribute values by attribute. The relationship is inferred based on naming and typical database design patterns.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_value_index_texts t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7281734,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "ci_id",
            "to_table": "c_value_texts",
            "to_column": "ci_id",
            "condition": "c_attribute_histories.ci_id = c_value_texts.ci_id",
            "confidence": "high",
            "reasoning": "Both tables use the field ci_id, which likely refers to the same conceptual entity (e.g., a configuration item). This suggests that attribute history records and current attribute values can be related by the entity they reference. However, without explicit foreign keys or further context, the relationship is inferred based on naming and business logic.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_value_texts t2 ON t1.ci_id = t2.ci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 34578,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attribute_histories",
            "from_column": "attr_id",
            "to_table": "c_value_texts",
            "to_column": "attr_id",
            "condition": "c_attribute_histories.attr_id = c_value_texts.attr_id",
            "confidence": "high",
            "reasoning": "Both tables have an attr_id field, which likely refers to the same attribute definition. This allows for relating attribute history records to current attribute values by attribute. The relationship is logical and based on naming conventions and business purpose.",
            "test_sql": "SELECT COUNT(*) FROM c_attribute_histories t1 JOIN c_value_texts t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1966080,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_choice_texts",
            "from_column": "attr_id",
            "to_table": "c_psa",
            "to_column": "attr_id",
            "condition": "c_choice_texts.attr_id = c_psa.attr_id",
            "confidence": "high",
            "reasoning": "Both tables contain an attr_id field of type int, and both reference the concept of an attribute. In c_choice_texts, attr_id identifies the attribute for which a choice text is defined. In c_psa, attr_id (nullable) links a type-attribute association. It is plausible that for a given attribute (attr_id), one may want to join c_psa and c_choice_texts to retrieve all selectable choices for attributes associated with a type. However, there is no explicit foreign key between these two tables, and attr_id in c_psa is nullable, so the relationship is inferred based on business logic and naming conventions.",
            "test_sql": "SELECT COUNT(*) FROM c_choice_texts t1 JOIN c_psa t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_relations",
            "from_column": "relation_type_id",
            "to_table": "c_ci_type_relations",
            "to_column": "relation_type_id",
            "condition": "c_ci_relations.relation_type_id = c_ci_type_relations.relation_type_id",
            "confidence": "high",
            "reasoning": "Both tables use the field 'relation_type_id' to reference the type of relationship. While in each table this field is a foreign key to a relation types table (not provided), joining on this field could allow analysis of which CI-to-CI relationships (instances) correspond to which CI type-to-type relationship definitions. This is a common pattern in configuration management systems, where instance-level relationships are mapped to type-level relationship definitions.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_relations t1 JOIN c_ci_type_relations t2 ON t1.relation_type_id = t2.relation_type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4200,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_choice_texts",
            "from_column": "value",
            "to_table": "c_value_index_texts",
            "to_column": "value",
            "condition": "c_choice_texts.value = c_value_index_texts.value",
            "confidence": "high",
            "reasoning": "Both tables have a 'value' field representing a text option (in c_choice_texts) and a selected value (in c_value_index_texts). While the data types differ (text vs varchar(128)), they are compatible for comparison. This relationship would make sense if the system enforces that only predefined choices from c_choice_texts can be selected and stored in c_value_index_texts. However, this is not enforced by a foreign key, so the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM c_choice_texts t1 JOIN c_value_index_texts t2 ON t1.value = t2.value LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2304,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attribute_group_items",
            "from_column": "attr_id",
            "to_table": "c_ci_type_attributes",
            "to_column": "attr_id",
            "condition": "c_ci_type_attribute_group_items.attr_id = c_ci_type_attributes.attr_id",
            "confidence": "high",
            "reasoning": "Both tables reference an 'attr_id' field of type int, which likely points to the same attribute definition in their respective business contexts. While there is no explicit foreign key between these two tables, it is common in configuration management systems for attribute groupings and CI type-attribute mappings to reference the same attribute definitions. This join would allow analysis of how attributes are grouped and how they are assigned to CI types.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attribute_group_items t1 JOIN c_ci_type_attributes t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 24,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attribute_group_items",
            "from_column": "attr_id",
            "to_table": "c_psa",
            "to_column": "attr_id",
            "condition": "c_ci_type_attribute_group_items.attr_id = c_psa.attr_id",
            "confidence": "high",
            "reasoning": "Both tables reference an 'attr_id' field of type int, which likely refers to the same attribute entity in the business domain. While there is no explicit foreign key between these two tables, the shared use of 'attr_id' suggests a logical relationship: both tables are associating attributes (by id) with different higher-level groupings (attribute groups in one, types in the other). This join could be used to find attributes that are both part of a group and configured for a type, or to analyze attribute usage across groupings and types.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attribute_group_items t1 JOIN c_psa t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 14,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_relations",
            "from_column": "second_ci_id",
            "to_table": "c_value_texts",
            "to_column": "ci_id",
            "condition": "c_ci_relations.second_ci_id = c_value_texts.ci_id",
            "confidence": "high",
            "reasoning": "Both fields represent a reference to a configuration item (CI) by ID. Joining on these fields allows retrieval of attribute values for the 'second' CI in a relationship, which is useful for reporting or filtering based on the properties of related CIs.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_relations t1 JOIN c_value_texts t2 ON t1.second_ci_id = t2.ci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2304,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attribute_group_items",
            "from_column": "attr_id",
            "to_table": "c_value_texts",
            "to_column": "attr_id",
            "condition": "c_ci_type_attribute_group_items.attr_id = c_value_texts.attr_id",
            "confidence": "high",
            "reasoning": "Both tables reference an 'attr_id' field of type int, which likely refers to the same attribute definition. While there is no direct foreign key between these two tables, it is reasonable to infer that c_ci_type_attribute_group_items defines which attributes are grouped, and c_value_texts stores values for those attributes. This join would allow analysis of which attribute values (in c_value_texts) correspond to attributes that are part of a group (in c_ci_type_attribute_group_items).",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attribute_group_items t1 JOIN c_value_texts t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2304,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attribute_group_items",
            "from_column": "attr_id",
            "to_table": "c_value_index_texts",
            "to_column": "attr_id",
            "condition": "c_ci_type_attribute_group_items.attr_id = c_value_index_texts.attr_id",
            "confidence": "high",
            "reasoning": "Both tables reference an 'attr_id' field of type int, which likely refers to the same attribute concept. In c_ci_type_attribute_group_items, 'attr_id' associates an attribute with a group, while in c_value_index_texts, 'attr_id' associates an attribute with a value for a specific entity. This suggests a logical relationship where the attributes defined in groups may be the same attributes for which values are stored. However, there is no direct foreign key or business rule enforcing this relationship between these two tables, so the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attribute_group_items t1 JOIN c_value_index_texts t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 7681,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attribute_groups",
            "from_column": "type_id",
            "to_table": "c_ci_type_attributes",
            "to_column": "type_id",
            "condition": "c_ci_type_attribute_groups.type_id = c_ci_type_attributes.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' field of the same data type (int, not null), and both reference the concept of a CI type. While there is no explicit foreign key between these two tables, it is logical that attribute groups (c_ci_type_attribute_groups) and attribute assignments (c_ci_type_attributes) are both scoped to the same CI type. This allows for queries that retrieve all attribute groups and their associated attributes for a given CI type. However, there is no direct one-to-one or one-to-many relationship between the two tables, as there is no group_id or similar field in c_ci_type_attributes. The relationship is thus at the CI type level, not at the group level.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attribute_groups t1 JOIN c_ci_type_attributes t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 66,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attribute_groups",
            "from_column": "type_id",
            "to_table": "c_cis",
            "to_column": "type_id",
            "condition": "c_ci_type_attribute_groups.type_id = c_cis.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' field of the same data type (int), and both reference the concept of a CI type. While there is no direct foreign key between these two tables, it is logical to infer that attribute groups (which organize attributes for a CI type) and configuration items (which are instances of a CI type) can be related via their shared 'type_id'. This allows for queries such as retrieving all attribute groups relevant to the type of a given configuration item.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attribute_groups t1 JOIN c_cis t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2304,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attribute_groups",
            "from_column": "type_id",
            "to_table": "c_psa",
            "to_column": "type_id",
            "condition": "c_ci_type_attribute_groups.type_id = c_psa.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' field of the same data type (int), and both reference the concept of a 'type' in their business logic. While 'type_id' is a foreign key to another table in both cases, within the context of these two tables, joining on 'type_id' would allow analysis of attribute groups and attribute assignments for the same CI type. However, there is no direct foreign key or explicit relationship between these two tables, so this is an inferred, business-logic-based relationship.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attribute_groups t1 JOIN c_psa t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 42,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attribute_groups",
            "from_column": "type_id",
            "to_table": "c_ptv",
            "to_column": "type_id",
            "condition": "c_ci_type_attribute_groups.type_id = c_ptv.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a 'type_id' field of the same data type (int, not null), and both reference the concept of a 'type' in their business purposes. While there is no explicit foreign key between these two tables, it is reasonable to infer that records in both tables can be associated with the same CI type, allowing for a logical join on 'type_id'. This relationship is not a direct foreign key but is based on shared business logic and domain alignment.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attribute_groups t1 JOIN c_ptv t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attribute_groups",
            "from_column": "type_id",
            "to_table": "c_ci_type_relations",
            "to_column": "parent_id",
            "condition": "c_ci_type_attribute_groups.type_id = c_ci_type_relations.parent_id",
            "confidence": "high",
            "reasoning": "Both fields reference a CI type (by id), and it is plausible that attribute groups for a CI type may be relevant when analyzing relationships where that CI type is the parent. However, there is no explicit foreign key or direct business logic tying these two tables together, so this is an inferred relationship based on naming and domain context.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attribute_groups t1 JOIN c_ci_type_relations t2 ON t1.type_id = t2.parent_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attribute_groups",
            "from_column": "type_id",
            "to_table": "c_ci_type_relations",
            "to_column": "child_id",
            "condition": "c_ci_type_attribute_groups.type_id = c_ci_type_relations.child_id",
            "confidence": "high",
            "reasoning": "Similarly, attribute groups for a CI type may be relevant when that CI type is the child in a relationship. This is inferred from the shared reference to CI type IDs and the business context, but there is no explicit foreign key or direct linkage.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attribute_groups t1 JOIN c_ci_type_relations t2 ON t1.type_id = t2.child_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attributes",
            "from_column": "type_id",
            "to_table": "c_ci_type_relations",
            "to_column": "parent_id",
            "condition": "c_ci_type_attributes.type_id = c_ci_type_relations.parent_id",
            "confidence": "high",
            "reasoning": "Both fields reference CI type IDs, and it is plausible that attributes defined for a CI type (type_id) could be relevant to the parent CI type in a relationship. This could be used to retrieve all attributes for the parent CI type in a relationship.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attributes t1 JOIN c_ci_type_relations t2 ON t1.type_id = t2.parent_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 82,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attributes",
            "from_column": "type_id",
            "to_table": "c_ci_type_relations",
            "to_column": "child_id",
            "condition": "c_ci_type_attributes.type_id = c_ci_type_relations.child_id",
            "confidence": "high",
            "reasoning": "Similarly, attributes for a CI type (type_id) could be relevant to the child CI type in a relationship. This could be used to retrieve all attributes for the child CI type in a relationship.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attributes t1 JOIN c_ci_type_relations t2 ON t1.type_id = t2.child_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 53,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attributes",
            "from_column": "attr_id",
            "to_table": "c_value_texts",
            "to_column": "attr_id",
            "condition": "c_ci_type_attributes.attr_id = c_value_texts.attr_id",
            "confidence": "high",
            "reasoning": "Both tables reference the same attribute definition via attr_id. In c_ci_type_attributes, attr_id defines which attributes are available for a CI type; in c_value_texts, attr_id indicates which attribute's value is being stored for a specific CI instance. While there is no direct foreign key between these two tables, joining on attr_id can be useful for reporting or validation (e.g., to check if a value is stored for an attribute that is configured for a CI type). However, without a direct link between CI type and CI instance, this relationship is not guaranteed to be strictly valid for all business cases.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attributes t1 JOIN c_value_texts t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 3072,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_attributes",
            "from_column": "attr_id",
            "to_table": "c_psa",
            "to_column": "attr_id",
            "condition": "c_ci_type_attributes.attr_id = c_psa.attr_id",
            "confidence": "high",
            "reasoning": "Both tables use 'attr_id' as a foreign key to reference the same conceptual entity (an attribute). While this alone does not guarantee a direct relationship, it is possible to join on 'attr_id' to analyze or compare how a given attribute is configured across both tables.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_attributes t1 JOIN c_psa t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 37,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_relations",
            "from_column": "relation_type_id",
            "to_table": "c_relation_histories",
            "to_column": "relation_type_id",
            "condition": "c_ci_type_relations.relation_type_id = c_relation_histories.relation_type_id",
            "confidence": "high",
            "reasoning": "Both tables contain a field named 'relation_type_id' with the same data type (int), and both reference the concept of a relationship type. While in c_ci_type_relations it defines the type of relationship between CI types, in c_relation_histories it tracks the type of relationship event. This suggests a logical connection for reporting or filtering, though it is not a strict foreign key relationship between these two tables.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_relations t1 JOIN c_relation_histories t2 ON t1.relation_type_id = t2.relation_type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4200,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_relations",
            "from_column": "parent_id",
            "to_table": "c_ptv",
            "to_column": "type_id",
            "condition": "c_ci_type_relations.parent_id = c_ptv.type_id",
            "confidence": "high",
            "reasoning": "Both fields reference the concept of a CI type (parent_id in c_ci_type_relations and type_id in c_ptv). This suggests that c_ptv records could represent instances of a CI type that is a parent in a relationship. This join would allow analysis of all c_ptv records that are of a CI type acting as a parent in a relationship.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_relations t1 JOIN c_ptv t2 ON t1.parent_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_relations",
            "from_column": "child_id",
            "to_table": "c_ptv",
            "to_column": "type_id",
            "condition": "c_ci_type_relations.child_id = c_ptv.type_id",
            "confidence": "high",
            "reasoning": "Similarly, child_id in c_ci_type_relations and type_id in c_ptv both reference CI types. This join would allow analysis of all c_ptv records that are of a CI type acting as a child in a relationship.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_relations t1 JOIN c_ptv t2 ON t1.child_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_relations",
            "from_column": "parent_id",
            "to_table": "c_psa",
            "to_column": "type_id",
            "condition": "c_ci_type_relations.parent_id = c_psa.type_id",
            "confidence": "high",
            "reasoning": "Both fields reference a 'type' concept (parent_id in c_ci_type_relations and type_id in c_psa), and both are integer fields. It is plausible that one may want to join the parent CI type in a relationship to its attribute configuration in c_psa. However, there is no explicit foreign key or naming convention directly linking these two tables, so this is an inferred business logic relationship.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_relations t1 JOIN c_psa t2 ON t1.parent_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 58,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ci_type_relations",
            "from_column": "child_id",
            "to_table": "c_psa",
            "to_column": "type_id",
            "condition": "c_ci_type_relations.child_id = c_psa.type_id",
            "confidence": "high",
            "reasoning": "Similarly, child_id in c_ci_type_relations and type_id in c_psa both refer to a CI type. This join would allow analysis of the attribute configuration for the child CI type in a relationship. Again, this is an inferred business logic relationship, not an explicit foreign key.",
            "test_sql": "SELECT COUNT(*) FROM c_ci_type_relations t1 JOIN c_psa t2 ON t1.child_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 22,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_cis",
            "from_column": "type_id",
            "to_table": "c_ptv",
            "to_column": "type_id",
            "condition": "c_cis.type_id = c_ptv.type_id",
            "confidence": "high",
            "reasoning": "Both tables have a non-nullable type_id field of the same data type (int), and both reference the same external table (c_ci_types) for type categorization. While this is not a direct relationship between the two tables, it is common in database design to join tables on shared type/category fields for reporting, filtering, or aggregation purposes. However, this is not a foreign key relationship between the two tables themselves, but rather a logical/business relationship based on shared categorization.",
            "test_sql": "SELECT COUNT(*) FROM c_cis t1 JOIN c_ptv t2 ON t1.type_id = t2.type_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 768,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_cis",
            "from_column": "id",
            "to_table": "c_relation_histories",
            "to_column": "first_ci_id",
            "condition": "c_cis.id = c_relation_histories.first_ci_id",
            "confidence": "high",
            "reasoning": "The c_relation_histories table appears to track relationships between two entities, with first_ci_id and second_ci_id likely referencing the primary key of the c_cis table. This is a common pattern in relationship/audit tables for configuration items or entities.",
            "test_sql": "SELECT COUNT(*) FROM c_cis t1 JOIN c_relation_histories t2 ON t1.id = t2.first_ci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 840,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_cis",
            "from_column": "id",
            "to_table": "c_relation_histories",
            "to_column": "second_ci_id",
            "condition": "c_cis.id = c_relation_histories.second_ci_id",
            "confidence": "high",
            "reasoning": "Similarly, second_ci_id in c_relation_histories likely references the id of c_cis, representing the second entity in the relationship. This allows the table to track relationships between any two configuration items.",
            "test_sql": "SELECT COUNT(*) FROM c_cis t1 JOIN c_relation_histories t2 ON t1.id = t2.second_ci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 840,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_cis",
            "from_column": "updated_by",
            "to_table": "users",
            "to_column": "username",
            "condition": "c_cis.updated_by = users.username",
            "confidence": "high",
            "reasoning": "The c_cis.updated_by field likely records the username of the user who last updated the configuration item. The users table has a username field that is unique and suitable for identifying users. This is a common business logic pattern for tracking record modifications by user identity.",
            "test_sql": "SELECT COUNT(*) FROM c_cis t1 JOIN users t2 ON t1.updated_by = t2.username LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 842,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_prv",
            "from_column": "uid",
            "to_table": "c_ptv",
            "to_column": "uid",
            "condition": "c_prv.uid = c_ptv.uid",
            "confidence": "high",
            "reasoning": "Both tables have a required, indexed 'uid' field of type int. While there is no explicit foreign key, the naming and data type suggest that 'uid' may represent a common entity or owner (such as a user or account) across both tables. This is a common pattern in database design for associating records to the same logical entity. However, without more context, it is not certain that these refer to the same domain object.",
            "test_sql": "SELECT COUNT(*) FROM c_prv t1 JOIN c_ptv t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_prv",
            "from_column": "uid",
            "to_table": "c_psa",
            "to_column": "uid",
            "condition": "c_prv.uid = c_psa.uid",
            "confidence": "high",
            "reasoning": "Both tables contain a 'uid' field of type int, which likely represents an owner or user identifier. While there is no explicit foreign key, it is common in database design for related entities to be grouped or filtered by a common user or owner. This relationship could be used to join or filter records belonging to the same user across both tables.",
            "test_sql": "SELECT COUNT(*) FROM c_prv t1 JOIN c_psa t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 24,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_prv",
            "from_column": "uid",
            "to_table": "c_records",
            "to_column": "uid",
            "condition": "c_prv.uid = c_records.uid",
            "confidence": "high",
            "reasoning": "Both tables have a 'uid' field of type int, which is not a primary key in either table but is indexed and required (NOT NULL). The business analysis for both tables suggests that 'uid' represents an owner or user, and both tables support multiple records per uid. This suggests a logical relationship where records in both tables may belong to the same user or entity. However, without further context, this is not a strict foreign key relationship but rather a business logic association.",
            "test_sql": "SELECT COUNT(*) FROM c_prv t1 JOIN c_records t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_psa",
            "from_column": "attr_id",
            "to_table": "c_value_index_texts",
            "to_column": "attr_id",
            "condition": "c_psa.attr_id = c_value_index_texts.attr_id",
            "confidence": "high",
            "reasoning": "Both tables reference an 'attr_id' field of type int, which likely refers to the same attribute concept. In c_psa, 'attr_id' defines which attributes are associated with a type; in c_value_index_texts, 'attr_id' stores the value for a specific attribute of an entity. This suggests a logical relationship where c_psa defines the configuration of attributes, and c_value_index_texts stores the actual values for those attributes. However, there is no explicit foreign key or direct business operation linking these tables, so the relationship is inferred based on schema and business logic.",
            "test_sql": "SELECT COUNT(*) FROM c_psa t1 JOIN c_value_index_texts t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9291,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_psa",
            "from_column": "attr_id",
            "to_table": "c_value_texts",
            "to_column": "attr_id",
            "condition": "c_psa.attr_id = c_value_texts.attr_id",
            "confidence": "high",
            "reasoning": "Both tables reference an 'attr_id' field of type int, which likely refers to the same attribute definition. In c_psa, attr_id configures which attributes are available for a type; in c_value_texts, attr_id stores the value for a specific attribute of an entity. This suggests a logical relationship where c_psa defines the attribute's configuration, and c_value_texts stores its value for a given entity. However, there is no explicit foreign key or direct business operation linking these two tables, so the relationship is inferred based on schema and naming conventions.",
            "test_sql": "SELECT COUNT(*) FROM c_psa t1 JOIN c_value_texts t2 ON t1.attr_id = t2.attr_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 768,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ptv",
            "from_column": "uid",
            "to_table": "c_records",
            "to_column": "uid",
            "condition": "c_ptv.uid = c_records.uid",
            "confidence": "high",
            "reasoning": "Both tables have a required, indexed integer column named 'uid'. This suggests a possible logical or business relationship, such as both tables tracking records related to the same entity (e.g., a user, asset, or business object). However, without explicit foreign keys or further context, the exact nature of 'uid' is unclear. The matching names, types, and business purposes (tracking and logging) make this a plausible join candidate.",
            "test_sql": "SELECT COUNT(*) FROM c_ptv t1 JOIN c_records t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_relation_histories",
            "from_column": "second_ci_id",
            "to_table": "c_value_index_integers",
            "to_column": "ci_id",
            "condition": "c_relation_histories.second_ci_id = c_value_index_integers.ci_id",
            "confidence": "high",
            "reasoning": "Similar to the first relationship, 'second_ci_id' in c_relation_histories likely refers to the second entity in a relationship, which could also be a configuration item. Joining on this field allows analysis of attribute values for both entities involved in a relationship.",
            "test_sql": "SELECT COUNT(*) FROM c_relation_histories t1 JOIN c_value_index_integers t2 ON t1.second_ci_id = t2.ci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1536,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "common_employee",
            "from_column": "email",
            "to_table": "users",
            "to_column": "email",
            "condition": "common_employee.email = users.email",
            "confidence": "high",
            "reasoning": "Both tables have an 'email' field, which is a common unique identifier for individuals in business systems. The data types are compatible (varchar), and emails are often used to link user accounts to employee records. However, the 'email' field in 'common_employee' is nullable and not unique, while in 'users' it is not nullable and unique, so not all employees may have a corresponding user, and vice versa.",
            "test_sql": "SELECT COUNT(*) FROM common_employee t1 JOIN users t2 ON t1.email = t2.email LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_login_logs",
            "from_column": "username",
            "to_table": "acl_operation_records",
            "to_column": "rolename",
            "condition": "acl_audit_login_logs.username = acl_operation_records.rolename",
            "confidence": "high",
            "reasoning": "The only potentially joinable fields by name and type are 'username' (login logs) and 'rolename' (operation records), both varchar fields. However, 'username' typically refers to a user identity, while 'rolename' refers to a role or group, which are conceptually different. There is no evidence in the schema or business logic that these fields are meant to represent the same entity. This join is speculative and not recommended for production use without further business context.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_login_logs t1 JOIN acl_operation_records t2 ON t1.username = t2.rolename LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 32,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_login_logs",
            "from_column": "username",
            "to_table": "acl_roles",
            "to_column": "name",
            "condition": "acl_audit_login_logs.username = acl_roles.name",
            "confidence": "high",
            "reasoning": "The only possible field similarity is between 'username' in acl_audit_login_logs and 'name' in acl_roles. However, 'name' in acl_roles is intended to represent a role name, not a username. There is no direct evidence that these fields are semantically or structurally related, and their business purposes are different. This relationship is not likely in a well-designed schema, but is included for completeness based on naming similarity.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_login_logs t1 JOIN acl_roles t2 ON t1.username = t2.name LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "source",
            "to_table": "acl_audit_role_logs",
            "to_column": "source",
            "condition": "acl_audit_permission_logs.source = acl_audit_role_logs.source",
            "confidence": "high",
            "reasoning": "Both tables have a source field, possibly indicating the origin of the action (e.g., UI, API, system). While this could be used to correlate logs from the same source, the business value is less direct and the field may not always be populated or standardized.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_audit_role_logs t2 ON t1.source = t2.source LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "created_at",
            "to_table": "acl_audit_resource_logs",
            "to_column": "created_at",
            "condition": "acl_audit_permission_logs.created_at = acl_audit_resource_logs.created_at",
            "confidence": "high",
            "reasoning": "Both tables have a 'created_at' timestamp, but matching on this field is only meaningful for events that occurred at exactly the same time, which is rare. This join could be used for statistical or temporal correlation, but is not a strong business relationship.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_audit_resource_logs t2 ON t1.created_at = t2.created_at LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 15,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "rid",
            "to_table": "acl_role_relations",
            "to_column": "parent_id",
            "condition": "acl_audit_permission_logs.rid = acl_role_relations.parent_id",
            "confidence": "high",
            "reasoning": "The field rid in acl_audit_permission_logs could represent a role id, and parent_id in acl_role_relations references a role id. If rid is used to log actions on roles, there may be a logical connection. However, without explicit documentation or foreign key constraints, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_role_relations t2 ON t1.rid = t2.parent_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "rid",
            "to_table": "acl_role_relations",
            "to_column": "child_id",
            "condition": "acl_audit_permission_logs.rid = acl_role_relations.child_id",
            "confidence": "high",
            "reasoning": "Similarly, if rid in the audit log refers to a role id, and child_id in acl_role_relations is a role id, there could be a logical relationship for auditing changes to child roles. This is also speculative without further documentation.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN acl_role_relations t2 ON t1.rid = t2.child_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 14,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_permission_logs",
            "from_column": "operate_uid",
            "to_table": "c_ptv",
            "to_column": "uid",
            "condition": "acl_audit_permission_logs.operate_uid = c_ptv.uid",
            "confidence": "high",
            "reasoning": "Both tables have an integer field named 'operate_uid' and 'uid' respectively, which could potentially represent a user or operator identifier. However, there is no explicit foreign key or business context provided to confirm that these fields refer to the same entity. The naming similarity and data type compatibility suggest a possible relationship, but without further information, the confidence is low.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_permission_logs t1 JOIN c_ptv t2 ON t1.operate_uid = t2.uid LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "link_id",
            "to_table": "c_ad_ci_types",
            "to_column": "id",
            "condition": "acl_audit_resource_logs.link_id = c_ad_ci_types.id",
            "confidence": "high",
            "reasoning": "Both fields are of type int and could theoretically be linked if 'link_id' in the audit log is used to reference a resource in c_ad_ci_types. However, there is no explicit naming or business logic in the provided schemas to confirm this. The relationship is possible if 'link_id' is used generically to reference various resource tables, including c_ad_ci_types, but this is speculative.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN c_ad_ci_types t2 ON t1.link_id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "link_id",
            "to_table": "c_attribute_histories",
            "to_column": "record_id",
            "condition": "acl_audit_resource_logs.link_id = c_attribute_histories.record_id",
            "confidence": "high",
            "reasoning": "Both fields are of type int and could potentially reference the same resource/entity, with 'link_id' in the audit log possibly pointing to a record in another table. However, there is no explicit foreign key or naming convention directly linking these two fields, and their business purposes are distinct (general resource audit vs. attribute change history). This is a speculative relationship based on the generic use of 'link_id' as a possible reference to a record.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN c_attribute_histories t2 ON t1.link_id = t2.record_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "link_id",
            "to_table": "c_attributes",
            "to_column": "id",
            "condition": "acl_audit_resource_logs.link_id = c_attributes.id",
            "confidence": "high",
            "reasoning": "Both fields are of type int and could theoretically be joined, but there is no clear business or naming indication that 'link_id' in the audit log refers to an attribute definition in c_attributes. 'link_id' is described as a generic reference to a resource, but without further context, it is not possible to confidently assert that it points to c_attributes. This is a speculative relationship based solely on data type compatibility and the generic nature of 'link_id'.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN c_attributes t2 ON t1.link_id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "link_id",
            "to_table": "c_ci_relations",
            "to_column": "id",
            "condition": "acl_audit_resource_logs.link_id = c_ci_relations.id",
            "confidence": "high",
            "reasoning": "Both fields are of type int and could theoretically be linked if an audit log entry is specifically tracking changes to a CI relationship (i.e., a record in c_ci_relations). However, there is no explicit naming or business logic evidence that 'link_id' in the audit log refers to a CI relation. The 'link_id' is described as a generic reference to a resource, and 'c_ci_relations.id' is a resource in the context of CI relationships, but this is speculative.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN c_ci_relations t2 ON t1.link_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "link_id",
            "to_table": "c_ci_types",
            "to_column": "id",
            "condition": "acl_audit_resource_logs.link_id = c_ci_types.id",
            "confidence": "high",
            "reasoning": "The field 'link_id' in acl_audit_resource_logs is a generic integer reference, and 'id' in c_ci_types is the primary key. There is no explicit foreign key or naming convention directly linking these fields, but in some audit log designs, a generic 'link_id' may reference various resource tables, including CI types. However, without further context or a field indicating the resource type, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN c_ci_types t2 ON t1.link_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "link_id",
            "to_table": "c_psa",
            "to_column": "id",
            "condition": "acl_audit_resource_logs.link_id = c_psa.id",
            "confidence": "high",
            "reasoning": "Both fields are of type int and could theoretically be used to link an audit log entry to a specific c_psa record, possibly to track changes to attribute-type associations. However, there is no explicit foreign key or naming convention to confirm this, and the business purposes of the tables are quite distinct. The 'link_id' in acl_audit_resource_logs is a generic reference and could point to any resource, but without further context, this is only a speculative relationship.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN c_psa t2 ON t1.link_id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "operate_type",
            "to_table": "acl_audit_role_logs",
            "to_column": "operate_type",
            "condition": "acl_audit_resource_logs.operate_type = acl_audit_role_logs.operate_type",
            "confidence": "high",
            "reasoning": "Both tables have an 'operate_type' field, which may represent the type of operation performed (e.g., create, update, delete). While the data types are compatible, the actual values and semantics may differ between resource and role operations. This join could be useful for statistical or reporting purposes but is less likely to represent a direct business relationship.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN acl_audit_role_logs t2 ON t1.operate_type = t2.operate_type LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_audit_resource_logs",
            "from_column": "link_id",
            "to_table": "c_relation_histories",
            "to_column": "id",
            "condition": "acl_audit_resource_logs.link_id = c_relation_histories.id",
            "confidence": "high",
            "reasoning": "Both fields are of type int and could theoretically be used to link a resource log entry to a specific relationship history record. However, there is no explicit naming or business logic connection between 'link_id' and 'id' in the context of these two tables. The 'link_id' in acl_audit_resource_logs is described as a generic foreign key to a resource, but there is no evidence that it specifically references c_relation_histories. This is a speculative relationship based solely on data type compatibility and common database patterns.",
            "test_sql": "SELECT COUNT(*) FROM acl_audit_resource_logs t1 JOIN c_relation_histories t2 ON t1.link_id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_operation_records",
            "from_column": "rolename",
            "to_table": "users",
            "to_column": "username",
            "condition": "acl_operation_records.rolename = users.username",
            "confidence": "high",
            "reasoning": "The 'rolename' field in acl_operation_records and the 'username' field in users are both varchar(32) and could, in some systems, be related if usernames are used as role identifiers. However, typically 'rolename' refers to a role (e.g., 'admin', 'editor'), not a specific user. There is no explicit user identifier (such as user ID or username) in acl_operation_records, so this relationship is speculative and not strongly supported by the schema.",
            "test_sql": "SELECT COUNT(*) FROM acl_operation_records t1 JOIN users t2 ON t1.rolename = t2.username LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 32,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_operation_records",
            "from_column": "rolename",
            "to_table": "common_employee",
            "to_column": "username",
            "condition": "acl_operation_records.rolename = common_employee.username",
            "confidence": "high",
            "reasoning": "The 'rolename' field in 'acl_operation_records' and the 'username' field in 'common_employee' are both varchar fields and could, in some systems, be related if usernames are used as role identifiers. However, typically 'rolename' refers to a role (e.g., 'admin', 'manager'), while 'username' is a unique identifier for an employee. There is no strong evidence in the schema or business logic that these fields are directly related, but a weak business logic relationship is possible if the system uses usernames as role names.",
            "test_sql": "SELECT COUNT(*) FROM acl_operation_records t1 JOIN common_employee t2 ON t1.rolename = t2.username LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 32,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "acl_roles",
            "from_column": "uid",
            "to_table": "c_psa",
            "to_column": "uid",
            "condition": "acl_roles.uid = c_psa.uid",
            "confidence": "high",
            "reasoning": "Both tables contain a 'uid' field of type int, which could represent a user or entity identifier. However, there is no explicit foreign key or business logic in the provided schemas or business purposes that directly links these tables. The presence of 'uid' in both tables is the only basis for a possible relationship, but without further context, this is speculative.",
            "test_sql": "SELECT COUNT(*) FROM acl_roles t1 JOIN c_psa t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 24,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ad_ci_types",
            "from_column": "uid",
            "to_table": "c_records",
            "to_column": "uid",
            "condition": "c_ad_ci_types.uid = c_records.uid",
            "confidence": "high",
            "reasoning": "Both tables have a 'uid' field of type int. In c_ad_ci_types, 'uid' is nullable and likely represents a user or owner, while in c_records, 'uid' is not nullable and likely represents the subject of the record. There is no explicit foreign key or business logic tying these together, but it is possible that both reference the same entity (e.g., user) in the business domain. However, without more context, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM c_ad_ci_types t1 JOIN c_records t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_ad_ci_types",
            "from_column": "uid",
            "to_table": "c_ptv",
            "to_column": "uid",
            "condition": "c_ad_ci_types.uid = c_ptv.uid",
            "confidence": "high",
            "reasoning": "Both tables have a 'uid' field of type int, but the business meaning of 'uid' in each table is not defined in the provided schemas. There is no explicit foreign key or business context linking these fields, so any relationship would be speculative and likely weak unless further business rules are known.",
            "test_sql": "SELECT COUNT(*) FROM c_ad_ci_types t1 JOIN c_ptv t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_attributes",
            "from_column": "id",
            "to_table": "c_ci_type_attribute_groups",
            "to_column": "id",
            "condition": "c_attributes.id = c_ci_type_attribute_groups.id",
            "confidence": "high",
            "reasoning": "Although both tables have an 'id' field as their primary key, these are auto-incrementing and serve as unique identifiers for their respective tables. There is no business logic, naming convention, or schema evidence to suggest these IDs are related. This is a common field name but not a meaningful relationship.",
            "test_sql": "SELECT COUNT(*) FROM c_attributes t1 JOIN c_ci_type_attribute_groups t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_prv",
            "from_column": "id",
            "to_table": "c_relation_histories",
            "to_column": "relation_id",
            "condition": "c_prv.id = c_relation_histories.relation_id",
            "confidence": "high",
            "reasoning": "Both fields are of type int and could theoretically represent a relationship between a 'provision/profile' (c_prv) and a relationship history (c_relation_histories). However, there is no explicit naming or business logic that directly connects these fields. The field 'relation_id' in c_relation_histories could refer to a relationship record in another table, but without more context, this is speculative. The only basis is data type compatibility and a possible naming overlap.",
            "test_sql": "SELECT COUNT(*) FROM c_prv t1 JOIN c_relation_histories t2 ON t1.id = t2.relation_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_psa",
            "from_column": "uid",
            "to_table": "c_ptv",
            "to_column": "uid",
            "condition": "c_psa.uid = c_ptv.uid",
            "confidence": "high",
            "reasoning": "Both tables have a non-nullable uid field of the same data type (int), but there is no explicit foreign key or business logic described that links these uids. The meaning of uid in each table is unclear and may not refer to the same entity. This join is possible by naming convention and data type, but lacks strong business justification.",
            "test_sql": "SELECT COUNT(*) FROM c_psa t1 JOIN c_ptv t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 24,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_psa",
            "from_column": "uid",
            "to_table": "c_records",
            "to_column": "uid",
            "condition": "c_psa.uid = c_records.uid",
            "confidence": "high",
            "reasoning": "Both tables have a 'uid' field of the same data type (int), but there is no information about what 'uid' represents in either table. Without further context, it is unclear if these refer to the same entity or concept. The relationship is possible but speculative.",
            "test_sql": "SELECT COUNT(*) FROM c_psa t1 JOIN c_records t2 ON t1.uid = t2.uid LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 144,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_relation_histories",
            "from_column": "first_ci_id",
            "to_table": "c_value_index_texts",
            "to_column": "ci_id",
            "condition": "c_relation_histories.first_ci_id = c_value_index_texts.ci_id",
            "confidence": "high",
            "reasoning": "Both tables contain fields that reference a 'ci_id' (configuration item id) concept, but in c_relation_histories, 'first_ci_id' is nullable and not a foreign key, while in c_value_index_texts, 'ci_id' is required and a foreign key. There is no explicit relationship or naming convention directly connecting these fields, but it is possible that 'first_ci_id' in c_relation_histories could correspond to 'ci_id' in c_value_index_texts if both reference the same entity. However, this is speculative and not strongly supported by the schema.",
            "test_sql": "SELECT COUNT(*) FROM c_relation_histories t1 JOIN c_value_index_texts t2 ON t1.first_ci_id = t2.ci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 840,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "c_relation_histories",
            "from_column": "second_ci_id",
            "to_table": "c_value_index_texts",
            "to_column": "ci_id",
            "condition": "c_relation_histories.second_ci_id = c_value_index_texts.ci_id",
            "confidence": "high",
            "reasoning": "Similar to the previous relationship, 'second_ci_id' in c_relation_histories could potentially reference the same entity as 'ci_id' in c_value_index_texts. There is no explicit foreign key or strong naming convention, but both fields are of type int and may represent configuration item identifiers. This is a weak, inferred relationship based on possible business logic.",
            "test_sql": "SELECT COUNT(*) FROM c_relation_histories t1 JOIN c_value_index_texts t2 ON t1.second_ci_id = t2.ci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7753,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "common_employee",
            "from_column": "username",
            "to_table": "users",
            "to_column": "username",
            "condition": "common_employee.username = users.username",
            "confidence": "high",
            "reasoning": "Both tables have a 'username' field, but the data types and lengths differ, and 'username' is not required in 'common_employee'. In 'users', it is unique but nullable. This could be a weak join for some records, but is not a strong or reliable relationship.",
            "test_sql": "SELECT COUNT(*) FROM common_employee t1 JOIN users t2 ON t1.username = t2.username LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        }
    ]
}