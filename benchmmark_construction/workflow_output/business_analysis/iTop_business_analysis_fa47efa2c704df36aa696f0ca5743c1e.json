{
    "core_tables": [
        "applicationsolution",
        "brand",
        "connectableci",
        "contact",
        "contacttype",
        "contract",
        "customercontract",
        "databaseschema",
        "datacenterdevice",
        "dbserver",
        "deliverymodel",
        "farm",
        "functionalci",
        "hypervisor",
        "lnkapplicationsolutiontofunctionalci",
        "lnkcustomercontracttoservice",
        "lnkdeliverymodeltocontact",
        "lnkpersontoteam",
        "lnkslatoslt",
        "location",
        "model",
        "networkdevice",
        "networkdevicetype",
        "organization",
        "osfamily",
        "osversion",
        "person",
        "physicaldevice",
        "priv_action",
        "priv_action_email",
        "priv_action_notification",
        "priv_app_preferences",
        "priv_change",
        "priv_changeop",
        "priv_changeop_create",
        "priv_changeop_links",
        "priv_changeop_links_addremove",
        "priv_changeop_links_tune",
        "priv_changeop_setatt",
        "priv_changeop_setatt_scalar",
        "priv_db_properties",
        "priv_extension_install",
        "priv_internaluser",
        "priv_link_action_trigger",
        "priv_module_install",
        "priv_query",
        "priv_query_oql",
        "priv_tagfielddata",
        "priv_trigger",
        "priv_trigger_onobject",
        "priv_trigger_onobjmention",
        "priv_urp_profiles",
        "priv_urp_userprofile",
        "priv_user",
        "priv_user_local",
        "rack",
        "remoteapplicationtype",
        "server",
        "service",
        "servicefamily",
        "servicesubcategory",
        "sla",
        "slt",
        "software",
        "softwareinstance",
        "team",
        "typology",
        "virtualdevice",
        "virtualhost",
        "virtualmachine",
        "webapplication",
        "webserver"
    ],
    "table_analysis": {
        "applicationsolution": {
            "business_purpose": "The 'applicationsolution' table appears to represent a catalog or registry of application solutions within an organization. Each record likely corresponds to a distinct application solution, with metadata about its operational status and redundancy configuration. This table is used to track and manage the lifecycle and availability characteristics of application solutions.",
            "key_fields": [
                "id",
                "status",
                "redundancy"
            ],
            "potential_relationships": [
                "Could serve as a parent or reference table for detailed configuration, deployment, or monitoring records related to each application solution",
                "Might be referenced by tables tracking incidents, changes, or assets associated with each application solution"
            ],
            "business_operations": [
                "Registering new application solutions",
                "Updating the operational status (active/inactive) of solutions",
                "Configuring or auditing redundancy settings for solutions",
                "Reporting on the inventory and status of application solutions"
            ]
        },
        "brand": {
            "business_purpose": "The 'brand' table represents a unique business entity for storing distinct brands within a system. Each record corresponds to a single brand, identified solely by an auto-incrementing integer ID. This table likely serves as a foundational reference for associating brands with other business entities or processes.",
            "key_fields": [
                "id"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as the 'one' side in a one-to-many relationship, where each brand may be referenced by multiple records in other tables (e.g., products, assets, or campaigns).",
                "Many-to-many: It could also participate in many-to-many relationships via junction tables, allowing brands to be linked with other entities in complex ways."
            ],
            "business_operations": [
                "Creating new brand records (inserting new brands into the system)",
                "Retrieving brand IDs for reference or association with other business data",
                "Listing all available brands (for selection or reporting purposes)",
                "Deleting or deactivating brands (if business rules allow removal)"
            ]
        },
        "connectableci": {
            "business_purpose": "The 'connectableci' table appears to represent a generic entity for 'Connectable Configuration Items' (CIs), likely used in IT asset management, configuration management, or systems inventory. The table is designed to store unique records for items that can be connected or related in some way, with the 'finalclass' field suggesting support for inheritance or polymorphism, allowing different types of connectable items to be tracked under a common structure.",
            "key_fields": [
                "id",
                "finalclass"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as a parent or base table for more specific configuration item tables, with other tables referencing its 'id' as a foreign key.",
                "Polymorphic: The 'finalclass' field suggests that this table may be used in a polymorphic relationship, where different subtypes of connectable items are distinguished by class name.",
                "Lookup/reference: Other tables may reference this table to associate records with a specific connectable configuration item."
            ],
            "business_operations": [
                "Registering new connectable configuration items",
                "Querying or listing all connectable items, possibly filtered by type ('finalclass')",
                "Extending or subclassing configuration items for specialized business processes",
                "Auditing or tracking the existence and types of connectable items in the system"
            ]
        },
        "contact": {
            "business_purpose": "The 'contact' table represents individual contact records, likely for people associated with an organization or business. It is designed to store information about each contact, such as their name, status (active/inactive), organization association, communication details, and role/function. The table supports tracking the lifecycle of a contact, including obsolescence (end of relevance) and notification preferences.",
            "key_fields": [
                "id",
                "name",
                "status",
                "org_id",
                "email",
                "phone",
                "notify",
                "function",
                "obsolescence_date"
            ],
            "potential_relationships": [
                "Many-to-one relationship with an organization entity (via org_id), where multiple contacts may be associated with a single organization",
                "Possible subclassing or type differentiation using the 'finalclass' field, allowing for polymorphic relationships if extended",
                "Potential for use as a reference in communication, notification, or workflow processes"
            ],
            "business_operations": [
                "Adding new contact records",
                "Updating contact details (name, email, phone, function, status)",
                "Associating contacts with organizations (via org_id)",
                "Filtering or searching contacts by status, organization, or function",
                "Managing notification preferences for contacts",
                "Marking contacts as obsolete or inactive (using status and obsolescence_date)",
                "Reporting or exporting contact lists for communication or compliance purposes"
            ]
        },
        "contacttype": {
            "business_purpose": "The 'contacttype' table is designed to represent different types or categories of contacts within a business context. Each record in this table uniquely identifies a contact type, which could be used to classify or group contacts according to their nature or role (e.g., customer, supplier, partner), though the specific types are not detailed in the structure provided.",
            "key_fields": [
                "id"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as a reference or lookup table, where its primary key ('id') is used as a foreign key in other tables to categorize or associate records with a specific contact type."
            ],
            "business_operations": [
                "Defining and managing the available contact types in the system",
                "Referencing contact types when creating or updating records in other tables",
                "Reporting or filtering data based on contact type classifications"
            ]
        },
        "contract": {
            "business_purpose": "The 'contract' table represents contractual agreements, likely between an organization and external providers or entities. It is designed to store details about each contract, such as its name, associated organization, provider, type, cost, currency, billing frequency, status, and relevant dates. This table is central to managing and tracking the lifecycle, financials, and classification of contracts within a business context.",
            "key_fields": [
                "id",
                "name",
                "org_id",
                "provider_id",
                "contracttype_id",
                "start_date",
                "end_date",
                "cost",
                "cost_currency",
                "billing_frequency",
                "status",
                "finalclass"
            ],
            "potential_relationships": [
                "May reference organizations via 'org_id'",
                "May reference providers via 'provider_id'",
                "May reference contract types via 'contracttype_id'",
                "May be subclassed or extended via 'finalclass' for polymorphic behavior"
            ],
            "business_operations": [
                "Creating new contracts",
                "Updating contract details (e.g., cost, status, dates)",
                "Tracking contract status and lifecycle (implementation, production, obsolete)",
                "Reporting on contract costs, durations, and billing frequencies",
                "Filtering or searching contracts by organization, provider, type, or status",
                "Archiving or marking contracts as obsolete",
                "Classifying contracts for business logic or reporting (using 'finalclass')"
            ]
        },
        "customercontract": {
            "business_purpose": "The 'customercontract' table appears to represent individual customer contract records within a business system. Each record likely corresponds to a unique contract, serving as a foundational entity for tracking agreements or arrangements with customers.",
            "key_fields": [
                "id"
            ],
            "potential_relationships": [
                "This table could serve as a parent or reference table in one-to-many relationships, where other tables might link to specific contracts via a foreign key.",
                "It could also be a target for lookup or join operations from related transactional or detail tables."
            ],
            "business_operations": [
                "Creating new customer contract records (insertion).",
                "Retrieving or listing contract records (selection).",
                "Updating contract identifiers (though typically rare for primary keys).",
                "Deleting contract records (removal)."
            ]
        },
        "databaseschema": {
            "business_purpose": "The 'databaseschema' table appears to represent individual database schemas or schema definitions within a system, potentially tracking or cataloging schemas that exist on different database servers. It serves as a registry or inventory of schemas, possibly for management, auditing, or configuration purposes.",
            "key_fields": [
                "id",
                "dbserver_id"
            ],
            "potential_relationships": [
                "One-to-many: Each database server (referenced by dbserver_id) could have multiple schemas (rows in this table) associated with it.",
                "Many-to-one: Each schema entry is associated with a single database server (dbserver_id)."
            ],
            "business_operations": [
                "Registering or cataloging new database schemas as they are created.",
                "Querying to list all schemas associated with a particular database server.",
                "Auditing or reporting on the distribution of schemas across servers.",
                "Updating or maintaining schema records as database infrastructure changes.",
                "Deleting schema records when schemas are dropped or decommissioned."
            ]
        },
        "datacenterdevice": {
            "business_purpose": "The 'datacenterdevice' table represents physical devices located within a data center environment. Each record corresponds to a device (such as a server, switch, or storage unit) and captures its placement (rack, enclosure), management interface, power connections, and redundancy configuration. The table is designed to support inventory, asset management, and infrastructure planning for data center operations.",
            "key_fields": [
                "id",
                "rack_id",
                "enclosure_id",
                "nb_u",
                "managementip",
                "powera_id",
                "powerB_id",
                "redundancy",
                "finalclass"
            ],
            "potential_relationships": [
                "Many-to-one relationship with racks (via rack_id), indicating that multiple devices can be located in a single rack.",
                "Many-to-one relationship with enclosures (via enclosure_id), suggesting devices may be grouped within enclosures.",
                "Many-to-one relationship with power sources or power distribution units (via powera_id and powerB_id), representing the device's power connections.",
                "Potential inheritance or polymorphic relationship indicated by 'finalclass', allowing for different device subtypes to be represented in the same table."
            ],
            "business_operations": [
                "Tracking and managing the inventory of devices in a data center.",
                "Mapping device locations within racks and enclosures for physical asset management.",
                "Monitoring and updating device management IP addresses for remote access and configuration.",
                "Managing power redundancy and connections for high availability planning.",
                "Supporting capacity planning by recording device size (nb_u) and placement.",
                "Facilitating reporting and auditing of data center assets."
            ]
        },
        "dbserver": {
            "business_purpose": "The 'dbserver' table appears to represent a registry or catalog of database servers or server instances within an organization. Each record uniquely identifies a database server, likely for purposes such as tracking, management, or configuration.",
            "key_fields": [
                "id"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as a parent table, with other tables referencing its 'id' as a foreign key to associate records with a specific database server.",
                "One-to-one: It could be referenced by another table that stores additional details about each server.",
                "Many-to-many: Through a junction table, it could be linked to other entities such as applications or environments."
            ],
            "business_operations": [
                "Registering new database servers",
                "Tracking or auditing database server instances",
                "Referencing database servers in other operational or configuration records",
                "Managing the lifecycle (creation, deletion) of database server entries"
            ]
        },
        "deliverymodel": {
            "business_purpose": "The 'deliverymodel' table represents different models or methods of delivery that an organization can define and use. This could refer to how products, services, or projects are delivered within or by an organization. Each delivery model has a unique identifier, a name, an optional association with an organization, and a description.",
            "key_fields": [
                "id",
                "name",
                "org_id",
                "description"
            ],
            "potential_relationships": [
                "May serve as a reference or lookup table for other tables that need to specify a delivery model.",
                "The 'org_id' field suggests a possible association with organizational entities, indicating that delivery models can be specific to or shared among organizations.",
                "The 'name' field being indexed (MUL) suggests it may be used for searching or joining with other data."
            ],
            "business_operations": [
                "Defining and managing available delivery models.",
                "Associating delivery models with organizational processes or records.",
                "Querying or reporting on delivery models for administrative or analytical purposes.",
                "Selecting or filtering by delivery model in business workflows."
            ]
        },
        "farm": {
            "business_purpose": "The 'farm' table appears to represent a collection of farm entities or units within a business context. Each record uniquely identifies a farm, possibly for the purpose of tracking, management, or resource allocation. The presence of a 'redundancy' field suggests the table may also be used to indicate backup, failover, or duplication status for each farm entity, or to categorize farms by a redundancy-related attribute.",
            "key_fields": [
                "id",
                "redundancy"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as a parent in relationships where each farm is associated with multiple related records in other tables (e.g., assets, resources, or operational logs).",
                "One-to-one: Each farm could be linked to a unique configuration or status record in another table.",
                "Many-to-many: Farms could be associated with multiple entities in another table through a junction table, depending on business needs."
            ],
            "business_operations": [
                "Registering or creating new farm entities.",
                "Querying or listing all farms and their redundancy status.",
                "Updating the redundancy attribute to reflect changes in farm status or configuration.",
                "Deleting farm records when a farm is decommissioned or no longer tracked.",
                "Auditing or reporting on farm redundancy for operational or compliance purposes."
            ]
        },
        "functionalci": {
            "business_purpose": "The 'functionalci' table represents a catalog of functional configuration items (CIs), likely used to track and manage key components, assets, or services within an organization. Each record describes a distinct functional item, its business importance, organizational ownership, lifecycle dates, and classification. This is typical in IT service management, asset management, or business process tracking contexts.",
            "key_fields": [
                "id",
                "name",
                "org_id",
                "business_criticity",
                "move2production",
                "obsolescence_date",
                "finalclass"
            ],
            "potential_relationships": [
                "Belongs-to relationship with an organization or entity referenced by 'org_id'",
                "Classification or inheritance relationship indicated by 'finalclass'",
                "Possible many-to-many or one-to-many relationships with other configuration items, assets, or business processes (not shown in this schema)"
            ],
            "business_operations": [
                "Registering new configuration items or assets",
                "Updating details, status, or classification of existing items",
                "Tracking business criticality for risk and impact analysis",
                "Managing lifecycle events such as moving items to production or marking them obsolete",
                "Filtering or reporting on items by organization, criticality, or lifecycle stage"
            ]
        },
        "hypervisor": {
            "business_purpose": "The 'hypervisor' table appears to represent a record of hypervisor instances or entities, likely used to manage or track virtualization hosts within a larger infrastructure. Each record may associate a hypervisor with a specific farm (possibly a logical grouping or cluster) and a server (potentially the physical or virtual machine running the hypervisor).",
            "key_fields": [
                "id",
                "farm_id",
                "server_id"
            ],
            "potential_relationships": [
                "Many-to-one relationship from hypervisor to farm (via farm_id), if a farm entity exists",
                "Many-to-one relationship from hypervisor to server (via server_id), if a server entity exists",
                "Acts as a linking or associative table between farms and servers, if both are present"
            ],
            "business_operations": [
                "Registering or provisioning new hypervisors",
                "Assigning hypervisors to farms or clusters",
                "Mapping hypervisors to specific servers",
                "Querying which hypervisors belong to a particular farm or server",
                "Auditing or reporting on virtualization infrastructure"
            ]
        },
        "lnkapplicationsolutiontofunctionalci": {
            "business_purpose": "This table represents a linkage or association between two entities: 'applicationsolution' and 'functionalci'. It is designed to map or relate application solutions to functional configuration items (CIs), likely to track which application solutions depend on or are implemented by which functional CIs. This is typical in environments where applications are mapped to underlying technical or functional components for management, support, or analysis purposes.",
            "key_fields": [
                "id",
                "applicationsolution_id",
                "functionalci_id"
            ],
            "potential_relationships": [
                "Many-to-many relationship between application solutions and functional configuration items, where each application solution can be linked to multiple functional CIs and each functional CI can be linked to multiple application solutions.",
                "Acts as a bridge or junction table connecting the two entities via their respective IDs."
            ],
            "business_operations": [
                "Tracking and managing dependencies between application solutions and functional CIs.",
                "Reporting on which functional CIs support or are used by specific application solutions.",
                "Impact analysis for changes or incidents affecting either application solutions or functional CIs.",
                "Facilitating audits or compliance checks by showing the mapping between business applications and their underlying functional components."
            ]
        },
        "lnkcustomercontracttoservice": {
            "business_purpose": "This table represents a linkage between customer contracts and services, potentially associating each contract with one or more services and specifying a service level agreement (SLA) for each association. It acts as a junction or mapping table to manage which services are provided under which customer contracts, and under what SLA terms.",
            "key_fields": [
                "id",
                "customercontract_id",
                "service_id",
                "sla_id"
            ],
            "potential_relationships": [
                "Many-to-many relationship between customer contracts and services, with each link optionally associated with an SLA.",
                "Each record links a specific customer contract to a specific service, possibly under a specific SLA."
            ],
            "business_operations": [
                "Assigning services to customer contracts.",
                "Defining or updating the SLA terms for a service under a specific contract.",
                "Querying which services are included in a given customer contract.",
                "Auditing or reporting on the services and SLAs associated with customer contracts.",
                "Removing or modifying service associations from customer contracts."
            ]
        },
        "lnkdeliverymodeltocontact": {
            "business_purpose": "This table represents a linkage or association between delivery models and contacts, with an additional context of a role. It is likely used to map which contacts are associated with which delivery models, and in what capacity (role). This enables the business to track and manage the involvement of various contacts in different delivery models, possibly for project management, service delivery, or organizational structuring.",
            "key_fields": [
                "id",
                "deliverymodel_id",
                "contact_id",
                "role_id"
            ],
            "potential_relationships": [
                "Many-to-many relationship between delivery models and contacts, with each association optionally qualified by a role",
                "Each record links a single delivery model to a single contact, possibly with a specific role"
            ],
            "business_operations": [
                "Assigning contacts to delivery models with specific roles",
                "Querying which contacts are involved in a particular delivery model",
                "Determining the role of a contact within a delivery model",
                "Managing or updating the associations between delivery models, contacts, and roles",
                "Auditing or reporting on the involvement of contacts across delivery models"
            ]
        },
        "lnkpersontoteam": {
            "business_purpose": "This table represents a linkage or association between persons and teams, with an additional specification of the person's role within the team. It is designed to track which persons are assigned to which teams and in what capacity, supporting scenarios where a person can belong to multiple teams and have different roles in each.",
            "key_fields": [
                "id",
                "team_id",
                "person_id",
                "role_id"
            ],
            "potential_relationships": [
                "Many-to-many relationship between persons and teams, with each link potentially having a specific role.",
                "Each record links a person to a team and specifies a role, indicating a composite association."
            ],
            "business_operations": [
                "Assigning a person to a team with a specific role.",
                "Querying all persons in a given team and their roles.",
                "Listing all teams a person is part of and their roles in each.",
                "Updating or changing a person's role within a team.",
                "Removing a person from a team."
            ]
        },
        "lnkslatoslt": {
            "business_purpose": "This table appears to represent a linking or association entity between two other entities, likely named 'sla' and 'slt'. Its purpose is to establish a many-to-many relationship between these two entities, allowing each 'sla' to be associated with multiple 'slt' records and vice versa.",
            "key_fields": [
                "id",
                "sla_id",
                "slt_id"
            ],
            "potential_relationships": [
                "Many-to-many relationship between 'sla' and 'slt' entities, with this table serving as the join table.",
                "Each record links a single 'sla' to a single 'slt', enabling cross-referencing between the two."
            ],
            "business_operations": [
                "Creating associations between 'sla' and 'slt' records.",
                "Querying to find all 'slt' records linked to a specific 'sla', or all 'sla' records linked to a specific 'slt'.",
                "Removing or updating associations between 'sla' and 'slt'.",
                "Auditing or reporting on the connections between 'sla' and 'slt' entities."
            ]
        },
        "location": {
            "business_purpose": "The 'location' table represents physical or organizational locations associated with an entity, likely used to track and manage different sites, branches, offices, or facilities. It stores identifying, status, and address information for each location, possibly within a larger organization or system.",
            "key_fields": [
                "id",
                "name",
                "status",
                "org_id",
                "address",
                "obsolescence_date"
            ],
            "potential_relationships": [
                "May serve as a parent or reference table for assets, events, or resources assigned to a location",
                "org_id suggests a possible association with an organization or grouping entity, indicating a many-to-one relationship (many locations per org_id)",
                "Could be referenced by tables tracking activities, inventory, or personnel at specific locations"
            ],
            "business_operations": [
                "Adding, updating, or deactivating locations as business sites change",
                "Querying active or inactive locations for reporting or operational purposes",
                "Associating business processes, assets, or events with specific locations",
                "Tracking the lifecycle of locations, including obsolescence or closure dates",
                "Filtering or grouping data by location for analysis or management"
            ]
        },
        "model": {
            "business_purpose": "The 'model' table represents a catalog of hardware or device models, each associated with a specific brand and classified by device type (such as Server, Printer, MobilePhone, etc.). It is likely used to standardize and manage the different models of equipment or products that a business tracks, sells, supports, or inventories.",
            "key_fields": [
                "id",
                "brand_id",
                "type"
            ],
            "potential_relationships": [
                "Many-to-one: Each model may be associated with a single brand (via brand_id), suggesting a potential relationship to a brands table.",
                "One-to-many: This table could serve as a reference for other tables that track individual assets, inventory, or product instances, where each instance refers to a model.",
                "Classification: The 'type' field allows grouping or filtering models by device category."
            ],
            "business_operations": [
                "Adding new device or product models to the catalog",
                "Querying available models by type or brand",
                "Updating model information (e.g., changing type or brand association)",
                "Reporting or analytics on the distribution of models by type or brand",
                "Referencing models when managing inventory, support, or sales records"
            ]
        },
        "networkdevice": {
            "business_purpose": "The 'networkdevice' table represents individual network devices within an organization or system. Each record stores information about a specific device, including its type, operating system version, and RAM specification. The table is likely used to inventory, manage, or track network hardware assets.",
            "key_fields": [
                "id",
                "networkdevicetype_id",
                "iosversion_id",
                "ram"
            ],
            "potential_relationships": [
                "Many-to-one relationship to a table of network device types (via networkdevicetype_id)",
                "Many-to-one relationship to a table of operating system versions (via iosversion_id)"
            ],
            "business_operations": [
                "Registering new network devices",
                "Updating device specifications (e.g., RAM, OS version)",
                "Querying or reporting on device inventory",
                "Classifying devices by type or OS version",
                "Auditing or compliance checks on network hardware"
            ]
        },
        "networkdevicetype": {
            "business_purpose": "This table represents a catalog or list of network device types, serving as a reference or lookup for different categories or classifications of network devices within a business context.",
            "key_fields": [
                "id"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as the 'one' side in a relationship where multiple network devices reference a single device type.",
                "Lookup/reference: Other tables may use the 'id' as a foreign key to indicate the type of a network device."
            ],
            "business_operations": [
                "Defining and maintaining the set of valid network device types.",
                "Referencing device types when adding or managing network devices.",
                "Reporting or filtering network devices by type.",
                "Ensuring data consistency by restricting device type values to those defined in this table."
            ]
        },
        "organization": {
            "business_purpose": "The 'organization' table represents a hierarchical structure of organizational units, such as departments, branches, or business entities within a larger organization. It is designed to store information about each organizational unit, its status, hierarchical relationships, and associated delivery models. The table supports both simple parent-child relationships and more complex tree structures, likely for efficient querying of organizational hierarchies.",
            "key_fields": [
                "id",
                "name",
                "code",
                "status",
                "parent_id",
                "parent_id_left",
                "parent_id_right",
                "deliverymodel_id",
                "obsolescence_date"
            ],
            "potential_relationships": [
                "Self-referential hierarchy via 'parent_id' (an organization can be a parent of another organization)",
                "Nested set model relationships via 'parent_id_left' and 'parent_id_right' (for efficient tree traversal)",
                "Possible association with delivery models via 'deliverymodel_id' (linking to a delivery model entity, if it exists)"
            ],
            "business_operations": [
                "Creating, updating, or deactivating organizational units",
                "Managing organizational hierarchies (e.g., moving units within the hierarchy, querying sub-units)",
                "Tracking the status (active/inactive) and obsolescence of organizational units",
                "Associating organizational units with specific delivery models",
                "Reporting and analytics on organizational structure and lifecycle"
            ]
        },
        "osfamily": {
            "business_purpose": "The 'osfamily' table appears to represent a classification or grouping entity, likely used to categorize or identify different families or types of operating systems within a system. Its primary purpose is to provide a unique identifier for each OS family, which can be referenced elsewhere in the database.",
            "key_fields": [
                "id"
            ],
            "potential_relationships": [
                "One-to-many: Other tables may reference 'osfamily.id' as a foreign key to associate records with a specific OS family",
                "Many-to-many: It could serve as a join table in more complex relationships, though no such structure is present here"
            ],
            "business_operations": [
                "Creating new OS family entries",
                "Retrieving the list of OS families for selection or categorization",
                "Referencing OS family identifiers in related business processes or records"
            ]
        },
        "osversion": {
            "business_purpose": "The 'osversion' table appears to represent different versions of operating systems, with each record corresponding to a specific OS version. The presence of an 'osfamily_id' field suggests that each OS version can be associated with a broader OS family or group, though the details of that family are not defined in this table.",
            "key_fields": [
                "id",
                "osfamily_id"
            ],
            "potential_relationships": [
                "One-to-many: Each OS family (referenced by osfamily_id) could have multiple OS versions in this table.",
                "Many-to-one: Each OS version belongs to a single OS family (if osfamily_id refers to another table).",
                "Standalone: The table could also function independently, simply listing OS versions with optional grouping by family."
            ],
            "business_operations": [
                "Storing and retrieving information about available OS versions.",
                "Grouping or filtering OS versions by their family identifier.",
                "Associating other business data (such as software compatibility, device support, or licensing) with specific OS versions.",
                "Maintaining a catalog of supported or recognized OS versions for internal or external reference."
            ]
        },
        "person": {
            "business_purpose": "The 'person' table represents individuals within an organization or system, likely employees or members, capturing their personal details, contact information, and optionally their photograph. It is designed to store both identification and organizational hierarchy information.",
            "key_fields": [
                "id",
                "first_name",
                "employee_number",
                "mobile_phone",
                "picture_data",
                "location_id",
                "manager_id"
            ],
            "potential_relationships": [
                "Self-referential relationship via 'manager_id' to represent reporting or management hierarchy among persons",
                "Possible association with a 'location' entity via 'location_id' to indicate where a person is based"
            ],
            "business_operations": [
                "Storing and retrieving personal and contact information for individuals",
                "Managing organizational structure by assigning managers to persons",
                "Associating persons with specific locations",
                "Storing and displaying profile pictures for individuals",
                "Searching for persons by name or other attributes"
            ]
        },
        "physicaldevice": {
            "business_purpose": "The 'physicaldevice' table represents the inventory and lifecycle management of physical devices within an organization. It is designed to track individual devices by their unique identifiers, status, location, brand, model, and key lifecycle dates such as purchase and warranty end. This table is likely used to manage assets such as computers, servers, networking equipment, or other hardware.",
            "key_fields": [
                "id",
                "serialnumber",
                "location_id",
                "status",
                "brand_id",
                "model_id",
                "asset_number",
                "purchase_date",
                "end_of_warranty"
            ],
            "potential_relationships": [
                "Many-to-one relationship to a location entity (via location_id)",
                "Many-to-one relationship to a brand entity (via brand_id)",
                "Many-to-one relationship to a model entity (via model_id)",
                "Possible inheritance or classification relationship via finalclass"
            ],
            "business_operations": [
                "Registering new physical devices into inventory",
                "Tracking the current status and location of devices",
                "Managing device lifecycle events (e.g., purchase, warranty expiration, obsolescence)",
                "Auditing and reporting on asset inventory",
                "Searching for devices by serial number, asset number, or other attributes",
                "Updating device status (e.g., moving from stock to production, marking as obsolete)",
                "Associating devices with brands, models, and locations for organizational management"
            ]
        },
        "priv_action": {
            "business_purpose": "The 'priv_action' table appears to represent a catalog or registry of actions or operations that can be performed within a system, likely for the purpose of managing permissions, workflows, or system events. Each record defines a specific action, its description, operational status, and an associated class or type.",
            "key_fields": [
                "id",
                "name",
                "status",
                "realclass"
            ],
            "potential_relationships": [
                "Could serve as a reference table for logging or tracking actions performed in the system",
                "Might be linked to permission or role management tables to control access to specific actions",
                "Could be associated with workflow or process tables to define allowed or available actions"
            ],
            "business_operations": [
                "Defining and maintaining the list of available system actions",
                "Enabling or disabling specific actions based on business rules or system configuration",
                "Describing and categorizing actions for documentation or auditing purposes",
                "Filtering or selecting actions by status or type for administrative interfaces"
            ]
        },
        "priv_action_email": {
            "business_purpose": "The priv_action_email table represents the storage of email messages that are generated as part of a private or privileged action process within an application. It is designed to capture all relevant details of an outgoing email, including sender, recipients, subject, body, and importance, possibly for auditing, logging, or workflow automation purposes.",
            "key_fields": [
                "id",
                "test_recipient",
                "from",
                "from_label",
                "reply_to",
                "reply_to_label",
                "to",
                "cc",
                "bcc",
                "subject",
                "body",
                "importance"
            ],
            "potential_relationships": [
                "One-to-many: This table could be referenced by a parent entity representing an action, event, or process that triggers email notifications.",
                "Many-to-one: Multiple email records could be associated with a single action or process, if such an entity exists.",
                "Standalone: The table may also function independently as an audit log or queue for outgoing emails."
            ],
            "business_operations": [
                "Logging or archiving sent emails for compliance or auditing purposes",
                "Queuing emails to be sent as part of a workflow or automated process",
                "Testing email delivery using the test_recipient field",
                "Tracking the details and status of email communications related to privileged actions"
            ]
        },
        "priv_action_notification": {
            "business_purpose": "The 'priv_action_notification' table appears to represent a record of notifications related to specific actions or events within a system. The table is likely used to store instances where an action notification needs to be tracked, possibly for auditing, alerting, or workflow purposes. The presence of a 'realclass' field suggests support for polymorphism, allowing different types or subclasses of action notifications to be represented within the same table.",
            "key_fields": [
                "id",
                "realclass"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as a parent or child in a one-to-many relationship, where each notification might be linked to multiple related records in another table, or multiple notifications could be associated with a single entity elsewhere.",
                "Polymorphic: The 'realclass' field indicates the table may participate in polymorphic relationships, where different types of notifications (possibly defined in application code) are stored in the same table and distinguished by this field."
            ],
            "business_operations": [
                "Creating new action notification records when specific events or actions occur in the system.",
                "Querying or filtering notifications based on their type (using the 'realclass' field).",
                "Auditing or tracking the occurrence of certain actions for compliance or monitoring purposes.",
                "Extending notification types by leveraging the polymorphic 'realclass' field to support new notification subclasses."
            ]
        },
        "priv_app_preferences": {
            "business_purpose": "The 'priv_app_preferences' table is designed to store application-specific preference settings for individual users or entities, allowing the application to personalize or customize the user experience based on stored preferences.",
            "key_fields": [
                "id",
                "userid",
                "preferences"
            ],
            "potential_relationships": [
                "One-to-many: Each userid may have multiple preference records (if allowed by the application logic).",
                "Many-to-one: Multiple preference records may reference the same userid value.",
                "Standalone: The table can function independently to store preferences even if no explicit foreign key is defined."
            ],
            "business_operations": [
                "Storing user or entity-specific application preferences.",
                "Retrieving and applying preferences to customize the application interface or behavior.",
                "Updating preferences when users change their settings.",
                "Deleting preferences if a user or entity is removed or opts out."
            ]
        },
        "priv_change": {
            "business_purpose": "The 'priv_change' table is designed to log or track changes related to privileges or permissions within a system. Each record represents an event where a privilege change occurred, capturing details about when it happened, who was involved, and the method or origin of the change.",
            "key_fields": [
                "id",
                "date",
                "userinfo",
                "user_id",
                "origin"
            ],
            "potential_relationships": [
                "May serve as a log or audit trail for privilege changes, potentially referencing users or entities whose privileges are being changed (via 'user_id' or 'userinfo').",
                "Could be linked to processes or modules that trigger privilege changes, as indicated by the 'origin' field.",
                "Might be used in reporting or auditing contexts to analyze how and when privilege changes occur."
            ],
            "business_operations": [
                "Auditing and reviewing privilege or permission changes for compliance or security purposes.",
                "Tracking the source and method of privilege changes for troubleshooting or process improvement.",
                "Generating reports on privilege change activity over time.",
                "Investigating incidents by correlating privilege changes with other system events."
            ]
        },
        "priv_changeop": {
            "business_purpose": "The 'priv_changeop' table appears to log or track operations (actions or changes) performed on various objects within a system. Each record represents a specific operation (such as create, update, or delete) performed on an object, possibly as part of a broader change event or process. The table is likely used for auditing, change management, or tracking modifications to system entities for security, compliance, or operational purposes.",
            "key_fields": [
                "id",
                "changeid",
                "objclass",
                "objkey",
                "optype"
            ],
            "potential_relationships": [
                "Many-to-one: Multiple operation records (priv_changeop) may be associated with a single change event (via changeid).",
                "Polymorphic association: The combination of objclass and objkey allows this table to reference different types of objects in the system, supporting a flexible relationship to various entities.",
                "Index-based relationships: The presence of multiple indexes (MUL) on changeid, objclass, and optype suggests frequent querying or joining on these fields, possibly for reporting or filtering operations."
            ],
            "business_operations": [
                "Auditing changes made to system objects.",
                "Tracking the history of operations performed on various entities.",
                "Supporting change management workflows by recording each step or action taken.",
                "Generating reports on object modifications for compliance or review.",
                "Enabling rollback or review of changes by maintaining a log of operations."
            ]
        },
        "priv_changeop_create": {
            "business_purpose": "The 'priv_changeop_create' table appears to represent a record or log of a specific event or permission related to a 'change operation' creation. Given its minimal structure, it likely serves as a flag, marker, or registry for instances where a 'change operation' creation privilege or event needs to be tracked or referenced.",
            "key_fields": [
                "id"
            ],
            "potential_relationships": [
                "Could serve as a referenced table in a one-to-one or one-to-many relationship, where other tables might link to this table via the 'id' to indicate association with a 'change operation' creation privilege or event."
            ],
            "business_operations": [
                "Registering or logging the creation of a change operation privilege or event",
                "Referencing or validating the existence of a change operation creation record",
                "Auditing or tracking the creation of change operation privileges"
            ]
        },
        "priv_changeop_links": {
            "business_purpose": "The 'priv_changeop_links' table appears to serve as a linking or association table that tracks changes or operations performed on various items or entities within a system. It likely records the relationship between a change operation (possibly a configuration or attribute change) and the specific item (of a certain class and ID) that the operation affects. The table is designed to be generic, supporting multiple item types through the 'item_class' field.",
            "key_fields": [
                "id",
                "item_class",
                "item_id",
                "optype"
            ],
            "potential_relationships": [
                "Many-to-one: Multiple records in this table may reference the same item (by item_class and item_id), indicating multiple operations on a single item.",
                "Polymorphic association: The combination of 'item_class' and 'item_id' allows this table to link to different types of items/entities, supporting a flexible relationship model."
            ],
            "business_operations": [
                "Recording or auditing changes made to items/entities in the system.",
                "Querying the history of operations performed on a specific item or class of items.",
                "Supporting rollback or review processes by tracking which operations were applied to which items.",
                "Facilitating reporting or compliance checks on changes made within the system."
            ]
        },
        "priv_changeop_links_addremove": {
            "business_purpose": "This table appears to track the addition or removal of links or associations in a system, likely as part of a change operation or audit process. Each record logs an event where a link was either added or removed, possibly to maintain a history of changes for auditing, rollback, or synchronization purposes.",
            "key_fields": [
                "id",
                "type"
            ],
            "potential_relationships": [
                "Could serve as a child or detail table in a one-to-many relationship with a parent change operation or transaction table, where each change operation may have multiple link add/remove events.",
                "May be referenced by other tables that need to track or summarize link changes, such as a log or audit summary."
            ],
            "business_operations": [
                "Recording when a link or association is added or removed during a change operation.",
                "Auditing or reviewing the history of link changes for compliance or troubleshooting.",
                "Supporting rollback or undo functionality by tracking what links were added or removed in each operation."
            ]
        },
        "priv_changeop_links_tune": {
            "business_purpose": "This table appears to represent a mapping or linkage between change operations (possibly tracked elsewhere) and specific links or references, with a focus on tuning or customizing these relationships. The table likely serves as a junction or association table to record which links are associated with particular change operations, possibly for auditing, tracking, or configuration purposes.",
            "key_fields": [
                "id",
                "link_id"
            ],
            "potential_relationships": [
                "One-to-many: Each record has a unique id, suggesting each entry is distinct and could be referenced individually.",
                "Many-to-one: The link_id field may reference a link entity elsewhere, allowing multiple records in this table to point to the same link_id.",
                "Standalone: Without explicit foreign keys, the table may also serve as a simple log or registry of link associations."
            ],
            "business_operations": [
                "Recording or tracking the association between change operations and links.",
                "Querying which links are associated with specific change operations for reporting or auditing.",
                "Updating or tuning the associations between change operations and links as business requirements evolve.",
                "Deleting or archiving associations that are no longer relevant."
            ]
        },
        "priv_changeop_setatt": {
            "business_purpose": "This table appears to represent a configuration or mapping for change operations that set or modify specific attributes within a system. It likely defines which attributes (attcode) can be set or changed as part of a particular change operation type (optype), possibly for auditing, permissions, or workflow automation purposes.",
            "key_fields": [
                "id",
                "attcode",
                "optype"
            ],
            "potential_relationships": [
                "Could serve as a lookup or reference table for change operation processes",
                "Might be linked to logs or records of change events to specify which attributes were affected",
                "Could be referenced by workflow or automation rules to determine allowed or required attribute changes"
            ],
            "business_operations": [
                "Defining or updating which attributes can be modified during specific change operations",
                "Auditing or tracking attribute changes as part of change management processes",
                "Enforcing business rules or permissions regarding attribute modifications",
                "Configuring workflows that automate or restrict attribute changes based on operation type"
            ]
        },
        "priv_changeop_setatt_scalar": {
            "business_purpose": "This table appears to record changes to scalar (single-value) attributes, likely as part of an audit or change tracking process. Each record logs the previous value (oldvalue) and the updated value (newvalue) for a particular change operation, with a unique identifier (id) for each change event. The table is likely used to track modifications to data fields elsewhere in the system, providing a history of changes for auditing, rollback, or review purposes.",
            "key_fields": [
                "id",
                "oldvalue",
                "newvalue"
            ],
            "potential_relationships": [
                "Could serve as a detail or log table linked to a parent change operation or entity table via a foreign key (not present here)",
                "May be referenced by other tables that track change events or attribute modifications"
            ],
            "business_operations": [
                "Auditing changes to data attributes",
                "Tracking the history of modifications for compliance or troubleshooting",
                "Supporting rollback or undo operations by storing previous values",
                "Generating reports on attribute changes over time"
            ]
        },
        "priv_db_properties": {
            "business_purpose": "The 'priv_db_properties' table is designed to store configurable properties or settings for a private database or application context. Each record represents a named property, its value, a description, and metadata about when and why it was last changed. This structure is typically used for managing dynamic configuration parameters, feature flags, or system-level settings that may need to be updated without altering application code.",
            "key_fields": [
                "id",
                "name",
                "value",
                "change_date",
                "change_comment"
            ],
            "potential_relationships": [
                "Could serve as a lookup or reference table for application components that require configuration values",
                "May be referenced by logging or audit tables to track configuration changes",
                "Could be linked to modules or features within the application that depend on specific property values"
            ],
            "business_operations": [
                "Reading configuration or property values at application startup or runtime",
                "Updating property values to change system behavior or enable/disable features",
                "Auditing or reviewing changes to configuration via 'change_date' and 'change_comment'",
                "Displaying current configuration settings in an administrative interface"
            ]
        },
        "priv_extension_install": {
            "business_purpose": "The priv_extension_install table represents the record of software extensions (such as plugins, modules, or add-ons) that have been installed in a system. It tracks details about each installed extension, including its unique identifier, descriptive label, version, source, and the date/time it was installed. This table is likely used to manage, audit, or display information about installed extensions within an application or platform.",
            "key_fields": [
                "id",
                "code",
                "label",
                "version",
                "source",
                "installed"
            ],
            "potential_relationships": [
                "Could serve as a parent or reference table for extension-specific configuration, logs, or permissions",
                "Might be referenced by tables tracking extension usage, updates, or dependencies",
                "Could be related to tables that manage extension licensing or compatibility"
            ],
            "business_operations": [
                "Registering a new extension installation",
                "Querying installed extensions for display or management",
                "Auditing extension installation history",
                "Checking extension version or source for updates or support",
                "Uninstalling or updating extensions"
            ]
        },
        "priv_internaluser": {
            "business_purpose": "This table represents internal system users who may require password reset functionality. It is likely used to manage authentication and security for privileged or internal accounts within an application or organization.",
            "key_fields": [
                "id",
                "reset_pwd_token_hash",
                "reset_pwd_token_salt",
                "finalclass"
            ],
            "potential_relationships": [
                "Could serve as a parent or base table for different types of internal users, as suggested by the 'finalclass' field.",
                "May be referenced by audit, access control, or authentication-related tables to track user actions or permissions.",
                "Could be linked to password reset or security event logs."
            ],
            "business_operations": [
                "Managing internal user accounts.",
                "Handling password reset requests and storing secure reset tokens.",
                "Classifying or differentiating types of internal users for access control or business logic.",
                "Auditing or tracking internal user activities."
            ]
        },
        "priv_link_action_trigger": {
            "business_purpose": "This table appears to represent a linking or mapping entity that associates 'actions' with 'triggers', potentially in a system where certain actions are executed in response to specific triggers. The table allows for multiple actions to be linked to multiple triggers, possibly in a specific sequence, as indicated by the 'order' field. It is likely used to define or manage workflows, automation rules, or event-driven processes.",
            "key_fields": [
                "link_id",
                "action_id",
                "trigger_id",
                "order"
            ],
            "potential_relationships": [
                "Many-to-many relationship between actions and triggers, where each action can be associated with multiple triggers and vice versa",
                "The 'order' field suggests an ordered sequence of actions for a given trigger or vice versa"
            ],
            "business_operations": [
                "Defining which actions should be executed in response to specific triggers",
                "Managing or updating the sequence in which actions are performed when a trigger occurs",
                "Querying to determine what actions are linked to a given trigger or what triggers are associated with a given action",
                "Deleting or modifying action-trigger associations as business rules change"
            ]
        },
        "priv_module_install": {
            "business_purpose": "The 'priv_module_install' table is designed to track the installation of modules (likely software components, plugins, or features) within a system. Each record represents a specific module installation event, capturing details such as the module's name, version, installation timestamp, and any relevant comments. The presence of a 'parent_id' field suggests support for hierarchical or dependent module installations, where one module installation may be related to or dependent on another.",
            "key_fields": [
                "id",
                "name",
                "version",
                "installed",
                "parent_id"
            ],
            "potential_relationships": [
                "Self-referential (hierarchical) relationship via 'parent_id', allowing modules to be linked as parent and child installations",
                "Potential for one-to-many relationships within the same table (one parent module installation to many child installations)"
            ],
            "business_operations": [
                "Recording new module installations",
                "Tracking the version and installation date of modules",
                "Documenting dependencies or hierarchies between module installations",
                "Auditing or reviewing installation history and comments for troubleshooting or compliance",
                "Querying for installed modules by name, version, or parent-child relationships"
            ]
        },
        "priv_query": {
            "business_purpose": "The 'priv_query' table appears to represent a system for storing and managing saved queries, possibly for reporting, data retrieval, or reusable data access templates. The presence of fields like 'name', 'description', and 'is_template' suggests that users or processes can define, describe, and flag queries as templates for reuse. The 'realclass' field may support polymorphism or different query types within the system.",
            "key_fields": [
                "id",
                "name",
                "is_template",
                "realclass"
            ],
            "potential_relationships": [
                "One-to-many: This table could be referenced by other tables that store query results, query executions, or permissions for accessing queries.",
                "Inheritance/Polymorphic: The 'realclass' field suggests that this table might be used in a polymorphic relationship, where different types of queries or subclasses are stored in the same table."
            ],
            "business_operations": [
                "Creating and saving new queries for later use",
                "Defining and managing query templates for reuse",
                "Searching and retrieving queries by name or type",
                "Describing the purpose and details of each query",
                "Classifying queries by type or class for specialized processing"
            ]
        },
        "priv_query_oql": {
            "business_purpose": "The 'priv_query_oql' table is designed to store and manage custom queries written in OQL (Object Query Language) along with their associated fields. This table likely serves as a repository for saving, retrieving, and possibly executing dynamic or user-defined queries within an application that supports OQL-based data access or reporting.",
            "key_fields": [
                "id",
                "oql",
                "fields"
            ],
            "potential_relationships": [
                "Could serve as a reference for logs or audit tables that track query execution",
                "Might be linked to a permissions or access control system to restrict query usage",
                "Could be referenced by a scheduling or automation system to run saved queries at intervals"
            ],
            "business_operations": [
                "Saving new OQL queries for later use",
                "Retrieving and displaying stored queries for review or execution",
                "Editing or deleting existing queries",
                "Executing stored queries and processing their results",
                "Managing the fields associated with each query for reporting or data extraction purposes"
            ]
        },
        "priv_tagfielddata": {
            "business_purpose": "The 'priv_tagfielddata' table appears to represent metadata or configuration for tag fields that can be associated with various objects or entities within a system. It likely stores definitions for custom tagging fields, including their code, label, description, and the object class and attribute they are related to. This enables dynamic tagging or categorization functionality for different types of objects in the application.",
            "key_fields": [
                "id",
                "code",
                "label",
                "obj_class",
                "obj_attcode",
                "finalclass"
            ],
            "potential_relationships": [
                "Could be referenced by other tables that store actual tag values or assignments, using the 'id' as a foreign key.",
                "Might be used in a polymorphic relationship, where 'obj_class' and 'obj_attcode' indicate which object and attribute this tag field definition applies to.",
                "Could serve as a lookup or configuration table for dynamic forms or metadata management."
            ],
            "business_operations": [
                "Defining new tag fields for use in the system.",
                "Retrieving tag field definitions to render dynamic forms or tagging interfaces.",
                "Updating or managing the metadata (label, description) for existing tag fields.",
                "Filtering or searching for tag field definitions based on label, code, or object class.",
                "Supporting dynamic extension of data models by allowing administrators to add or modify tag fields without altering the core schema."
            ]
        },
        "priv_trigger": {
            "business_purpose": "The 'priv_trigger' table appears to represent a system for defining and managing triggers or events within an application. Each row likely corresponds to a specific trigger, which may be used to initiate automated actions or workflows based on certain conditions or contexts. The table is designed to store metadata about these triggers, such as their description, the context in which they operate, and their class/type.",
            "key_fields": [
                "id",
                "description",
                "context",
                "realclass"
            ],
            "potential_relationships": [
                "Could serve as a reference table for logging or tracking events triggered in the system",
                "Might be linked to tables that define actions, rules, or workflows that are activated by these triggers",
                "Could be used in a many-to-many relationship with other entities that require triggers to be associated with them (e.g., objects, processes, or modules within the application)"
            ],
            "business_operations": [
                "Defining new triggers for automated processes",
                "Querying triggers based on context or description for configuration or management purposes",
                "Updating trigger metadata to reflect changes in business logic",
                "Auditing or reviewing available triggers to ensure proper system behavior"
            ]
        },
        "priv_trigger_onobject": {
            "business_purpose": "The 'priv_trigger_onobject' table appears to represent a system for defining triggers or automated actions that are associated with specific object types (classes) within an application. Each row likely defines a trigger configuration, specifying the target object class, optional filtering criteria, and the real class of the trigger logic. This enables dynamic or configurable automation based on object types and conditions.",
            "key_fields": [
                "id",
                "target_class",
                "filter",
                "realclass"
            ],
            "potential_relationships": [
                "May reference or be referenced by tables that define object classes or entities (via 'target_class')",
                "Could be related to tables that store trigger execution logs or trigger definitions (via 'realclass')",
                "Might be used in conjunction with tables that store application objects to determine when triggers should fire"
            ],
            "business_operations": [
                "Configuring or managing automated triggers for specific object types",
                "Filtering or scoping triggers to only apply under certain conditions (using 'filter')",
                "Executing business logic when certain objects are created, updated, or deleted",
                "Auditing or reviewing which triggers are active for which object types"
            ]
        },
        "priv_trigger_onobjmention": {
            "business_purpose": "This table appears to represent a configuration or rule set for triggering certain actions or processes when specific objects are mentioned, based on a filter or criteria defined in the 'mentioned_filter' field. It likely supports a system where object mentions (possibly in text, logs, or events) need to be detected and acted upon according to customizable filters.",
            "key_fields": [
                "id",
                "mentioned_filter"
            ],
            "potential_relationships": [
                "Could serve as a reference for event or action tables that log or process object mentions",
                "Might be linked to a system that processes or monitors object mentions, acting as a trigger configuration table"
            ],
            "business_operations": [
                "Creating, updating, or deleting mention trigger rules",
                "Retrieving filters to determine if an object mention should trigger an action",
                "Auditing or reviewing the set of active mention-based triggers"
            ]
        },
        "priv_urp_profiles": {
            "business_purpose": "The 'priv_urp_profiles' table represents a collection of profiles, each identified by a unique ID, with a name and an optional description. The naming suggests these profiles are related to privileges or roles, possibly used for grouping permissions, access levels, or user roles within a system. However, based solely on the structure, it is a generic profile table for storing named entities with descriptions.",
            "key_fields": [
                "id",
                "name",
                "description"
            ],
            "potential_relationships": [
                "One-to-many: Other tables may reference the 'id' field as a foreign key to associate records with a specific profile.",
                "Many-to-many: This table could participate in a join table to link profiles with other entities (e.g., privileges, resources, or assignments)."
            ],
            "business_operations": [
                "Creating new profiles (insert operations)",
                "Updating profile names or descriptions (update operations)",
                "Retrieving lists of profiles for display or selection (select operations)",
                "Deleting profiles (delete operations), subject to business rules"
            ]
        },
        "priv_urp_userprofile": {
            "business_purpose": "The priv_urp_userprofile table appears to represent the association between two entities: 'userid' and 'profileid'. It likely serves as a mapping or linking table to connect users (or user-like entities) with profiles (or profile-like entities), possibly to manage permissions, roles, or user settings. The optional 'description' field allows for additional context or notes about each association.",
            "key_fields": [
                "id",
                "userid",
                "profileid"
            ],
            "potential_relationships": [
                "Many-to-many relationship between entities represented by 'userid' and 'profileid', with this table acting as the join table.",
                "One-to-many relationship from this table to the entities referenced by 'userid' and 'profileid' (each row links one userid to one profileid)."
            ],
            "business_operations": [
                "Assigning a profile to a user or entity (creating a new association).",
                "Removing a profile from a user or entity (deleting an association).",
                "Querying which profiles are associated with a given user or entity.",
                "Querying which users or entities are associated with a given profile.",
                "Updating the description or metadata about a specific user-profile association."
            ]
        },
        "priv_user": {
            "business_purpose": "The 'priv_user' table represents a system for managing privileged users or user accounts within an application. It is designed to store information about users who have access to a system, including their login credentials, language preferences, account status, and a reference to a contact entity. The table supports user management, authentication, and possibly role or class-based distinctions among users.",
            "key_fields": [
                "id",
                "contactid",
                "login",
                "language",
                "status",
                "finalclass"
            ],
            "potential_relationships": [
                "May reference a contact entity via 'contactid' (suggesting a possible link to contact information stored elsewhere)",
                "Could be related to authentication or authorization modules through the 'login' and 'status' fields",
                "The 'finalclass' field may indicate inheritance or user type, suggesting relationships with other user subtypes or roles"
            ],
            "business_operations": [
                "User account creation, modification, and deletion",
                "User authentication and login processes",
                "Enabling or disabling user access (status management)",
                "Managing user language preferences for localization",
                "Assigning or identifying user types or roles via 'finalclass'"
            ]
        },
        "priv_user_local": {
            "business_purpose": "The 'priv_user_local' table is designed to manage local user authentication credentials and password policies. It stores password hashes, salts, and information about password expiration and renewal, supporting secure authentication and password lifecycle management for users within a system.",
            "key_fields": [
                "id",
                "password_hash",
                "password_salt",
                "expiration",
                "password_renewed_date"
            ],
            "potential_relationships": [
                "One-to-one or one-to-many relationships with entities representing users or accounts, where this table holds authentication details for each user or account",
                "Could serve as a child or extension table for a broader user or identity management system, storing sensitive credential data separately"
            ],
            "business_operations": [
                "User login and authentication processes, where password verification is required",
                "Password reset and renewal workflows, updating password_hash, password_salt, and password_renewed_date",
                "Enforcing password expiration policies based on the 'expiration' field",
                "Auditing or compliance checks related to password management and security"
            ]
        },
        "rack": {
            "business_purpose": "The 'rack' table represents a physical or logical storage unit, likely used to organize or house items, equipment, or components. The presence of the 'nb_u' field suggests it tracks the number of units (possibly rack units, a standard measurement in equipment racking), indicating its use in environments such as data centers, warehouses, or inventory management systems.",
            "key_fields": [
                "id",
                "nb_u"
            ],
            "potential_relationships": [
                "One-to-many: Other tables might reference the 'rack' table to associate items, equipment, or assets with a specific rack.",
                "One-to-one: A rack might be uniquely associated with a specific location or asset in another table.",
                "Many-to-many: Racks could be linked to multiple entities through a junction table, such as shared resources or grouped assets."
            ],
            "business_operations": [
                "Tracking and managing the inventory or capacity of racks.",
                "Allocating or assigning items or equipment to specific racks.",
                "Monitoring available space or utilization within racks.",
                "Reporting on rack usage, capacity planning, or maintenance."
            ]
        },
        "remoteapplicationtype": {
            "business_purpose": "The 'remoteapplicationtype' table appears to represent a classification or type entity for remote applications. Its primary purpose is likely to serve as a reference or lookup table that enumerates different types of remote applications, each uniquely identified by an auto-incrementing integer ID.",
            "key_fields": [
                "id"
            ],
            "potential_relationships": [
                "One-to-many: This table could be referenced by other tables that need to associate records with a specific remote application type via a foreign key relationship.",
                "Many-to-many: It could also participate in a join table to associate multiple remote application types with other entities."
            ],
            "business_operations": [
                "Inserting new remote application types as the business expands or changes.",
                "Querying to retrieve the list of available remote application types.",
                "Referencing the type ID when categorizing or filtering remote applications in other business processes.",
                "Maintaining or auditing the list of remote application types for consistency and accuracy."
            ]
        },
        "server": {
            "business_purpose": "The 'server' table represents a record of individual servers within an IT infrastructure or data center. Each row stores information about a specific server, including its operating system family, version, license, CPU, and RAM configuration. This table is likely used to inventory, track, and manage server assets and their technical specifications.",
            "key_fields": [
                "id",
                "osfamily_id",
                "osversion_id",
                "oslicence_id",
                "cpu",
                "ram"
            ],
            "potential_relationships": [
                "Many-to-one relationships to reference tables for operating system family, version, and license (as indicated by osfamily_id, osversion_id, oslicence_id).",
                "Possible one-to-many relationship from this table to other tables that might track server usage, maintenance, or deployment, though such tables are not present in the provided schema."
            ],
            "business_operations": [
                "Asset inventory and management of servers",
                "Tracking and reporting on server hardware and software configurations",
                "Auditing server operating system licenses and compliance",
                "Planning for upgrades or capacity based on CPU and RAM specifications",
                "Filtering or searching for servers by OS family, version, or license"
            ]
        },
        "service": {
            "business_purpose": "The 'service' table represents a catalog or registry of services offered or managed by an organization. Each record describes a distinct service, including its name, organizational association, service family grouping, descriptive details, operational status, and optional iconographic representation.",
            "key_fields": [
                "id",
                "name",
                "org_id",
                "servicefamily_id",
                "description",
                "status"
            ],
            "potential_relationships": [
                "Belongs-to relationship with an organization entity (via org_id)",
                "Belongs-to relationship with a service family or grouping entity (via servicefamily_id)",
                "May be referenced by other tables that track usage, deployment, or configuration of services"
            ],
            "business_operations": [
                "Registering new services",
                "Updating service details and status (e.g., moving from implementation to production)",
                "Listing or searching available services",
                "Grouping services by organization or service family",
                "Displaying service information, including icons, in user interfaces",
                "Archiving or marking services as obsolete"
            ]
        },
        "servicefamily": {
            "business_purpose": "The 'servicefamily' table represents a classification or grouping of services within a business context. Each record defines a distinct 'service family', likely used to organize or categorize individual services under broader headings. The inclusion of icon data suggests these groupings are visually represented, possibly in a user interface or catalog.",
            "key_fields": [
                "id",
                "name",
                "icon_data",
                "icon_mimetype",
                "icon_filename"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as a parent entity for a set of services, where each service belongs to a single service family.",
                "Reference: Other tables might reference 'servicefamily.id' to indicate the family or category a record belongs to."
            ],
            "business_operations": [
                "Creating, updating, or deleting service family records to manage service groupings.",
                "Displaying lists of service families, including their names and associated icons, in user interfaces.",
                "Assigning or reassigning services to a particular service family.",
                "Searching or filtering services by their family/grouping."
            ]
        },
        "servicesubcategory": {
            "business_purpose": "The 'servicesubcategory' table represents a classification of subcategories under a broader service offering. It is designed to organize and describe specific types of service requests or incidents that fall under a parent service, allowing for more granular management, tracking, and reporting of service-related activities within an organization.",
            "key_fields": [
                "id",
                "name",
                "service_id",
                "request_type",
                "status"
            ],
            "potential_relationships": [
                "Many-to-one relationship to a parent 'service' entity via 'service_id' (each subcategory belongs to one service)",
                "One-to-many relationship from this table to other entities that may reference a service subcategory (e.g., service requests, incidents, or tickets, if such tables exist)"
            ],
            "business_operations": [
                "Defining and maintaining the catalog of service subcategories",
                "Associating subcategories with parent services for organizational purposes",
                "Classifying and routing incoming requests or incidents based on subcategory",
                "Filtering or reporting on service subcategories by status (e.g., implementation, obsolete, production)",
                "Supporting workflows that distinguish between different request types (incident vs. service_request)"
            ]
        },
        "sla": {
            "business_purpose": "The 'sla' table represents Service Level Agreements (SLAs) within an organization or system. Each record defines a specific SLA, which may include a name, description, and an association with an organization (via org_id). This table is likely used to manage and track different SLAs that apply to various organizational units or services.",
            "key_fields": [
                "id",
                "name",
                "org_id"
            ],
            "potential_relationships": [
                "One-to-many: An organization (referenced by org_id) may have multiple SLAs.",
                "One-to-one or many-to-one: Each SLA may be associated with a single organization (org_id).",
                "Potential lookup or reference: Other tables may reference the SLA by its id to enforce or track compliance with specific agreements."
            ],
            "business_operations": [
                "Creating new SLAs for organizations or services.",
                "Retrieving and displaying SLA details for reporting or compliance purposes.",
                "Updating SLA information as agreements change.",
                "Associating SLAs with organizational processes or entities.",
                "Auditing or reviewing SLAs for quality assurance or contractual obligations."
            ]
        },
        "slt": {
            "business_purpose": "The 'slt' table represents Service Level Targets (SLTs), which define specific performance or response metrics for handling requests, such as incidents or service requests. Each record specifies a target metric (e.g., time to own, time to resolve) for a given priority and request type, along with the expected value and unit of measurement. This table is likely used to enforce or track service level agreements (SLAs) within a business process.",
            "key_fields": [
                "id",
                "name",
                "priority",
                "request_type",
                "metric",
                "value",
                "unit"
            ],
            "potential_relationships": [
                "Could be referenced by request or ticket tables to determine applicable SLT for a given request",
                "Might be linked to reporting or monitoring tables to track compliance with SLTs",
                "Could serve as a lookup or configuration table for workflow engines or automation rules"
            ],
            "business_operations": [
                "Defining and maintaining service level targets for different types of requests and priorities",
                "Determining the expected response or resolution time for incoming requests",
                "Auditing and reporting on compliance with service level targets",
                "Configuring automated escalations or notifications based on SLT breaches"
            ]
        },
        "software": {
            "business_purpose": "The 'software' table represents a catalog or registry of software products or components, capturing key identifying and classification information about each software item. It is likely used to track, manage, or reference software assets within an organization or system.",
            "key_fields": [
                "id",
                "name",
                "version",
                "type"
            ],
            "potential_relationships": [
                "Could serve as a reference table for linking software assets to other entities such as installations, licenses, or inventory records",
                "May be used in a one-to-many relationship where each software entry is associated with multiple deployment or usage records",
                "Could be referenced in audit or compliance tracking tables to indicate which software is involved"
            ],
            "business_operations": [
                "Registering new software products or versions",
                "Querying or reporting on available software by name, vendor, version, or type",
                "Classifying software for inventory, compliance, or asset management purposes",
                "Supporting software selection or compatibility checks based on type or vendor"
            ]
        },
        "softwareinstance": {
            "business_purpose": "The 'softwareinstance' table represents individual deployments or installations of software within an organization. Each record tracks a specific instance of a software product, potentially linked to a configuration item, a software definition, and a software license. This enables management and tracking of where and how software is installed and used.",
            "key_fields": [
                "id",
                "functionalci_id",
                "software_id",
                "softwarelicence_id",
                "path",
                "status",
                "finalclass"
            ],
            "potential_relationships": [
                "Many-to-one relationship to a configuration item (via functionalci_id), representing the asset or environment where the software is installed.",
                "Many-to-one relationship to a software definition (via software_id), representing the specific software product or version.",
                "Many-to-one relationship to a software license (via softwarelicence_id), representing the license governing this instance.",
                "Possible inheritance or polymorphic relationship indicated by the 'finalclass' field, allowing for different types of software instances."
            ],
            "business_operations": [
                "Tracking and inventory of software installations across assets or environments.",
                "Auditing software license usage and compliance.",
                "Monitoring software deployment status (active/inactive).",
                "Managing software lifecycle, including installation, updates, and decommissioning.",
                "Reporting on software usage and distribution within the organization."
            ]
        },
        "team": {
            "business_purpose": "The 'team' table represents a unique collection of teams within a business context. Each record corresponds to a distinct team entity, likely used to organize people, projects, or resources into groups for management or operational purposes.",
            "key_fields": [
                "id"
            ],
            "potential_relationships": [
                "One-to-many: Other tables may reference the 'team' table via the 'id' field to associate records with a specific team.",
                "Many-to-many: The 'team' table could participate in join tables to represent relationships between teams and other entities (e.g., projects, events), though such relationships are not defined here."
            ],
            "business_operations": [
                "Creating new teams (inserting new records).",
                "Retrieving a list of teams (selecting records).",
                "Updating team identifiers (rare, as 'id' is auto-incremented and primary).",
                "Deleting teams (removing records, possibly with cascading effects elsewhere)."
            ]
        },
        "typology": {
            "business_purpose": "The 'typology' table is designed to store and manage different types or classifications relevant to a business domain. It acts as a reference or lookup table for various typologies, which could be used to categorize or group other entities or records within a system. The presence of a 'finalclass' field suggests support for inheritance or polymorphism, allowing for different subtypes or specialized typologies to be represented.",
            "key_fields": [
                "id",
                "name",
                "finalclass"
            ],
            "potential_relationships": [
                "One-to-many: Other tables may reference the 'typology' table via a foreign key to associate records with a specific typology.",
                "Polymorphic: The 'finalclass' field may enable polymorphic associations, where different subtypes of typologies are handled within the same table."
            ],
            "business_operations": [
                "Defining and maintaining the list of available typologies or classifications.",
                "Retrieving typology information for use in categorizing or filtering other business data.",
                "Supporting dynamic or extensible classification schemes through the 'finalclass' field.",
                "Reporting or analytics based on typology groupings."
            ]
        },
        "virtualdevice": {
            "business_purpose": "The 'virtualdevice' table represents a catalog or registry of virtual devices within an organization or system. Each record corresponds to a unique virtual device, tracking its lifecycle status (such as whether it is in production, being implemented, obsolete, or in stock) and its specific class or type. This table is likely used to manage and monitor virtual assets, possibly for IT infrastructure, cloud environments, or virtualized hardware/software resources.",
            "key_fields": [
                "id",
                "status",
                "finalclass"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as a parent in relationships where each virtual device has associated configurations, logs, or assignments.",
                "Inheritance/Polymorphism: The 'finalclass' field suggests support for multiple subtypes or specialized virtual device records, possibly using single-table inheritance or class-based differentiation."
            ],
            "business_operations": [
                "Registering new virtual devices (creation of records)",
                "Updating the status of virtual devices as they move through their lifecycle",
                "Querying and reporting on the inventory of virtual devices by status or class",
                "Auditing or tracking changes to virtual device records",
                "Managing the transition of devices between statuses (e.g., from 'implementation' to 'production' or to 'obsolete')"
            ]
        },
        "virtualhost": {
            "business_purpose": "The 'virtualhost' table appears to represent a business entity related to the configuration or management of virtual hosts, likely in a web hosting or application deployment context. Each record uniquely identifies a virtual host instance, possibly supporting polymorphic behavior or inheritance through the 'finalclass' field.",
            "key_fields": [
                "id",
                "finalclass"
            ],
            "potential_relationships": [
                "One-to-many: This table could serve as a parent or base entity for more specific virtual host types, with other tables referencing its 'id' as a foreign key.",
                "Polymorphic: The 'finalclass' field suggests the table may be used in an inheritance or polymorphic association pattern, where different subclasses or types of virtual hosts are distinguished by this field."
            ],
            "business_operations": [
                "Creating new virtual host records (provisioning virtual hosts)",
                "Querying or listing virtual hosts for management or monitoring",
                "Updating the type or class of a virtual host (possibly changing its behavior or configuration)",
                "Deleting virtual host records when decommissioning resources"
            ]
        },
        "virtualmachine": {
            "business_purpose": "The 'virtualmachine' table represents individual virtual machine instances within an IT infrastructure. Each record stores configuration and identification details for a virtual machine, such as its host, operating system, licensing, hardware specifications, and management IP address. This table is likely used to inventory, manage, and track virtual machines in a data center or cloud environment.",
            "key_fields": [
                "id",
                "virtualhost_id",
                "osfamily_id",
                "osversion_id",
                "oslicence_id",
                "cpu",
                "ram",
                "managementip"
            ],
            "potential_relationships": [
                "Many-to-one relationship to a virtual host entity (via virtualhost_id), indicating which host the VM resides on.",
                "Many-to-one relationship to an operating system family entity (via osfamily_id), specifying the OS type.",
                "Many-to-one relationship to an operating system version entity (via osversion_id), specifying the OS version.",
                "Many-to-one relationship to an OS license entity (via oslicence_id), specifying the license used by the VM."
            ],
            "business_operations": [
                "Provisioning new virtual machines with specific configurations.",
                "Updating or modifying virtual machine details (e.g., hardware specs, OS version).",
                "Tracking and reporting on virtual machine inventory.",
                "Auditing virtual machine compliance (e.g., OS licensing, resource allocation).",
                "Managing virtual machine lifecycle (creation, modification, decommissioning)."
            ]
        },
        "webapplication": {
            "business_purpose": "The 'webapplication' table represents individual web applications, each identified by a unique ID. It stores the URL of the web application and optionally associates it with a web server via the 'webserver_id' field. This table is likely used to catalog or manage web applications within an organization or system.",
            "key_fields": [
                "id",
                "webserver_id",
                "url"
            ],
            "potential_relationships": [
                "'webserver_id' suggests a possible many-to-one relationship with another table (not provided) that would represent web servers. Each web application may be linked to a web server, but this is optional (nullable)."
            ],
            "business_operations": [
                "Registering new web applications",
                "Updating the URL or server association of existing web applications",
                "Querying for web applications by ID, URL, or associated web server",
                "Auditing or reporting on web applications and their deployment locations"
            ]
        },
        "webserver": {
            "business_purpose": "The 'webserver' table represents a unique identifier for web server entities within a system. Its primary purpose is to serve as a registry or reference for individual web server instances, likely to be used as a foundational element for tracking, managing, or associating web server-specific data elsewhere in the database.",
            "key_fields": [
                "id"
            ],
            "potential_relationships": [
                "One-to-many (as a parent to other tables referencing web servers)",
                "One-to-one (as a unique reference for a web server's configuration or status)",
                "Many-to-many (if used in a join table to associate web servers with other entities)"
            ],
            "business_operations": [
                "Registering a new web server in the system",
                "Referencing a specific web server in logs, configurations, or monitoring data",
                "Tracking the existence or count of web servers",
                "Serving as a foreign key in other tables to associate data with a specific web server"
            ]
        }
    },
    "relationships": [
        {
            "type": "inferred",
            "from_table": "applicationsolution",
            "from_column": "id",
            "to_table": "lnkapplicationsolutiontofunctionalci",
            "to_column": "applicationsolution_id",
            "condition": "applicationsolution.id = lnkapplicationsolutiontofunctionalci.applicationsolution_id",
            "confidence": "high",
            "reasoning": "The field 'applicationsolution_id' in 'lnkapplicationsolutiontofunctionalci' is clearly named to reference the 'id' field in 'applicationsolution'. This follows standard database design patterns for many-to-many relationships, where a junction table (lnkapplicationsolutiontofunctionalci) links records from a parent table (applicationsolution) via a foreign key. The data types (both int) are compatible, and the business logic aligns with mapping application solutions to other entities.",
            "test_sql": "SELECT COUNT(*) FROM applicationsolution t1 JOIN lnkapplicationsolutiontofunctionalci t2 ON t1.id = t2.applicationsolution_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "brand",
            "from_column": "id",
            "to_table": "model",
            "to_column": "brand_id",
            "condition": "brand.id = model.brand_id",
            "confidence": "high",
            "reasoning": "The 'model' table contains a 'brand_id' column of type int, which matches the primary key 'id' in the 'brand' table. The naming convention and data types strongly suggest that 'brand_id' is intended to reference 'brand.id', establishing a one-to-many relationship where each model belongs to a single brand. This is a common database design pattern for associating models with their respective brands.",
            "test_sql": "SELECT COUNT(*) FROM brand t1 JOIN model t2 ON t1.id = t2.brand_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "brand",
            "from_column": "id",
            "to_table": "physicaldevice",
            "to_column": "brand_id",
            "condition": "brand.id = physicaldevice.brand_id",
            "confidence": "high",
            "reasoning": "The 'physicaldevice' table contains a 'brand_id' column of type int, which matches the primary key 'id' in the 'brand' table. The naming convention and data type compatibility strongly suggest that 'brand_id' in 'physicaldevice' is intended to reference 'id' in 'brand', establishing a many-to-one relationship where each physical device is associated with a single brand. This is a common database design pattern for associating assets with their manufacturer or brand.",
            "test_sql": "SELECT COUNT(*) FROM brand t1 JOIN physicaldevice t2 ON t1.id = t2.brand_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contact",
            "from_column": "id",
            "to_table": "lnkdeliverymodeltocontact",
            "to_column": "contact_id",
            "condition": "contact.id = lnkdeliverymodeltocontact.contact_id",
            "confidence": "high",
            "reasoning": "The 'lnkdeliverymodeltocontact' table contains a 'contact_id' field, which by naming convention and data type (int) matches the primary key 'id' in the 'contact' table. This is a classic pattern for a many-to-many relationship link table, where 'contact_id' references the 'contact' table. The business purpose of associating contacts with delivery models further supports this relationship.",
            "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN lnkdeliverymodeltocontact t2 ON t1.id = t2.contact_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contact",
            "from_column": "id",
            "to_table": "lnkpersontoteam",
            "to_column": "person_id",
            "condition": "contact.id = lnkpersontoteam.person_id",
            "confidence": "high",
            "reasoning": "The 'lnkpersontoteam' table is designed to link persons to teams, and the field 'person_id' is likely intended to reference a unique identifier for a person. In the provided schemas, the 'contact' table represents individual people and has a primary key 'id'. The data types (both int) and business logic (contacts as persons) strongly suggest that 'lnkpersontoteam.person_id' refers to 'contact.id'. This is a common database pattern for many-to-many relationships between people and teams.",
            "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN lnkpersontoteam t2 ON t1.id = t2.person_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contact",
            "from_column": "org_id",
            "to_table": "organization",
            "to_column": "id",
            "condition": "contact.org_id = organization.id",
            "confidence": "high",
            "reasoning": "The 'org_id' field in the 'contact' table is an integer and is named in a way that strongly suggests it references the 'id' field of the 'organization' table. This is a common pattern in database design for establishing a many-to-one relationship, where multiple contacts can be associated with a single organization. The business purposes of both tables also align: contacts are likely to belong to organizations.",
            "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN organization t2 ON t1.org_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 37,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contact",
            "from_column": "id",
            "to_table": "priv_user",
            "to_column": "contactid",
            "condition": "contact.id = priv_user.contactid",
            "confidence": "high",
            "reasoning": "The 'priv_user' table contains a 'contactid' field of type int, which matches the primary key 'id' in the 'contact' table. The naming convention and data type strongly suggest that 'contactid' is intended to reference a contact record, establishing a link between a user account and its associated contact information. This is a common pattern in database design, where user accounts are linked to contact/person records.",
            "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN priv_user t2 ON t1.id = t2.contactid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contract",
            "from_column": "id",
            "to_table": "lnkcustomercontracttoservice",
            "to_column": "customercontract_id",
            "condition": "contract.id = lnkcustomercontracttoservice.customercontract_id",
            "confidence": "high",
            "reasoning": "The field 'customercontract_id' in 'lnkcustomercontracttoservice' is an integer and appears to reference the primary key 'id' of the 'contract' table. The business purpose of 'lnkcustomercontracttoservice' is to link customer contracts to services, and the naming convention strongly suggests that 'customercontract_id' refers to a contract record. This is a common database design pattern for many-to-many relationships, where a junction table references the primary key of the main entity table.",
            "test_sql": "SELECT COUNT(*) FROM contract t1 JOIN lnkcustomercontracttoservice t2 ON t1.id = t2.customercontract_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contract",
            "from_column": "org_id",
            "to_table": "organization",
            "to_column": "id",
            "condition": "contract.org_id = organization.id",
            "confidence": "high",
            "reasoning": "The 'org_id' field in the 'contract' table is an integer and its naming convention strongly suggests it references the 'id' field in the 'organization' table. This is a common foreign key pattern where contracts are associated with the organization they belong to. The business purpose of both tables supports this: contracts are typically managed by or for specific organizational units.",
            "test_sql": "SELECT COUNT(*) FROM contract t1 JOIN organization t2 ON t1.org_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "customercontract",
            "from_column": "id",
            "to_table": "lnkcustomercontracttoservice",
            "to_column": "customercontract_id",
            "condition": "customercontract.id = lnkcustomercontracttoservice.customercontract_id",
            "confidence": "high",
            "reasoning": "The field 'customercontract_id' in 'lnkcustomercontracttoservice' matches the primary key 'id' in 'customercontract' by naming convention and data type (both int). The business purpose of 'lnkcustomercontracttoservice' is to link contracts to services, so it is logical that each record references a contract via this field. This is a standard foreign key pattern, even though the foreign key is not explicitly defined in the schema.",
            "test_sql": "SELECT COUNT(*) FROM customercontract t1 JOIN lnkcustomercontracttoservice t2 ON t1.id = t2.customercontract_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "databaseschema",
            "from_column": "dbserver_id",
            "to_table": "dbserver",
            "to_column": "id",
            "condition": "databaseschema.dbserver_id = dbserver.id",
            "confidence": "high",
            "reasoning": "The 'dbserver_id' column in 'databaseschema' is an integer field with a 'MUL' (multiple) key, which typically indicates it is used as a foreign key. Its name and type match the primary key 'id' in 'dbserver'. The business logic also supports this: each schema is associated with a database server, and the relationship is one-to-many (one dbserver to many schemas). This is a standard foreign key pattern in database design.",
            "test_sql": "SELECT COUNT(*) FROM databaseschema t1 JOIN dbserver t2 ON t1.dbserver_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "deliverymodel",
            "from_column": "id",
            "to_table": "lnkdeliverymodeltocontact",
            "to_column": "deliverymodel_id",
            "condition": "deliverymodel.id = lnkdeliverymodeltocontact.deliverymodel_id",
            "confidence": "high",
            "reasoning": "The field 'deliverymodel_id' in 'lnkdeliverymodeltocontact' matches the primary key 'id' in 'deliverymodel' by both naming convention and data type (int). The business purpose of 'lnkdeliverymodeltocontact' is to link contacts to delivery models, which strongly suggests that 'deliverymodel_id' is a reference to 'deliverymodel.id'. This is a standard many-to-many linking pattern.",
            "test_sql": "SELECT COUNT(*) FROM deliverymodel t1 JOIN lnkdeliverymodeltocontact t2 ON t1.id = t2.deliverymodel_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "deliverymodel",
            "from_column": "id",
            "to_table": "organization",
            "to_column": "deliverymodel_id",
            "condition": "deliverymodel.id = organization.deliverymodel_id",
            "confidence": "high",
            "reasoning": "The 'organization' table contains a 'deliverymodel_id' column, which matches the primary key 'id' of the 'deliverymodel' table. This is a common foreign key pattern, suggesting that each organization can be associated with a specific delivery model. The data types are compatible (both int), and the business logic supports organizations being linked to delivery models.",
            "test_sql": "SELECT COUNT(*) FROM deliverymodel t1 JOIN organization t2 ON t1.id = t2.deliverymodel_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "farm",
            "from_column": "id",
            "to_table": "hypervisor",
            "to_column": "farm_id",
            "condition": "farm.id = hypervisor.farm_id",
            "confidence": "high",
            "reasoning": "The 'hypervisor' table contains a 'farm_id' column of type int, which matches the primary key 'id' in the 'farm' table. The naming convention and data type compatibility strongly suggest that 'farm_id' in 'hypervisor' is intended to reference 'id' in 'farm', establishing a many-to-one relationship where each hypervisor is associated with a single farm. This is a common database design pattern for representing parent-child relationships.",
            "test_sql": "SELECT COUNT(*) FROM farm t1 JOIN hypervisor t2 ON t1.id = t2.farm_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "functionalci",
            "from_column": "id",
            "to_table": "lnkapplicationsolutiontofunctionalci",
            "to_column": "functionalci_id",
            "condition": "functionalci.id = lnkapplicationsolutiontofunctionalci.functionalci_id",
            "confidence": "high",
            "reasoning": "The 'lnkapplicationsolutiontofunctionalci' table is a classic junction/bridge table designed to map application solutions to functional configuration items. The field 'functionalci_id' in the link table is clearly intended to reference the primary key 'id' of the 'functionalci' table. This is a standard many-to-many relationship pattern in relational database design.",
            "test_sql": "SELECT COUNT(*) FROM functionalci t1 JOIN lnkapplicationsolutiontofunctionalci t2 ON t1.id = t2.functionalci_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "functionalci",
            "from_column": "org_id",
            "to_table": "organization",
            "to_column": "id",
            "condition": "functionalci.org_id = organization.id",
            "confidence": "high",
            "reasoning": "The 'org_id' field in 'functionalci' is an integer and is indexed (MUL), matching the primary key 'id' in 'organization'. The business purpose of 'functionalci' is to track configuration items belonging to an organization, and 'org_id' clearly references the owning or responsible organization. This is a standard foreign key pattern, even though the constraint is not explicitly defined.",
            "test_sql": "SELECT COUNT(*) FROM functionalci t1 JOIN organization t2 ON t1.org_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 31,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "functionalci",
            "from_column": "id",
            "to_table": "softwareinstance",
            "to_column": "functionalci_id",
            "condition": "functionalci.id = softwareinstance.functionalci_id",
            "confidence": "high",
            "reasoning": "The 'softwareinstance' table contains a column named 'functionalci_id' of type int, which matches the primary key 'id' in the 'functionalci' table. The naming convention and data types strongly suggest that each software instance is associated with a specific functional configuration item, likely representing the asset or environment where the software is installed. This is a common foreign key pattern in configuration management and asset tracking systems.",
            "test_sql": "SELECT COUNT(*) FROM functionalci t1 JOIN softwareinstance t2 ON t1.id = t2.functionalci_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "hypervisor",
            "from_column": "server_id",
            "to_table": "server",
            "to_column": "id",
            "condition": "hypervisor.server_id = server.id",
            "confidence": "high",
            "reasoning": "The 'hypervisor' table contains a 'server_id' column of type int, which matches the primary key 'id' in the 'server' table. This strongly suggests that each hypervisor record is associated with a specific server, likely representing the physical or virtual machine hosting the hypervisor. This is a common pattern in infrastructure management databases, where a hypervisor is mapped to the server it runs on.",
            "test_sql": "SELECT COUNT(*) FROM hypervisor t1 JOIN server t2 ON t1.server_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "lnkcustomercontracttoservice",
            "from_column": "sla_id",
            "to_table": "lnkslatoslt",
            "to_column": "sla_id",
            "condition": "lnkcustomercontracttoservice.sla_id = lnkslatoslt.sla_id",
            "confidence": "high",
            "reasoning": "Both tables contain a column named 'sla_id' of the same data type (int), and both schemas and business purposes reference 'SLA' as a key entity. In lnkcustomercontracttoservice, 'sla_id' links a contract-service association to an SLA, while in lnkslatoslt, 'sla_id' links to SLT records. This suggests a logical relationship where you may want to find all SLT records associated with the SLA assigned to a contract-service pair.",
            "test_sql": "SELECT COUNT(*) FROM lnkcustomercontracttoservice t1 JOIN lnkslatoslt t2 ON t1.sla_id = t2.sla_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "lnkcustomercontracttoservice",
            "from_column": "service_id",
            "to_table": "service",
            "to_column": "id",
            "condition": "lnkcustomercontracttoservice.service_id = service.id",
            "confidence": "high",
            "reasoning": "The field 'service_id' in 'lnkcustomercontracttoservice' matches the primary key 'id' in 'service' by both naming convention and data type (int). The business purpose of 'lnkcustomercontracttoservice' is to link customer contracts to specific services, which are catalogued in the 'service' table. This is a classic foreign key relationship, even though it is not explicitly defined in the schema.",
            "test_sql": "SELECT COUNT(*) FROM lnkcustomercontracttoservice t1 JOIN service t2 ON t1.service_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "lnkcustomercontracttoservice",
            "from_column": "sla_id",
            "to_table": "sla",
            "to_column": "id",
            "condition": "lnkcustomercontracttoservice.sla_id = sla.id",
            "confidence": "high",
            "reasoning": "The field 'sla_id' in 'lnkcustomercontracttoservice' matches the primary key 'id' in 'sla', both are of type int, and the business logic indicates that each service linked to a customer contract can be associated with a specific SLA. This is a common foreign key pattern, even though the foreign key is not explicitly defined in the schema.",
            "test_sql": "SELECT COUNT(*) FROM lnkcustomercontracttoservice t1 JOIN sla t2 ON t1.sla_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "lnkdeliverymodeltocontact",
            "from_column": "contact_id",
            "to_table": "person",
            "to_column": "id",
            "condition": "lnkdeliverymodeltocontact.contact_id = person.id",
            "confidence": "high",
            "reasoning": "The field 'contact_id' in 'lnkdeliverymodeltocontact' is an integer and likely references the 'id' field in 'person', which is the primary key. The business purpose of 'lnkdeliverymodeltocontact' is to associate contacts with delivery models, and the 'person' table stores individual contact details. This is a common pattern where a linking table references the primary key of an entity table.",
            "test_sql": "SELECT COUNT(*) FROM lnkdeliverymodeltocontact t1 JOIN person t2 ON t1.contact_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "lnkpersontoteam",
            "from_column": "person_id",
            "to_table": "person",
            "to_column": "id",
            "condition": "lnkpersontoteam.person_id = person.id",
            "confidence": "high",
            "reasoning": "The 'person_id' field in 'lnkpersontoteam' is an integer and matches the primary key 'id' in 'person'. The business purpose of 'lnkpersontoteam' is to link persons to teams, and the only logical way to reference a person is via their unique identifier. This is a standard foreign key pattern, even though the foreign key is not explicitly defined in the schema.",
            "test_sql": "SELECT COUNT(*) FROM lnkpersontoteam t1 JOIN person t2 ON t1.person_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "lnkpersontoteam",
            "from_column": "team_id",
            "to_table": "team",
            "to_column": "id",
            "condition": "lnkpersontoteam.team_id = team.id",
            "confidence": "high",
            "reasoning": "The 'team_id' field in 'lnkpersontoteam' matches the primary key 'id' in 'team' by both naming convention and data type (int). The business purpose of 'lnkpersontoteam' is to link persons to teams, so it is logical that 'team_id' references 'team.id'. This is a standard foreign key pattern, even though the foreign key is not explicitly defined in the schema.",
            "test_sql": "SELECT COUNT(*) FROM lnkpersontoteam t1 JOIN team t2 ON t1.team_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "lnkslatoslt",
            "from_column": "sla_id",
            "to_table": "sla",
            "to_column": "id",
            "condition": "lnkslatoslt.sla_id = sla.id",
            "confidence": "high",
            "reasoning": "The field 'sla_id' in 'lnkslatoslt' matches the primary key 'id' in 'sla' by both naming convention and data type (int). The business purpose of 'lnkslatoslt' is to link SLAs to another entity, and this is a standard join table pattern. This relationship is likely intended to associate each record in 'lnkslatoslt' with a specific SLA.",
            "test_sql": "SELECT COUNT(*) FROM lnkslatoslt t1 JOIN sla t2 ON t1.sla_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "lnkslatoslt",
            "from_column": "slt_id",
            "to_table": "slt",
            "to_column": "id",
            "condition": "lnkslatoslt.slt_id = slt.id",
            "confidence": "high",
            "reasoning": "The 'lnkslatoslt' table is a linking table, and the 'slt_id' column is an integer that matches the primary key 'id' in the 'slt' table. This is a common database pattern for establishing a many-to-many relationship. The business purpose of 'lnkslatoslt' is to associate SLAs with SLTs, and the only way to reference an SLT is via its 'id'.",
            "test_sql": "SELECT COUNT(*) FROM lnkslatoslt t1 JOIN slt t2 ON t1.slt_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "location",
            "from_column": "id",
            "to_table": "physicaldevice",
            "to_column": "location_id",
            "condition": "location.id = physicaldevice.location_id",
            "confidence": "high",
            "reasoning": "The 'physicaldevice' table contains a 'location_id' field of type int, which matches the primary key 'id' in the 'location' table. The naming convention and business logic both strongly suggest that each physical device is assigned to a specific location, and this is a common foreign key pattern in asset management systems.",
            "test_sql": "SELECT COUNT(*) FROM location t1 JOIN physicaldevice t2 ON t1.id = t2.location_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "location",
            "from_column": "id",
            "to_table": "person",
            "to_column": "location_id",
            "condition": "location.id = person.location_id",
            "confidence": "high",
            "reasoning": "The 'person' table contains a 'location_id' column of type int, which matches the primary key 'id' of the 'location' table. This is a common pattern for representing that a person is assigned to or based at a specific location. The naming convention and data types are compatible, and the business logic supports associating individuals with locations.",
            "test_sql": "SELECT COUNT(*) FROM location t1 JOIN person t2 ON t1.id = t2.location_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "location",
            "from_column": "org_id",
            "to_table": "organization",
            "to_column": "id",
            "condition": "location.org_id = organization.id",
            "confidence": "high",
            "reasoning": "The 'org_id' field in the 'location' table is an integer and is named in a way that strongly suggests it references the 'id' field of the 'organization' table. This is a common pattern in database design, where a child entity (location) references its parent entity (organization) via a foreign key. The business logic also supports this: locations are typically associated with organizations, and the 'org_id' field enables grouping or filtering locations by their parent organization.",
            "test_sql": "SELECT COUNT(*) FROM location t1 JOIN organization t2 ON t1.org_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "model",
            "from_column": "id",
            "to_table": "physicaldevice",
            "to_column": "model_id",
            "condition": "model.id = physicaldevice.model_id",
            "confidence": "high",
            "reasoning": "The 'physicaldevice' table has a 'model_id' column that matches the primary key 'id' of the 'model' table. This is a classic foreign key pattern where each physical device instance references the model it is based on. The data types are compatible (both int), and the business logic aligns: each device is of a specific model.",
            "test_sql": "SELECT COUNT(*) FROM model t1 JOIN physicaldevice t2 ON t1.id = t2.model_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "networkdevice",
            "from_column": "networkdevicetype_id",
            "to_table": "networkdevicetype",
            "to_column": "id",
            "condition": "networkdevice.networkdevicetype_id = networkdevicetype.id",
            "confidence": "high",
            "reasoning": "The field 'networkdevicetype_id' in 'networkdevice' matches the primary key 'id' in 'networkdevicetype' by both naming convention and data type (int). The business purpose of 'networkdevicetype' is to serve as a lookup for device types, and 'networkdevice' references this type, indicating a classic foreign key relationship. This is a common database design pattern for categorizing or classifying records.",
            "test_sql": "SELECT COUNT(*) FROM networkdevice t1 JOIN networkdevicetype t2 ON t1.networkdevicetype_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "networkdevice",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "objkey",
            "condition": "networkdevice.id = priv_changeop.objkey AND priv_changeop.objclass = 'networkdevice'",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass indicates the type of object being referenced and objkey stores the object's primary key. Since 'networkdevice' is a table and 'id' is its primary key, it is highly likely that priv_changeop records with objclass = 'networkdevice' and objkey = networkdevice.id represent operations performed on networkdevice records.",
            "test_sql": "SELECT COUNT(*) FROM networkdevice t1 JOIN priv_changeop t2 ON t1.id = t2.objkey WHERE t2.objclass = 'networkdevice' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "organization",
            "from_column": "id",
            "to_table": "service",
            "to_column": "org_id",
            "condition": "organization.id = service.org_id",
            "confidence": "high",
            "reasoning": "The 'service' table contains an 'org_id' column of type int, which matches the primary key 'id' of the 'organization' table. The business purpose of both tables supports a relationship where each service is associated with an organizational unit. This is a common pattern where a child entity (service) references its parent (organization) via a foreign key, even though the foreign key constraint is not explicitly defined in the schema.",
            "test_sql": "SELECT COUNT(*) FROM organization t1 JOIN service t2 ON t1.id = t2.org_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "organization",
            "from_column": "id",
            "to_table": "sla",
            "to_column": "org_id",
            "condition": "organization.id = sla.org_id",
            "confidence": "high",
            "reasoning": "The 'sla' table contains an 'org_id' column of type int, which matches the primary key 'id' of the 'organization' table. The business purpose of 'sla' is to represent Service Level Agreements that are associated with organizational units, and the naming convention ('org_id') strongly suggests a foreign key relationship to 'organization.id'. This is a common database design pattern for associating records in a child table (sla) with a parent table (organization).",
            "test_sql": "SELECT COUNT(*) FROM organization t1 JOIN sla t2 ON t1.id = t2.org_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "osfamily",
            "from_column": "id",
            "to_table": "osversion",
            "to_column": "osfamily_id",
            "condition": "osfamily.id = osversion.osfamily_id",
            "confidence": "high",
            "reasoning": "The 'osversion' table contains an 'osfamily_id' column, which by naming convention and data type (int) matches the primary key 'id' of the 'osfamily' table. This is a common pattern for establishing a one-to-many relationship, where each OS version belongs to a single OS family. The business logic also supports this, as OS versions are typically grouped under OS families.",
            "test_sql": "SELECT COUNT(*) FROM osfamily t1 JOIN osversion t2 ON t1.id = t2.osfamily_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "osfamily",
            "from_column": "id",
            "to_table": "server",
            "to_column": "osfamily_id",
            "condition": "osfamily.id = server.osfamily_id",
            "confidence": "high",
            "reasoning": "The 'server' table contains a column named 'osfamily_id' of type int, which matches the primary key 'id' in the 'osfamily' table. The naming convention and data type compatibility strongly suggest that 'osfamily_id' is intended to reference 'osfamily.id', establishing a foreign key relationship. This aligns with common database design patterns where a child table (server) references a parent table (osfamily) to categorize or group records by a classification entity (OS family).",
            "test_sql": "SELECT COUNT(*) FROM osfamily t1 JOIN server t2 ON t1.id = t2.osfamily_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "osfamily",
            "from_column": "id",
            "to_table": "virtualmachine",
            "to_column": "osfamily_id",
            "condition": "osfamily.id = virtualmachine.osfamily_id",
            "confidence": "high",
            "reasoning": "The 'osfamily' table provides unique identifiers for operating system families, and the 'virtualmachine' table contains an 'osfamily_id' column of the same data type and naming convention. This strongly suggests that 'virtualmachine.osfamily_id' is intended to reference 'osfamily.id', establishing a many-to-one relationship where each virtual machine is associated with a specific OS family. This is a common database design pattern for categorizing or grouping entities.",
            "test_sql": "SELECT COUNT(*) FROM osfamily t1 JOIN virtualmachine t2 ON t1.id = t2.osfamily_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "osversion",
            "from_column": "id",
            "to_table": "server",
            "to_column": "osversion_id",
            "condition": "osversion.id = server.osversion_id",
            "confidence": "high",
            "reasoning": "The 'server' table contains an 'osversion_id' field, which by naming convention and data type (int) matches the primary key 'id' of the 'osversion' table. This is a common pattern for referencing a specific OS version installed on a server. The business logic also supports this, as each server would be associated with a particular OS version.",
            "test_sql": "SELECT COUNT(*) FROM osversion t1 JOIN server t2 ON t1.id = t2.osversion_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "osversion",
            "from_column": "id",
            "to_table": "virtualmachine",
            "to_column": "osversion_id",
            "condition": "osversion.id = virtualmachine.osversion_id",
            "confidence": "high",
            "reasoning": "The 'osversion' table's primary key 'id' matches the 'osversion_id' field in 'virtualmachine'. Both are of type int, and the naming convention strongly suggests that 'virtualmachine.osversion_id' is intended to reference 'osversion.id'. This is a common foreign key pattern where a child table (virtualmachine) references a parent table (osversion) to indicate which OS version is installed on the VM.",
            "test_sql": "SELECT COUNT(*) FROM osversion t1 JOIN virtualmachine t2 ON t1.id = t2.osversion_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "person",
            "from_column": "id",
            "to_table": "priv_app_preferences",
            "to_column": "userid",
            "condition": "person.id = priv_app_preferences.userid",
            "confidence": "high",
            "reasoning": "The 'userid' column in 'priv_app_preferences' is an integer and likely refers to a user or person entity. The 'person' table's primary key is 'id', also an integer. Given the business purposes'person' representing individuals and 'priv_app_preferences' storing preferences for usersit is logical to infer that 'userid' in 'priv_app_preferences' references 'id' in 'person', even though no explicit foreign key is defined.",
            "test_sql": "SELECT COUNT(*) FROM person t1 JOIN priv_app_preferences t2 ON t1.id = t2.userid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "person",
            "from_column": "id",
            "to_table": "priv_user",
            "to_column": "contactid",
            "condition": "person.id = priv_user.contactid",
            "confidence": "high",
            "reasoning": "The 'priv_user' table has a 'contactid' field of type int, which matches the primary key 'id' in the 'person' table. The business purpose of 'priv_user' is to represent user accounts, and it references a contact entity via 'contactid'. Since 'person' stores individual details, it is logical that 'priv_user.contactid' refers to 'person.id', establishing a one-to-one or many-to-one relationship between user accounts and persons.",
            "test_sql": "SELECT COUNT(*) FROM person t1 JOIN priv_user t2 ON t1.id = t2.contactid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_action",
            "from_column": "id",
            "to_table": "priv_link_action_trigger",
            "to_column": "action_id",
            "condition": "priv_action.id = priv_link_action_trigger.action_id",
            "confidence": "high",
            "reasoning": "The 'action_id' field in 'priv_link_action_trigger' is an integer and its naming convention directly references the 'id' field of 'priv_action'. The business purpose of 'priv_link_action_trigger' is to link actions to triggers, and 'priv_action' is the catalog of actions. This is a common foreign key pattern, even though the foreign key is not explicitly defined.",
            "test_sql": "SELECT COUNT(*) FROM priv_action t1 JOIN priv_link_action_trigger t2 ON t1.id = t2.action_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_app_preferences",
            "from_column": "userid",
            "to_table": "priv_user",
            "to_column": "id",
            "condition": "priv_app_preferences.userid = priv_user.id",
            "confidence": "high",
            "reasoning": "The 'userid' field in 'priv_app_preferences' is an integer and is likely intended to reference the 'id' field in 'priv_user', which is the primary key for user records. This follows common database design patterns where user-specific data (such as preferences) references the user table via a user ID. The business logic also supports this, as preferences are typically associated with users.",
            "test_sql": "SELECT COUNT(*) FROM priv_app_preferences t1 JOIN priv_user t2 ON t1.userid = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_change",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "changeid",
            "condition": "priv_change.id = priv_changeop.changeid",
            "confidence": "high",
            "reasoning": "The 'changeid' field in 'priv_changeop' is an integer and is indexed (MUL), matching the primary key 'id' in 'priv_change'. The naming convention ('changeid') strongly suggests it is intended to reference a change event, which aligns with the business purpose of 'priv_change' as a log of privilege changes. This is a common pattern where a main change event table is referenced by a detail or operation table via a foreign key, even if not explicitly defined.",
            "test_sql": "SELECT COUNT(*) FROM priv_change t1 JOIN priv_changeop t2 ON t1.id = t2.changeid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 348,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_internaluser",
            "from_column": "id",
            "to_table": "priv_user_local",
            "to_column": "id",
            "condition": "priv_internaluser.id = priv_user_local.id",
            "confidence": "high",
            "reasoning": "Both tables use 'id' as their primary key, and both represent user-related entities. It is a common database design pattern to separate core user identity (priv_internaluser) from authentication credentials (priv_user_local) using a one-to-one relationship on the 'id' field. This allows for modular management of user metadata and sensitive authentication data. The matching data types (int, auto_increment) and naming conventions further support this inference.",
            "test_sql": "SELECT COUNT(*) FROM priv_internaluser t1 JOIN priv_user_local t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_link_action_trigger",
            "from_column": "trigger_id",
            "to_table": "priv_trigger",
            "to_column": "id",
            "condition": "priv_link_action_trigger.trigger_id = priv_trigger.id",
            "confidence": "high",
            "reasoning": "The field 'trigger_id' in 'priv_link_action_trigger' is an integer and its naming convention matches the primary key 'id' in 'priv_trigger'. The business logic and schema analysis suggest that 'priv_link_action_trigger' is a mapping table linking actions to triggers, and thus 'trigger_id' is likely intended to reference 'priv_trigger.id'. This is a common database design pattern for many-to-many relationships, even though the foreign key is not explicitly defined.",
            "test_sql": "SELECT COUNT(*) FROM priv_link_action_trigger t1 JOIN priv_trigger t2 ON t1.trigger_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_urp_profiles",
            "from_column": "id",
            "to_table": "priv_urp_userprofile",
            "to_column": "profileid",
            "condition": "priv_urp_profiles.id = priv_urp_userprofile.profileid",
            "confidence": "high",
            "reasoning": "The 'profileid' column in 'priv_urp_userprofile' is an integer and matches the primary key 'id' in 'priv_urp_profiles'. The naming convention and business logic suggest that 'priv_urp_userprofile' is a mapping table linking users to profiles, with 'profileid' referencing the profile's unique identifier. This is a common database design pattern for many-to-many relationships.",
            "test_sql": "SELECT COUNT(*) FROM priv_urp_profiles t1 JOIN priv_urp_userprofile t2 ON t1.id = t2.profileid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_urp_userprofile",
            "from_column": "userid",
            "to_table": "priv_user",
            "to_column": "id",
            "condition": "priv_urp_userprofile.userid = priv_user.id",
            "confidence": "high",
            "reasoning": "The 'userid' field in 'priv_urp_userprofile' and the 'id' field in 'priv_user' share a naming convention and compatible data types (both int). The business logic suggests that 'priv_urp_userprofile' is a mapping table associating users (likely from 'priv_user') with profiles. This is a common database pattern for many-to-many relationships between users and profiles. Although no explicit foreign key is defined, this is a standard inferred relationship.",
            "test_sql": "SELECT COUNT(*) FROM priv_urp_userprofile t1 JOIN priv_user t2 ON t1.userid = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_user",
            "from_column": "id",
            "to_table": "priv_user_local",
            "to_column": "id",
            "condition": "priv_user.id = priv_user_local.id",
            "confidence": "high",
            "reasoning": "Both tables use 'id' as their primary key, and the business purposes suggest that 'priv_user_local' extends 'priv_user' by storing authentication credentials for each user. This is a common database design pattern where a user table is extended by a credentials table using a one-to-one relationship on the primary key. The data types are compatible (both int, auto_increment), and the naming convention strongly suggests a direct link.",
            "test_sql": "SELECT COUNT(*) FROM priv_user t1 JOIN priv_user_local t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "service",
            "from_column": "servicefamily_id",
            "to_table": "servicefamily",
            "to_column": "id",
            "condition": "service.servicefamily_id = servicefamily.id",
            "confidence": "high",
            "reasoning": "The 'service' table contains a 'servicefamily_id' column, which by naming convention and data type (int) matches the primary key 'id' of the 'servicefamily' table. The business purpose of both tables supports a one-to-many relationship: each service belongs to a single service family, and each service family can have multiple services. This is a common database design pattern for categorizing or grouping records.",
            "test_sql": "SELECT COUNT(*) FROM service t1 JOIN servicefamily t2 ON t1.servicefamily_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "service",
            "from_column": "id",
            "to_table": "servicesubcategory",
            "to_column": "service_id",
            "condition": "service.id = servicesubcategory.service_id",
            "confidence": "high",
            "reasoning": "The 'servicesubcategory' table contains a 'service_id' column of type int, which matches the primary key 'id' of the 'service' table. The business purpose and naming convention indicate that each subcategory is associated with a parent service, forming a classic one-to-many (service to servicesubcategory) relationship. This is a common database design pattern for categorizing sub-entities under a parent entity.",
            "test_sql": "SELECT COUNT(*) FROM service t1 JOIN servicesubcategory t2 ON t1.id = t2.service_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 17,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "software",
            "from_column": "id",
            "to_table": "softwareinstance",
            "to_column": "software_id",
            "condition": "software.id = softwareinstance.software_id",
            "confidence": "high",
            "reasoning": "The 'softwareinstance' table contains a 'software_id' column of type int, which matches the primary key 'id' in the 'software' table. The business purpose of 'softwareinstance' is to represent individual deployments of software, and it logically references the software definition in the 'software' table. This is a classic foreign key relationship, even though it is not explicitly defined in the schema.",
            "test_sql": "SELECT COUNT(*) FROM software t1 JOIN softwareinstance t2 ON t1.id = t2.software_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "virtualhost",
            "from_column": "id",
            "to_table": "virtualmachine",
            "to_column": "virtualhost_id",
            "condition": "virtualhost.id = virtualmachine.virtualhost_id",
            "confidence": "high",
            "reasoning": "The 'virtualmachine' table contains a column named 'virtualhost_id' of type int, which matches the primary key 'id' of the 'virtualhost' table. This naming convention and data type compatibility strongly suggest a foreign key relationship, where each virtual machine is associated with a virtual host. This is a common pattern in infrastructure management, where VMs are hosted on virtual hosts.",
            "test_sql": "SELECT COUNT(*) FROM virtualhost t1 JOIN virtualmachine t2 ON t1.id = t2.virtualhost_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "webapplication",
            "from_column": "webserver_id",
            "to_table": "webserver",
            "to_column": "id",
            "condition": "webapplication.webserver_id = webserver.id",
            "confidence": "high",
            "reasoning": "The 'webapplication' table contains a 'webserver_id' column of type int, which matches the primary key 'id' in the 'webserver' table. The naming convention and data types strongly suggest that 'webserver_id' is intended to reference 'webserver.id', forming a classic one-to-many (foreign key) relationship where each web application may be associated with a web server.",
            "test_sql": "SELECT COUNT(*) FROM webapplication t1 JOIN webserver t2 ON t1.webserver_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "applicationsolution",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "objkey",
            "condition": "applicationsolution.id = priv_changeop.objkey AND priv_changeop.objclass = 'applicationsolution'",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass indicates the type of object being referenced and objkey is the object's ID. Since 'applicationsolution' is a table name and objclass is a varchar, it is plausible that priv_changeop records changes to application solutions by setting objclass = 'applicationsolution' and objkey = applicationsolution.id. This is a common design for change tracking/auditing tables.",
            "test_sql": "SELECT COUNT(*) FROM applicationsolution t1 JOIN priv_changeop t2 ON t1.id = t2.objkey AND t2.objclass = 'applicationsolution' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 15,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "applicationsolution",
            "from_column": "id",
            "to_table": "priv_changeop_links",
            "to_column": "item_id",
            "condition": "applicationsolution.id = priv_changeop_links.item_id AND priv_changeop_links.item_class = 'applicationsolution'",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed for polymorphic associations, where item_class specifies the type of entity and item_id is the corresponding primary key. Given the business purpose of tracking changes to various items, it is plausible that changes to application solutions are tracked here, with item_class set to 'applicationsolution' and item_id referencing applicationsolution.id. However, this is not enforced by a foreign key and relies on naming conventions and typical design patterns.",
            "test_sql": "SELECT COUNT(*) FROM applicationsolution t1 JOIN priv_changeop_links t2 ON t1.id = t2.item_id WHERE t2.item_class = 'applicationsolution' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 10,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "brand",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "objkey",
            "condition": "brand.id = priv_changeop.objkey AND priv_changeop.objclass = 'brand'",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass indicates the type of object being referenced and objkey stores the object's ID. Since 'brand' is a table with an integer primary key (id), and priv_changeop.objkey is also an integer, it is plausible that changes to brand records are tracked in priv_changeop with objclass set to 'brand' and objkey referencing brand.id. This is a common pattern for audit/change tracking tables.",
            "test_sql": "SELECT COUNT(*) FROM brand t1 JOIN priv_changeop t2 ON t1.id = t2.objkey WHERE t2.objclass = 'brand' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "connectableci",
            "from_column": "id",
            "to_table": "datacenterdevice",
            "to_column": "id",
            "condition": "connectableci.id = datacenterdevice.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of type int and both are primary keys. In some database designs, especially those using single-table inheritance or table-per-class inheritance, a child table (like 'datacenterdevice') may share the same primary key value as its parent (like 'connectableci'). The presence of a 'finalclass' field in both tables further suggests a possible inheritance or polymorphic relationship, where 'datacenterdevice' could be a specialized type of 'connectableci'. However, there is no explicit foreign key constraint, so this is an inferred relationship based on naming, data type, and common design patterns.",
            "test_sql": "SELECT COUNT(*) FROM connectableci t1 JOIN datacenterdevice t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "connectableci",
            "from_column": "id",
            "to_table": "priv_changeop_links",
            "to_column": "item_id",
            "condition": "connectableci.id = priv_changeop_links.item_id AND priv_changeop_links.item_class = connectableci.finalclass",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table uses a polymorphic association pattern, referencing items by both class (item_class) and id (item_id). The connectableci table's id and finalclass fields match the types and naming conventions of item_id and item_class, respectively. This suggests that priv_changeop_links may record operations performed on connectableci records, distinguished by class. However, this is not enforced by explicit foreign keys, and item_class could reference other classes not present in connectableci, so the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM connectableci t1 JOIN priv_changeop_links t2 ON t1.id = t2.item_id AND t2.item_class = t1.finalclass LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 15,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "connectableci",
            "from_column": "id",
            "to_table": "physicaldevice",
            "to_column": "id",
            "condition": "connectableci.id = physicaldevice.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of type int, which is the primary key in each table. In some database designs, especially those using single-table inheritance or class-table inheritance, a base table (here, 'connectableci') holds the common fields and a subclass table (here, 'physicaldevice') extends it with more specific fields, sharing the same primary key value. The presence of a 'finalclass' field in both tables further suggests a polymorphic or inheritance relationship, where 'physicaldevice' could be a subtype of 'connectableci'. However, there is no explicit foreign key constraint, so this is an inferred relationship based on naming, data type, and business logic.",
            "test_sql": "SELECT COUNT(*) FROM connectableci t1 JOIN physicaldevice t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "connectableci",
            "from_column": "id",
            "to_table": "softwareinstance",
            "to_column": "functionalci_id",
            "condition": "connectableci.id = softwareinstance.functionalci_id",
            "confidence": "high",
            "reasoning": "The 'softwareinstance' table has a 'functionalci_id' column of type int, which is likely intended to reference a configuration item. The 'connectableci' table represents connectable configuration items with a primary key 'id'. Given the business context (IT asset/configuration management), it is plausible that 'softwareinstance.functionalci_id' refers to 'connectableci.id', establishing a many-to-one relationship where each software instance is installed on a specific connectable configuration item. However, the relationship is not explicitly defined as a foreign key, and the naming is not a perfect match, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM connectableci t1 JOIN softwareinstance t2 ON t1.id = t2.functionalci_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contact",
            "from_column": "org_id",
            "to_table": "contract",
            "to_column": "org_id",
            "condition": "contact.org_id = contract.org_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'org_id' field of type int, which likely refers to the same organization entity. This suggests that contacts and contracts can be associated with the same organization, allowing for business logic such as finding all contacts related to contracts for a given organization. However, there is no explicit foreign key or direct business rule linking a contact to a specific contract, only to the organization.",
            "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN contract t2 ON t1.org_id = t2.org_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contact",
            "from_column": "org_id",
            "to_table": "deliverymodel",
            "to_column": "org_id",
            "condition": "contact.org_id = deliverymodel.org_id",
            "confidence": "high",
            "reasoning": "Both tables contain an 'org_id' field of type int, which likely refers to the same organizational entity. This suggests that contacts and delivery models can be associated with the same organization. While this does not directly link a contact to a delivery model, it allows for joining both tables on their shared organization, which may be useful for reporting or filtering contacts and delivery models belonging to the same organization.",
            "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN deliverymodel t2 ON t1.org_id = t2.org_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 29,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contact",
            "from_column": "org_id",
            "to_table": "functionalci",
            "to_column": "org_id",
            "condition": "contact.org_id = functionalci.org_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'org_id' field of type int, which likely refers to the same organization entity. This suggests that contacts and functional configuration items can be associated with the same organization, enabling queries such as 'all contacts related to the same organization as a given configuration item.' While there is no explicit foreign key, the naming, data type, and business context support this relationship.",
            "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN functionalci t2 ON t1.org_id = t2.org_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 217,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contact",
            "from_column": "id",
            "to_table": "priv_app_preferences",
            "to_column": "userid",
            "condition": "contact.id = priv_app_preferences.userid",
            "confidence": "high",
            "reasoning": "The 'userid' field in 'priv_app_preferences' is an integer and is indexed (MUL), which matches the data type and indexing of the 'id' field in 'contact'. While the field is named 'userid' (not 'contact_id'), in the absence of a dedicated 'user' table and given the business context (contacts representing people who may have application preferences), it is plausible that 'userid' refers to the 'contact.id'. This would allow storing application preferences for each contact.",
            "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN priv_app_preferences t2 ON t1.id = t2.userid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contact",
            "from_column": "id",
            "to_table": "priv_changeop_links",
            "to_column": "item_id",
            "condition": "contact.id = priv_changeop_links.item_id AND priv_changeop_links.item_class = 'Contact'",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed for polymorphic associations, using item_class and item_id to reference various entities. Since 'Contact' is the default value for contact.finalclass and the contact table's primary key is id (int), it is plausible that priv_changeop_links can reference contact records when item_class = 'Contact' and item_id = contact.id. This is a common pattern for generic change tracking or audit tables.",
            "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN priv_changeop_links t2 ON t1.id = t2.item_id AND t2.item_class = 'Contact' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contact",
            "from_column": "org_id",
            "to_table": "service",
            "to_column": "org_id",
            "condition": "contact.org_id = service.org_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'org_id' field of type int, which likely refers to the same organization entity. This suggests that contacts and services can be associated with the same organization, allowing for queries such as 'all contacts related to services of a given organization.' However, there is no direct business logic or foreign key constraint between contact and service, only a shared organizational context.",
            "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN service t2 ON t1.org_id = t2.org_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 87,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contact",
            "from_column": "org_id",
            "to_table": "sla",
            "to_column": "org_id",
            "condition": "contact.org_id = sla.org_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'org_id' field of type int, which likely refers to the same organization entity. While there is no explicit foreign key constraint, it is common in business systems for contacts and SLAs to be associated with organizations. This relationship would allow analysis of which contacts are associated with organizations that have specific SLAs.",
            "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN sla t2 ON t1.org_id = t2.org_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contract",
            "from_column": "org_id",
            "to_table": "functionalci",
            "to_column": "org_id",
            "condition": "contract.org_id = functionalci.org_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'org_id' field of type int, which likely references the same organization entity. This suggests that contracts and functional configuration items can be associated with the same organization. While this does not establish a direct foreign key relationship between the two tables, it allows for business logic joins to analyze contracts and configuration items belonging to the same organization.",
            "test_sql": "SELECT COUNT(*) FROM contract t1 JOIN functionalci t2 ON t1.org_id = t2.org_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 31,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contract",
            "from_column": "org_id",
            "to_table": "sla",
            "to_column": "org_id",
            "condition": "contract.org_id = sla.org_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'org_id' field of type int, which likely references the same organization entity. This suggests that contracts and SLAs may be associated with the same organization, allowing for analysis of all contracts and SLAs belonging to a given organization. However, there is no explicit foreign key or business rule tying a contract directly to a specific SLA, so the relationship is organizational rather than contractual.",
            "test_sql": "SELECT COUNT(*) FROM contract t1 JOIN sla t2 ON t1.org_id = t2.org_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "customercontract",
            "from_column": "id",
            "to_table": "priv_changeop_links",
            "to_column": "item_id",
            "condition": "customercontract.id = priv_changeop_links.item_id AND priv_changeop_links.item_class = 'customercontract'",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed for polymorphic associations, where item_class specifies the type of entity and item_id is the identifier. Since customercontract.id is the primary key of the customercontract table, and priv_changeop_links.item_id is an integer that could reference any entity's ID, it is plausible that when item_class = 'customercontract', item_id refers to customercontract.id. This is a common pattern for generic change tracking tables.",
            "test_sql": "SELECT COUNT(*) FROM customercontract t1 JOIN priv_changeop_links t2 ON t1.id = t2.item_id WHERE t2.item_class = 'customercontract' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "customercontract",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "objkey",
            "condition": "customercontract.id = priv_changeop.objkey AND priv_changeop.objclass = 'customercontract'",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass indicates the type of object being referenced and objkey stores the object's primary key. Since customercontract.id is the primary key of the customercontract table, and priv_changeop.objclass could potentially store the string 'customercontract', this join would allow tracking of change operations performed on customercontract records. However, this relationship is inferred based on naming conventions and common design patterns, as there is no explicit foreign key or constraint.",
            "test_sql": "SELECT COUNT(*) FROM customercontract t1 JOIN priv_changeop t2 ON t1.id = t2.objkey AND t2.objclass = 'customercontract' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "databaseschema",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "objkey",
            "condition": "databaseschema.id = priv_changeop.objkey AND priv_changeop.objclass = 'databaseschema'",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass indicates the type of object being referenced and objkey is the object's ID. Since 'databaseschema' is a table representing schemas, it is plausible that changes to database schemas are tracked in priv_changeop with objclass = 'databaseschema' and objkey = databaseschema.id. This is a common pattern for audit/change tracking tables.",
            "test_sql": "SELECT COUNT(*) FROM databaseschema t1 JOIN priv_changeop t2 ON t1.id = t2.objkey AND t2.objclass = 'databaseschema' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "databaseschema",
            "from_column": "id",
            "to_table": "priv_changeop_links",
            "to_column": "item_id",
            "condition": "databaseschema.id = priv_changeop_links.item_id AND priv_changeop_links.item_class = 'databaseschema'",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed for polymorphic associations, where item_class specifies the type of item and item_id is the identifier. Since 'databaseschema' is a table representing schemas, it is plausible that change operations could be tracked for these schemas. The most likely mapping is priv_changeop_links.item_class = 'databaseschema' and item_id = databaseschema.id. However, this is not enforced by foreign keys and depends on application logic.",
            "test_sql": "SELECT COUNT(*) FROM databaseschema t1 JOIN priv_changeop_links t2 ON t1.id = t2.item_id WHERE t2.item_class = 'databaseschema' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "datacenterdevice",
            "from_column": "id",
            "to_table": "hypervisor",
            "to_column": "server_id",
            "condition": "datacenterdevice.id = hypervisor.server_id",
            "confidence": "high",
            "reasoning": "The 'hypervisor' table has a 'server_id' column, which is an integer and could logically reference the 'id' of a physical device in the 'datacenterdevice' table. This would make sense if each hypervisor is running on a specific physical device tracked in 'datacenterdevice'. The naming convention ('server_id') and business logic (hypervisors run on physical servers) support this relationship, though it is not explicitly defined as a foreign key.",
            "test_sql": "SELECT COUNT(*) FROM datacenterdevice t1 JOIN hypervisor t2 ON t1.id = t2.server_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "datacenterdevice",
            "from_column": "id",
            "to_table": "softwareinstance",
            "to_column": "functionalci_id",
            "condition": "datacenterdevice.id = softwareinstance.functionalci_id",
            "confidence": "high",
            "reasoning": "The 'softwareinstance' table has a 'functionalci_id' field, which likely refers to a configuration item (CI) where the software is installed. Given the business purpose of 'datacenterdevice' as a physical asset and the typical ITSM/CMDB pattern where software is installed on hardware assets, it is plausible that 'functionalci_id' could reference 'datacenterdevice.id'. Both fields are of type int, and this would allow tracking which software instances are installed on which physical devices.",
            "test_sql": "SELECT COUNT(*) FROM datacenterdevice t1 JOIN softwareinstance t2 ON t1.id = t2.functionalci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "dbserver",
            "from_column": "id",
            "to_table": "priv_changeop_links",
            "to_column": "item_id",
            "condition": "dbserver.id = priv_changeop_links.item_id AND priv_changeop_links.item_class = 'dbserver'",
            "confidence": "high",
            "reasoning": "The 'priv_changeop_links' table uses a polymorphic association pattern, where 'item_class' specifies the type of entity and 'item_id' is the identifier. Since 'dbserver' is a table of server records with an 'id' primary key, it is plausible that some records in 'priv_changeop_links' refer to dbserver entries (i.e., item_class = 'dbserver' and item_id = dbserver.id). This is a common pattern for tracking changes to various entity types in a generic way.",
            "test_sql": "SELECT COUNT(*) FROM dbserver t1 JOIN priv_changeop_links t2 ON t1.id = t2.item_id WHERE t2.item_class = 'dbserver' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "organization",
            "from_column": "id",
            "to_table": "deliverymodel",
            "to_column": "org_id",
            "condition": "organization.id = deliverymodel.org_id",
            "confidence": "high",
            "reasoning": "The 'deliverymodel' table has an 'org_id' column, which likely refers to the 'id' of the 'organization' table. This suggests that a delivery model can be associated with a specific organization, either as its owner or as the context in which it is defined. The data types match (both int), and this is a common pattern for scoping reference data to an organization.",
            "test_sql": "SELECT COUNT(*) FROM organization t1 JOIN deliverymodel t2 ON t1.id = t2.org_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "deliverymodel",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "objkey",
            "condition": "deliverymodel.id = priv_changeop.objkey AND priv_changeop.objclass = 'deliverymodel'",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass indicates the type of object being referenced and objkey is the object's primary key. Since deliverymodel's primary key is id, and priv_changeop.objclass could potentially reference 'deliverymodel', this join would allow tracking of change operations performed on deliverymodel records. However, this is inferred from naming conventions and common design patterns, as there are no explicit foreign keys or constraints.",
            "test_sql": "SELECT COUNT(*) FROM deliverymodel t1 JOIN priv_changeop t2 ON t1.id = t2.objkey WHERE t2.objclass = 'deliverymodel' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "deliverymodel",
            "from_column": "org_id",
            "to_table": "service",
            "to_column": "org_id",
            "condition": "deliverymodel.org_id = service.org_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'org_id' field of type int, which likely refers to the same organizational entity. This suggests that services and delivery models can be grouped or filtered by organization. However, this is not a direct foreign key relationship between the two tables, but rather a logical grouping or filtering mechanism.",
            "test_sql": "SELECT COUNT(*) FROM deliverymodel t1 JOIN service t2 ON t1.org_id = t2.org_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "farm",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "objkey",
            "condition": "farm.id = priv_changeop.objkey AND priv_changeop.objclass = 'farm'",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass indicates the type of object being referenced and objkey is the object's ID. Since 'farm' is a table with an 'id' primary key, it is plausible that priv_changeop records changes to farm entities by setting objclass = 'farm' and objkey = farm.id. This is a common design for audit/change tracking tables.",
            "test_sql": "SELECT COUNT(*) FROM farm t1 JOIN priv_changeop t2 ON t1.id = t2.objkey AND t2.objclass = 'farm' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "functionalci",
            "from_column": "id",
            "to_table": "priv_changeop_links",
            "to_column": "item_id",
            "condition": "functionalci.id = priv_changeop_links.item_id AND priv_changeop_links.item_class = 'FunctionalCI'",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed to generically reference items of various classes using the item_class and item_id fields. The functionalci table's primary key is id, and its default class name (as seen in the finalclass field) is 'FunctionalCI'. It is a common pattern in polymorphic association tables to use both a class/type field and an id to reference records in other tables. Therefore, it is reasonable to infer that priv_changeop_links records with item_class = 'FunctionalCI' and item_id = functionalci.id are referencing functionalci records.",
            "test_sql": "SELECT COUNT(*) FROM functionalci t1 JOIN priv_changeop_links t2 ON t1.id = t2.item_id AND t2.item_class = 'FunctionalCI' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 9,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "functionalci",
            "from_column": "org_id",
            "to_table": "sla",
            "to_column": "org_id",
            "condition": "functionalci.org_id = sla.org_id",
            "confidence": "high",
            "reasoning": "Both tables contain an 'org_id' field of type int, which likely references the same organization entity. While there is no explicit foreign key, it is common in business and ITSM domains for both configuration items and SLAs to be associated with an organization. This join would allow analysis of which CIs are covered by which SLAs at the organizational level. However, this is a broad relationship and does not directly link a specific CI to a specific SLA.",
            "test_sql": "SELECT COUNT(*) FROM functionalci t1 JOIN sla t2 ON t1.org_id = t2.org_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 31,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "hypervisor",
            "from_column": "server_id",
            "to_table": "physicaldevice",
            "to_column": "id",
            "condition": "hypervisor.server_id = physicaldevice.id",
            "confidence": "high",
            "reasoning": "Both fields are of type int and likely represent a mapping between a hypervisor and the physical device (server) it runs on. The business logic suggests that a hypervisor instance is typically associated with a physical server, and the naming convention (server_id) in 'hypervisor' and 'id' in 'physicaldevice' supports this. However, there is no explicit foreign key or direct naming match, so the confidence is not high.",
            "test_sql": "SELECT COUNT(*) FROM hypervisor t1 JOIN physicaldevice t2 ON t1.server_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "hypervisor",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "objkey",
            "condition": "hypervisor.id = priv_changeop.objkey AND priv_changeop.objclass = 'hypervisor'",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass indicates the type of object being referenced and objkey is the object's primary key. Since 'hypervisor' is a table and 'id' is its primary key, it's likely that priv_changeop records with objclass = 'hypervisor' and objkey = hypervisor.id represent operations performed on hypervisor records. This is a common audit/change tracking pattern.",
            "test_sql": "SELECT COUNT(*) FROM hypervisor t1 JOIN priv_changeop t2 ON t1.id = t2.objkey AND t2.objclass = 'hypervisor' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "hypervisor",
            "from_column": "id",
            "to_table": "priv_changeop_links",
            "to_column": "item_id",
            "condition": "hypervisor.id = priv_changeop_links.item_id AND priv_changeop_links.item_class = 'hypervisor'",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed to generically reference items of various classes using the item_class and item_id fields. Since 'hypervisor' is a table/entity in the system, it is plausible that priv_changeop_links could reference hypervisor records by setting item_class = 'hypervisor' and item_id = hypervisor.id. This is a common polymorphic association pattern for tracking changes or operations on different entity types.",
            "test_sql": "SELECT COUNT(*) FROM hypervisor t1 JOIN priv_changeop_links t2 ON t1.id = t2.item_id AND t2.item_class = 'hypervisor' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "lnkcustomercontracttoservice",
            "from_column": "service_id",
            "to_table": "servicesubcategory",
            "to_column": "service_id",
            "condition": "lnkcustomercontracttoservice.service_id = servicesubcategory.service_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'service_id' field of type int, which likely refers to the same conceptual 'service'. In 'lnkcustomercontracttoservice', 'service_id' links a contract to a service, while in 'servicesubcategory', 'service_id' associates a subcategory with its parent service. This suggests a logical relationship where you can find all subcategories for services linked to a contract, or vice versa. However, since there is no direct foreign key or unique constraint, and the relationship is not explicitly defined, the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM lnkcustomercontracttoservice t1 JOIN servicesubcategory t2 ON t1.service_id = t2.service_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 17,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "lnkcustomercontracttoservice",
            "from_column": "sla_id",
            "to_table": "slt",
            "to_column": "id",
            "condition": "lnkcustomercontracttoservice.sla_id = slt.id",
            "confidence": "high",
            "reasoning": "The 'sla_id' field in 'lnkcustomercontracttoservice' likely refers to a service level agreement or target. The 'slt' table contains service level targets, and its primary key is 'id'. While there is no explicit foreign key, the naming and business logic suggest that 'sla_id' could reference 'slt.id' to specify which service level target applies to a given contract-service link.",
            "test_sql": "SELECT COUNT(*) FROM lnkcustomercontracttoservice t1 JOIN slt t2 ON t1.sla_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "lnkdeliverymodeltocontact",
            "from_column": "deliverymodel_id",
            "to_table": "organization",
            "to_column": "deliverymodel_id",
            "condition": "lnkdeliverymodeltocontact.deliverymodel_id = organization.deliverymodel_id",
            "confidence": "high",
            "reasoning": "Both tables contain a field named 'deliverymodel_id' of type int. In 'lnkdeliverymodeltocontact', this field links a contact to a delivery model, while in 'organization', it associates an organization with a delivery model. This suggests a possible business logic relationship where you may want to find all contacts linked to delivery models that are also associated with specific organizations. However, since 'deliverymodel_id' is not a primary key in either table and there is no explicit foreign key, the relationship is inferred based on naming and business context.",
            "test_sql": "SELECT COUNT(*) FROM lnkdeliverymodeltocontact t1 JOIN organization t2 ON t1.deliverymodel_id = t2.deliverymodel_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "lnkslatoslt",
            "from_column": "id",
            "to_table": "priv_changeop_links_tune",
            "to_column": "link_id",
            "condition": "lnkslatoslt.id = priv_changeop_links_tune.link_id",
            "confidence": "high",
            "reasoning": "The field priv_changeop_links_tune.link_id is an integer and could logically reference the primary key lnkslatoslt.id, as 'link_id' often refers to a linking table's identifier. This would allow priv_changeop_links_tune to associate change operations with specific link records in lnkslatoslt. However, there is no explicit foreign key or naming convention that guarantees this relationship, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM lnkslatoslt t1 JOIN priv_changeop_links_tune t2 ON t1.id = t2.link_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "location",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "objkey",
            "condition": "location.id = priv_changeop.objkey AND priv_changeop.objclass = 'location'",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass indicates the type of object being referenced and objkey stores the object's primary key. Since 'location' is a table with an 'id' primary key, it is likely that priv_changeop records with objclass = 'location' and objkey = location.id represent operations performed on location records. This is a common design for change tracking/auditing tables.",
            "test_sql": "SELECT COUNT(*) FROM location t1 JOIN priv_changeop t2 ON t1.id = t2.objkey AND t2.objclass = 'location' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 10,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "location",
            "from_column": "org_id",
            "to_table": "sla",
            "to_column": "org_id",
            "condition": "location.org_id = sla.org_id",
            "confidence": "high",
            "reasoning": "Both tables contain an 'org_id' field of type int, which likely refers to the same organizational entity. This suggests that locations and SLAs can be associated with the same organization, enabling queries such as 'which SLAs apply to the organization that owns this location?' However, there is no explicit foreign key constraint, and the business logic does not directly tie a location to a specific SLA, only to the organization. Thus, the relationship is inferred based on naming conventions, data type compatibility, and common design patterns.",
            "test_sql": "SELECT COUNT(*) FROM location t1 JOIN sla t2 ON t1.org_id = t2.org_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "model",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "objkey",
            "condition": "model.id = priv_changeop.objkey AND priv_changeop.objclass = 'model'",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass indicates the type of object being referenced and objkey is the object's primary key. Since 'model' is a table name and 'id' is its primary key, it is likely that priv_changeop records with objclass = 'model' and objkey = model.id represent operations performed on model records. This is a common design for change tracking/auditing tables.",
            "test_sql": "SELECT COUNT(*) FROM model t1 JOIN priv_changeop t2 ON t1.id = t2.objkey WHERE t2.objclass = 'model' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "networkdevice",
            "from_column": "id",
            "to_table": "priv_changeop_links",
            "to_column": "item_id",
            "condition": "networkdevice.id = priv_changeop_links.item_id AND priv_changeop_links.item_class = 'networkdevice'",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed for polymorphic associations, where item_class specifies the type of entity and item_id is the entity's primary key. Since networkdevice has an 'id' field and priv_changeop_links has an 'item_id' field, and given the business purpose of tracking changes to various items, it is reasonable to infer that priv_changeop_links could reference networkdevice records when item_class = 'networkdevice'. This is a common pattern for generic change tracking or audit tables.",
            "test_sql": "SELECT COUNT(*) FROM networkdevice t1 JOIN priv_changeop_links t2 ON t1.id = t2.item_id WHERE t2.item_class = 'networkdevice' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "networkdevice",
            "from_column": "iosversion_id",
            "to_table": "server",
            "to_column": "osversion_id",
            "condition": "networkdevice.iosversion_id = server.osversion_id",
            "confidence": "high",
            "reasoning": "Both tables have a field representing an operating system version ID (iosversion_id in networkdevice and osversion_id in server). The naming is not identical, but both refer to an OS version, and the data type (int) matches. In some organizations, network devices and servers may share a common OS version reference table, making this a plausible join for reporting or inventory purposes.",
            "test_sql": "SELECT COUNT(*) FROM networkdevice t1 JOIN server t2 ON t1.iosversion_id = t2.osversion_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "organization",
            "from_column": "id",
            "to_table": "physicaldevice",
            "to_column": "location_id",
            "condition": "organization.id = physicaldevice.location_id",
            "confidence": "high",
            "reasoning": "The 'physicaldevice' table has a 'location_id' field of type int, which could logically reference the 'organization' table's 'id' field if organizational units are used to represent physical locations (such as branches, departments, or sites). This is a common pattern in asset management systems, where devices are assigned to organizational units that also serve as locations. However, the field name 'location_id' does not directly match 'organization', so this is an inferred relationship based on business logic and data type compatibility.",
            "test_sql": "SELECT COUNT(*) FROM organization t1 JOIN physicaldevice t2 ON t1.id = t2.location_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "organization",
            "from_column": "id",
            "to_table": "priv_changeop_links",
            "to_column": "item_id",
            "condition": "organization.id = priv_changeop_links.item_id AND priv_changeop_links.item_class = 'organization'",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed for polymorphic associations, where item_class specifies the type of entity and item_id is the entity's primary key. Since organization.id is the primary key of the organization table, and item_id is an int, it is plausible that priv_changeop_links can reference organizations when item_class = 'organization'. This is a common pattern for generic change tracking or auditing tables.",
            "test_sql": "SELECT COUNT(*) FROM organization t1 JOIN priv_changeop_links t2 ON t1.id = t2.item_id WHERE t2.item_class = 'organization' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "organization",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "objkey",
            "condition": "organization.id = priv_changeop.objkey AND priv_changeop.objclass = 'organization'",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass indicates the type of object being referenced and objkey is the primary key of that object. Since organization.id is the primary key of the organization table, and priv_changeop.objclass could contain the value 'organization', it is reasonable to infer that priv_changeop records with objclass = 'organization' and objkey = organization.id represent operations performed on organization records.",
            "test_sql": "SELECT COUNT(*) FROM organization t1 JOIN priv_changeop t2 ON t1.id = t2.objkey WHERE t2.objclass = 'organization' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "osversion",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "objkey",
            "condition": "osversion.id = priv_changeop.objkey AND priv_changeop.objclass = 'osversion'",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass indicates the type of object being referenced and objkey is the ID of that object. Since 'osversion' is a table name and objclass is a varchar field, it's plausible that changes to osversion records are tracked in priv_changeop with objclass = 'osversion' and objkey = osversion.id. This is a common pattern for audit/change tracking tables.",
            "test_sql": "SELECT COUNT(*) FROM osversion t1 JOIN priv_changeop t2 ON t1.id = t2.objkey AND t2.objclass = 'osversion' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "person",
            "from_column": "location_id",
            "to_table": "physicaldevice",
            "to_column": "location_id",
            "condition": "person.location_id = physicaldevice.location_id",
            "confidence": "high",
            "reasoning": "Both tables contain a 'location_id' field of type int, which likely refers to the same conceptual entity: a physical or organizational location. This suggests that persons and devices can be associated with the same location, enabling queries such as 'which devices are at the same location as a given person.' However, since the actual 'location' table is not provided and there is no explicit foreign key, the relationship is inferred based on naming convention and business logic.",
            "test_sql": "SELECT COUNT(*) FROM person t1 JOIN physicaldevice t2 ON t1.location_id = t2.location_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 68,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "person",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "objkey",
            "condition": "person.id = priv_changeop.objkey AND priv_changeop.objclass = 'person'",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic reference pattern with objclass and objkey to point to objects in the system. Since 'person' is a core entity and objkey is an int (matching person.id), it's plausible that priv_changeop records changes to person records by setting objclass to 'person' and objkey to the person's id. However, this is inferred from naming and common design patterns, as there is no explicit foreign key or constraint.",
            "test_sql": "SELECT COUNT(*) FROM person t1 JOIN priv_changeop t2 ON t1.id = t2.objkey WHERE t2.objclass = 'person' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 42,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "person",
            "from_column": "id",
            "to_table": "priv_changeop_links",
            "to_column": "item_id",
            "condition": "person.id = priv_changeop_links.item_id AND priv_changeop_links.item_class = 'person'",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed for polymorphic associations, where item_class specifies the type of entity and item_id is the entity's primary key. Since person.id is the primary key of the person table and item_id is an int, it is plausible that priv_changeop_links could reference person records when item_class = 'person'. This is a common pattern for generic change tracking or auditing tables.",
            "test_sql": "SELECT COUNT(*) FROM person t1 JOIN priv_changeop_links t2 ON t1.id = t2.item_id WHERE t2.item_class = 'person' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 11,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "person",
            "from_column": "id",
            "to_table": "priv_internaluser",
            "to_column": "id",
            "condition": "person.id = priv_internaluser.id",
            "confidence": "high",
            "reasoning": "Both tables use an 'id' field as their primary key, and both represent entities related to people within an organization. It is common in database design for an 'internal user' or authentication table to reference the main person/entity table via a shared or foreign key. However, there is no explicit foreign key constraint or naming convention directly linking these tables, so this relationship is inferred based on typical business logic and schema patterns.",
            "test_sql": "SELECT COUNT(*) FROM person t1 JOIN priv_internaluser t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "person",
            "from_column": "id",
            "to_table": "priv_urp_userprofile",
            "to_column": "userid",
            "condition": "person.id = priv_urp_userprofile.userid",
            "confidence": "high",
            "reasoning": "The 'userid' field in 'priv_urp_userprofile' is an integer and likely references a user entity. The 'person' table's primary key is 'id', which is also an integer and represents individuals in the system. Given naming conventions and typical database design, it is plausible that 'userid' refers to 'person.id', establishing a link between a person and their associated profiles.",
            "test_sql": "SELECT COUNT(*) FROM person t1 JOIN priv_urp_userprofile t2 ON t1.id = t2.userid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "person",
            "from_column": "id",
            "to_table": "priv_user_local",
            "to_column": "id",
            "condition": "person.id = priv_user_local.id",
            "confidence": "high",
            "reasoning": "Both tables use an 'id' field as their primary key, and the business purposes suggest that 'person' represents individuals while 'priv_user_local' stores authentication credentials. It is a common pattern to link a user's authentication record to their person record via a shared identifier. However, there is no explicit foreign key or naming convention that guarantees this relationship, so the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM person t1 JOIN priv_user_local t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "physicaldevice",
            "from_column": "id",
            "to_table": "softwareinstance",
            "to_column": "functionalci_id",
            "condition": "physicaldevice.id = softwareinstance.functionalci_id",
            "confidence": "high",
            "reasoning": "The 'softwareinstance' table has a 'functionalci_id' field, which is an integer and could represent the ID of a physical asset or configuration item where the software is installed. The 'physicaldevice' table's primary key is 'id', which uniquely identifies each device. Given the business purposestracking software installations on physical devicesit's plausible that 'functionalci_id' in 'softwareinstance' refers to 'id' in 'physicaldevice'. However, the naming is not an exact match, so the confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM physicaldevice t1 JOIN softwareinstance t2 ON t1.id = t2.functionalci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_app_preferences",
            "from_column": "userid",
            "to_table": "priv_internaluser",
            "to_column": "id",
            "condition": "priv_app_preferences.userid = priv_internaluser.id",
            "confidence": "high",
            "reasoning": "The 'userid' field in 'priv_app_preferences' and the 'id' field in 'priv_internaluser' are both of type int and likely represent user identifiers. The naming convention suggests that 'userid' could reference the primary key 'id' of 'priv_internaluser', especially since 'priv_internaluser' appears to store internal user accounts and 'priv_app_preferences' stores preferences for users. However, there is no explicit foreign key constraint, and 'userid' is nullable and defaults to 0, which slightly lowers confidence.",
            "test_sql": "SELECT COUNT(*) FROM priv_app_preferences t1 JOIN priv_internaluser t2 ON t1.userid = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_app_preferences",
            "from_column": "userid",
            "to_table": "priv_urp_userprofile",
            "to_column": "userid",
            "condition": "priv_app_preferences.userid = priv_urp_userprofile.userid",
            "confidence": "high",
            "reasoning": "Both tables contain a 'userid' field of the same data type (int), and both are used to associate records with a user or entity. It is common in database design for user preferences and user-profile associations to be linked by a shared user identifier. While there is no explicit foreign key, the naming convention and business purposes suggest that 'userid' in both tables likely refers to the same conceptual entity, enabling a logical join to retrieve preferences for users with specific profile associations.",
            "test_sql": "SELECT COUNT(*) FROM priv_app_preferences t1 JOIN priv_urp_userprofile t2 ON t1.userid = t2.userid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_app_preferences",
            "from_column": "userid",
            "to_table": "priv_user_local",
            "to_column": "id",
            "condition": "priv_app_preferences.userid = priv_user_local.id",
            "confidence": "high",
            "reasoning": "The 'userid' field in 'priv_app_preferences' and the 'id' field in 'priv_user_local' share compatible data types (int) and naming conventions, suggesting that 'userid' may reference the primary key of 'priv_user_local'. This would allow application preferences to be associated with user authentication records. However, there is no explicit foreign key constraint, and the business purposes are related but not definitively linked, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM priv_app_preferences t1 JOIN priv_user_local t2 ON t1.userid = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "id",
            "to_table": "priv_changeop_links_addremove",
            "to_column": "id",
            "condition": "priv_changeop.id = priv_changeop_links_addremove.id",
            "confidence": "high",
            "reasoning": "Both tables have a primary key column named 'id' of type int. While 'id' is a common field name and often used as a primary key, there is no explicit foreign key or naming convention directly linking these tables. However, given the business purposeswhere priv_changeop logs change operations and priv_changeop_links_addremove logs link add/remove eventsit is plausible that priv_changeop_links_addremove could use the same 'id' value to reference a specific change operation. This would be a common pattern if each link add/remove event is directly associated with a specific change operation. The confidence is not high because there is no explicit foreign key or supporting field, but the possibility exists based on naming and business logic.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN priv_changeop_links_addremove t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 113,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "optype",
            "to_table": "priv_changeop_setatt",
            "to_column": "optype",
            "condition": "priv_changeop.optype = priv_changeop_setatt.optype",
            "confidence": "high",
            "reasoning": "Both tables have an 'optype' column of the same data type and similar naming, suggesting that 'priv_changeop_setatt' may define or configure attribute-level details for specific operation types logged in 'priv_changeop'. This is a common pattern where a log or event table references a configuration or mapping table by operation type. However, there is no explicit foreign key, and the business logic connection is inferred from naming and purpose.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN priv_changeop_setatt t2 ON t1.optype = t2.optype LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 12774,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "objclass",
            "to_table": "priv_changeop_links",
            "to_column": "item_class",
            "condition": "priv_changeop.objclass = priv_changeop_links.item_class AND priv_changeop.objkey = priv_changeop_links.item_id",
            "confidence": "high",
            "reasoning": "Both tables use a polymorphic pattern to reference objects/entities: priv_changeop uses (objclass, objkey) and priv_changeop_links uses (item_class, item_id). The naming and data types are compatible, and both serve to track operations on various object types. This suggests that a logical relationship may exist where a change operation (priv_changeop) is associated with a specific item (priv_changeop_links) if they reference the same object class and key/id. However, there is no explicit foreign key or unique constraint, so the relationship is inferred based on naming, structure, and business purpose.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN priv_changeop_links t2 ON t1.objclass = t2.item_class AND t1.objkey = t2.item_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 243,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "id",
            "to_table": "priv_changeop_setatt_scalar",
            "to_column": "id",
            "condition": "priv_changeop.id = priv_changeop_setatt_scalar.id",
            "confidence": "high",
            "reasoning": "Both tables share a column named 'id' of type int, which is the primary key in both tables. In common audit/change tracking patterns, a detail table (priv_changeop_setatt_scalar) often references the parent operation (priv_changeop) via a foreign key. However, the lack of an explicit foreign key and the use of 'id' as a primary key in both tables (rather than 'priv_changeop_id' in the detail table) reduces confidence. Still, the naming and business logic suggest that priv_changeop_setatt_scalar could be a 1:1 or 1:0..1 extension of priv_changeop, storing attribute-level changes for a specific operation.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN priv_changeop_setatt_scalar t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "objkey",
            "to_table": "server",
            "to_column": "id",
            "condition": "priv_changeop.objclass = 'Server' AND priv_changeop.objkey = server.id",
            "confidence": "high",
            "reasoning": "The priv_changeop table is designed to track changes to various object types using a polymorphic association (objclass, objkey). If objclass stores the string 'Server', then objkey would logically reference the id of a server in the server table. This is a common pattern for tracking changes to multiple entity types in a CMDB or asset management system. However, this relationship is inferred from naming conventions and business logic, as there are no explicit foreign keys or constraints.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN server t2 ON t1.objclass = 'Server' AND t1.objkey = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "objclass/objkey",
            "to_table": "service",
            "to_column": "id",
            "condition": "priv_changeop.objclass = 'Service' AND priv_changeop.objkey = service.id",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern with objclass and objkey to reference various object types. Given the business purpose of tracking changes to system entities, and the presence of a 'service' table representing a key entity, it is plausible that some priv_changeop records log changes to services. The objclass field would likely contain the string 'Service' to indicate the type, and objkey would store the corresponding service.id. This is a common pattern in audit/change tracking systems.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN service t2 ON t1.objclass = 'Service' AND t1.objkey = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 23,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "objkey",
            "to_table": "rack",
            "to_column": "id",
            "condition": "priv_changeop.objclass = 'rack' AND priv_changeop.objkey = rack.id",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern with objclass and objkey to reference various objects. If objclass is set to 'rack', then objkey likely refers to the id of a rack. This is a common design for tracking changes to multiple entity types in a single audit table.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN rack t2 ON t1.objclass = 'rack' AND t1.objkey = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "objclass",
            "to_table": "software",
            "to_column": "id",
            "condition": "priv_changeop.objclass = 'software' AND priv_changeop.objkey = software.id",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass indicates the type of object being referenced and objkey is the object's primary key. If objclass = 'software', then objkey likely refers to software.id. This is a common pattern for tracking changes to multiple entity types in a single audit table.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN software t2 ON t1.objclass = 'software' AND t1.objkey = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "objclass, objkey",
            "to_table": "virtualdevice",
            "to_column": "finalclass, id",
            "condition": "priv_changeop.objclass = virtualdevice.finalclass AND priv_changeop.objkey = virtualdevice.id",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass (string) and objkey (int) together reference an object in another table. The virtualdevice table has a finalclass (string) and id (int) that could match this pattern. This suggests that some priv_changeop records may log operations performed on virtualdevice records, with objclass = finalclass (e.g., 'VirtualDevice') and objkey = id. However, this is not enforced by a foreign key and depends on application logic, so confidence is medium.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN virtualdevice t2 ON t1.objclass = t2.finalclass AND t1.objkey = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 19,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "objclass",
            "to_table": "webapplication",
            "to_column": "id",
            "condition": "priv_changeop.objclass = 'webapplication' AND priv_changeop.objkey = webapplication.id",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern, where objclass indicates the type of object being referenced and objkey is the object's ID. If objclass is set to 'webapplication', then objkey would logically reference the id of the webapplication table. This is a common pattern for tracking changes to multiple entity types in a single audit table.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN webapplication t2 ON t1.objclass = 'webapplication' AND t1.objkey = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 5,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "objkey",
            "to_table": "virtualmachine",
            "to_column": "id",
            "condition": "priv_changeop.objkey = virtualmachine.id AND priv_changeop.objclass = 'virtualmachine'",
            "confidence": "high",
            "reasoning": "The priv_changeop table uses a polymorphic association pattern with objclass and objkey to reference various objects. Given the business purpose of tracking changes to system entities and the presence of a virtualmachine table, it is reasonable to infer that when objclass = 'virtualmachine', objkey refers to the id of a virtualmachine record. This is a common design for audit/change tracking tables.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN virtualmachine t2 ON t1.objkey = t2.id WHERE t1.objclass = 'virtualmachine' LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 7,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop_links",
            "from_column": "id",
            "to_table": "priv_changeop_links_addremove",
            "to_column": "id",
            "condition": "priv_changeop_links.id = priv_changeop_links_addremove.id",
            "confidence": "high",
            "reasoning": "Both tables share a primary key column named 'id' of type int. While there is no explicit foreign key, it is common in audit or change tracking systems for a detail or status table (such as priv_changeop_links_addremove) to reference the main change operation record (priv_changeop_links) by sharing the same id. The business purposes are compatible: priv_changeop_links records the operation, and priv_changeop_links_addremove records whether the link was added or removed for that operation. However, without explicit documentation or foreign key constraints, this relationship is inferred based on naming, data type, and business logic.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop_links t1 JOIN priv_changeop_links_addremove t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 113,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop_links",
            "from_column": "optype",
            "to_table": "priv_changeop_setatt",
            "to_column": "optype",
            "condition": "priv_changeop_links.optype = priv_changeop_setatt.optype",
            "confidence": "high",
            "reasoning": "Both tables have an 'optype' column with similar naming and data type (varchar(255)), and both default to a value starting with 'CMDBChangeOpSetAttribute'. This suggests that 'optype' represents the type of change operation and could be used to associate records in 'priv_changeop_links' (which logs operations on items) with records in 'priv_changeop_setatt' (which defines which attributes can be set for a given operation type). This is a common business logic pattern where operation logs reference operation definitions.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop_links t1 JOIN priv_changeop_setatt t2 ON t1.optype = t2.optype LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 12770,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop_links",
            "from_column": "item_id",
            "to_table": "service",
            "to_column": "id",
            "condition": "priv_changeop_links.item_class = 'Service' AND priv_changeop_links.item_id = service.id",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed for polymorphic associations, where item_class indicates the type of entity being referenced and item_id is the corresponding entity's primary key. Since the service table's primary key is id, and 'Service' is a plausible value for item_class, it is likely that priv_changeop_links can reference service records in this way. This is a common pattern for tracking changes to various entity types in a generic way.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop_links t1 JOIN service t2 ON t1.item_class = 'Service' AND t1.item_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop_links",
            "from_column": "item_id",
            "to_table": "rack",
            "to_column": "id",
            "condition": "priv_changeop_links.item_class = 'rack' AND priv_changeop_links.item_id = rack.id",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed for polymorphic associations, where item_class specifies the type of entity and item_id is the corresponding entity's ID. Since rack.id is the primary key of the rack table, and 'rack' could be a possible value for item_class, it is reasonable to infer that priv_changeop_links can reference racks in this way. However, this is not enforced by a foreign key and depends on the actual values in item_class.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop_links t1 JOIN rack t2 ON t1.item_class = 'rack' AND t1.item_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop_links",
            "from_column": "item_id",
            "to_table": "server",
            "to_column": "id",
            "condition": "priv_changeop_links.item_class = 'server' AND priv_changeop_links.item_id = server.id",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed for polymorphic associations, where item_class indicates the type of entity being referenced and item_id is the corresponding entity's primary key. Since the server table's primary key is id, and 'server' is a plausible value for item_class, it is likely that priv_changeop_links can reference server records in this way. This is a common pattern for generic change tracking or audit tables.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop_links t1 JOIN server t2 ON t1.item_class = 'server' AND t1.item_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop_links",
            "from_column": "item_id",
            "to_table": "servicesubcategory",
            "to_column": "id",
            "condition": "priv_changeop_links.item_class = 'servicesubcategory' AND priv_changeop_links.item_id = servicesubcategory.id",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed for polymorphic associations, where item_class indicates the type of entity being referenced and item_id is the corresponding primary key. Since servicesubcategory has a primary key id, and the business purpose of priv_changeop_links is to track changes to various items, it is plausible that some records in priv_changeop_links track changes to servicesubcategory records, using item_class = 'servicesubcategory' and item_id = servicesubcategory.id.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop_links t1 JOIN servicesubcategory t2 ON t1.item_class = 'servicesubcategory' AND t1.item_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 17,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop_links",
            "from_column": "item_id",
            "to_table": "virtualmachine",
            "to_column": "id",
            "condition": "priv_changeop_links.item_class = 'virtualmachine' AND priv_changeop_links.item_id = virtualmachine.id",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed for polymorphic associations, tracking changes to various item types using the item_class and item_id fields. Given the business purpose and naming, it is likely that when item_class = 'virtualmachine', item_id refers to the id of a record in the virtualmachine table. This is a common pattern for generic change tracking or audit tables.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop_links t1 JOIN virtualmachine t2 ON t1.item_class = 'virtualmachine' AND t1.item_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop_links",
            "from_column": "item_id",
            "to_table": "webserver",
            "to_column": "id",
            "condition": "priv_changeop_links.item_class = 'webserver' AND priv_changeop_links.item_id = webserver.id",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed for polymorphic associations, where item_class specifies the type of entity and item_id is the corresponding entity's ID. Since webserver.id is the primary key of the webserver table, it is plausible that priv_changeop_links records with item_class = 'webserver' and item_id = webserver.id represent change operations performed on webserver entities.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop_links t1 JOIN webserver t2 ON t1.item_class = 'webserver' AND t1.item_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop_links",
            "from_column": "item_id",
            "to_table": "webapplication",
            "to_column": "id",
            "condition": "priv_changeop_links.item_class = 'webapplication' AND priv_changeop_links.item_id = webapplication.id",
            "confidence": "high",
            "reasoning": "The priv_changeop_links table is designed for polymorphic associations, where item_class indicates the type of entity being referenced and item_id is the corresponding entity's ID. Since webapplication has an id field and is a distinct entity, it is reasonable to infer that records in priv_changeop_links with item_class = 'webapplication' and item_id matching webapplication.id represent change operations performed on webapplication records.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop_links t1 JOIN webapplication t2 ON t1.item_class = 'webapplication' AND t1.item_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop_links_tune",
            "from_column": "link_id",
            "to_table": "priv_link_action_trigger",
            "to_column": "link_id",
            "condition": "priv_changeop_links_tune.link_id = priv_link_action_trigger.link_id",
            "confidence": "high",
            "reasoning": "Both tables contain a column named 'link_id' of type int. In priv_link_action_trigger, 'link_id' is the primary key and likely represents a unique link entity. In priv_changeop_links_tune, 'link_id' is a nullable int, possibly referencing a link elsewhere. The naming and data type match suggest a potential relationship where priv_changeop_links_tune references priv_link_action_trigger's link_id, possibly to associate change operations with specific action-trigger linkages. However, the absence of explicit foreign keys and the generic nature of 'link_id' reduce confidence to medium.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop_links_tune t1 JOIN priv_link_action_trigger t2 ON t1.link_id = t2.link_id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_internaluser",
            "from_column": "id",
            "to_table": "priv_urp_userprofile",
            "to_column": "userid",
            "condition": "priv_internaluser.id = priv_urp_userprofile.userid",
            "confidence": "high",
            "reasoning": "The 'userid' field in priv_urp_userprofile is an integer and is likely intended to reference a user entity. The only user-like table provided is priv_internaluser, which has an 'id' field of the same type. The naming convention ('userid') and data type compatibility suggest that priv_urp_userprofile.userid could reference priv_internaluser.id, forming a logical (though not explicitly defined) foreign key relationship. This is a common pattern for associating user profiles or permissions with user accounts.",
            "test_sql": "SELECT COUNT(*) FROM priv_internaluser t1 JOIN priv_urp_userprofile t2 ON t1.id = t2.userid LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_link_action_trigger",
            "from_column": "trigger_id",
            "to_table": "priv_trigger_onobject",
            "to_column": "id",
            "condition": "priv_link_action_trigger.trigger_id = priv_trigger_onobject.id",
            "confidence": "high",
            "reasoning": "The 'trigger_id' field in 'priv_link_action_trigger' and the 'id' field in 'priv_trigger_onobject' are both integers and likely represent a logical connection: 'priv_link_action_trigger' appears to map actions to triggers, and 'priv_trigger_onobject' defines triggers. The naming convention and data types are compatible, and this is a common pattern for linking tables to their referenced entities. However, the absence of an explicit foreign key constraint and the default value of 0 for 'trigger_id' slightly reduce confidence.",
            "test_sql": "SELECT COUNT(*) FROM priv_link_action_trigger t1 JOIN priv_trigger_onobject t2 ON t1.trigger_id = t2.id LIMIT 1",
            "relationship_type": "foreign_key",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_query",
            "from_column": "id",
            "to_table": "priv_query_oql",
            "to_column": "id",
            "condition": "priv_query.id = priv_query_oql.id",
            "confidence": "high",
            "reasoning": "Both tables use an 'id' column as their primary key, and the business purposes are closely related: 'priv_query' stores metadata about queries, while 'priv_query_oql' stores the OQL and fields for queries. It is a common design pattern to split metadata and query logic into separate tables, linking them via a shared primary key. However, there is no explicit foreign key constraint, and the schemas do not guarantee that the 'id' values are synchronized. The relationship is plausible if the application logic ensures a 1:1 mapping between the two tables.",
            "test_sql": "SELECT COUNT(*) FROM priv_query t1 JOIN priv_query_oql t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 13,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_trigger",
            "from_column": "realclass",
            "to_table": "priv_trigger_onobject",
            "to_column": "realclass",
            "condition": "priv_trigger.realclass = priv_trigger_onobject.realclass",
            "confidence": "high",
            "reasoning": "Both tables have a 'realclass' column with similar naming and default values ('Trigger' and 'TriggerOnObject'), suggesting a possible logical or polymorphic relationship. This could indicate that 'priv_trigger_onobject' is a specialized type of trigger defined in 'priv_trigger', or that both reference a common trigger class/type. However, there is no explicit foreign key or unique constraint, so this is inferred based on naming and business logic.",
            "test_sql": "SELECT COUNT(*) FROM priv_trigger t1 JOIN priv_trigger_onobject t2 ON t1.realclass = t2.realclass LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_urp_userprofile",
            "from_column": "userid",
            "to_table": "priv_user_local",
            "to_column": "id",
            "condition": "priv_urp_userprofile.userid = priv_user_local.id",
            "confidence": "high",
            "reasoning": "The 'userid' field in 'priv_urp_userprofile' and the 'id' field in 'priv_user_local' are both of type int and likely represent user identifiers. The naming convention ('userid' vs 'id') and the business logic (user-profile mapping vs user authentication) suggest that 'userid' could reference the primary key 'id' in 'priv_user_local', establishing a logical link between user authentication data and user-profile associations. However, this is not explicitly enforced by a foreign key constraint, and the relationship is inferred based on naming and typical database design patterns.",
            "test_sql": "SELECT COUNT(*) FROM priv_urp_userprofile t1 JOIN priv_user_local t2 ON t1.userid = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "server",
            "from_column": "id",
            "to_table": "softwareinstance",
            "to_column": "functionalci_id",
            "condition": "server.id = softwareinstance.functionalci_id",
            "confidence": "high",
            "reasoning": "The 'softwareinstance' table tracks software deployments and includes a 'functionalci_id' field, which, by naming convention and business logic, could represent the configuration item (CI) where the software is installed. In the absence of a dedicated configuration item table, and given the business context, it is plausible that 'server.id' serves as the CI identifier for servers. Both fields are of type 'int', and this pattern is common in IT asset management databases.",
            "test_sql": "SELECT COUNT(*) FROM server t1 JOIN softwareinstance t2 ON t1.id = t2.functionalci_id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "server",
            "from_column": "osfamily_id",
            "to_table": "virtualmachine",
            "to_column": "osfamily_id",
            "condition": "server.osfamily_id = virtualmachine.osfamily_id",
            "confidence": "high",
            "reasoning": "Both tables use the field 'osfamily_id' to reference the operating system family. While this does not directly link a specific server to a specific virtual machine, it allows for grouping or joining records that share the same OS family. This is a logical relationship based on shared configuration attributes.",
            "test_sql": "SELECT COUNT(*) FROM server t1 JOIN virtualmachine t2 ON t1.osfamily_id = t2.osfamily_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "server",
            "from_column": "osversion_id",
            "to_table": "virtualmachine",
            "to_column": "osversion_id",
            "condition": "server.osversion_id = virtualmachine.osversion_id",
            "confidence": "high",
            "reasoning": "Both tables have an 'osversion_id' field, likely referencing the same set of OS versions. This enables analysis or reporting on servers and virtual machines running the same OS version. This is a logical relationship, not a direct foreign key.",
            "test_sql": "SELECT COUNT(*) FROM server t1 JOIN virtualmachine t2 ON t1.osversion_id = t2.osversion_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "server",
            "from_column": "oslicence_id",
            "to_table": "virtualmachine",
            "to_column": "oslicence_id",
            "condition": "server.oslicence_id = virtualmachine.oslicence_id",
            "confidence": "high",
            "reasoning": "Both tables use 'oslicence_id', which likely references the same OS license pool. This allows for joining records to analyze license usage across both physical servers and virtual machines. This is a logical relationship.",
            "test_sql": "SELECT COUNT(*) FROM server t1 JOIN virtualmachine t2 ON t1.oslicence_id = t2.oslicence_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "servicesubcategory",
            "from_column": "request_type",
            "to_table": "slt",
            "to_column": "request_type",
            "condition": "servicesubcategory.request_type = slt.request_type",
            "confidence": "high",
            "reasoning": "Both tables have a 'request_type' field with identical ENUM values ('incident', 'service_request'). This suggests that service subcategories and SLTs are both classified by the type of request, and it is likely that business logic would require joining these tables to determine which SLTs apply to which subcategories based on request type. However, this is not a strict foreign key relationship, as there is no unique constraint or explicit reference.",
            "test_sql": "SELECT COUNT(*) FROM servicesubcategory t1 JOIN slt t2 ON t1.request_type = t2.request_type LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 10,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "softwareinstance",
            "from_column": "functionalci_id",
            "to_table": "virtualmachine",
            "to_column": "id",
            "condition": "softwareinstance.functionalci_id = virtualmachine.id",
            "confidence": "high",
            "reasoning": "The 'functionalci_id' in 'softwareinstance' is likely intended to reference a configuration item representing the environment or asset where the software is installed. In the absence of a dedicated configuration item table, and given the business context, it is plausible that a software instance could be installed on a virtual machine, with 'functionalci_id' pointing to the 'id' of a 'virtualmachine'. Both fields are of type int, and this pattern is common in IT asset management systems.",
            "test_sql": "SELECT COUNT(*) FROM softwareinstance t1 JOIN virtualmachine t2 ON t1.functionalci_id = t2.id LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 3,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "connectableci",
            "from_column": "finalclass",
            "to_table": "datacenterdevice",
            "to_column": "finalclass",
            "condition": "connectableci.finalclass = datacenterdevice.finalclass",
            "confidence": "high",
            "reasoning": "Both tables have a 'finalclass' column of type varchar(255), which appears to be used for polymorphic or inheritance purposes. While this could be used to filter or join records of the same class/type, it is not a unique or identifying field and is unlikely to serve as a true relational key. This join would only be meaningful for statistical or reporting purposes, not for enforcing referential integrity.",
            "test_sql": "SELECT COUNT(*) FROM connectableci t1 JOIN datacenterdevice t2 ON t1.finalclass = t2.finalclass LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 20,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "connectableci",
            "from_column": "id",
            "to_table": "functionalci",
            "to_column": "id",
            "condition": "connectableci.id = functionalci.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field as their primary key, but there is no explicit foreign key or naming convention indicating a direct relationship. The matching data types and the use of 'finalclass' in both tables suggest a possible inheritance or polymorphic pattern, but without further evidence, this is speculative. In some database designs, a base table (connectableci) and a derived table (functionalci) may share the same primary key value to represent the same entity in an inheritance hierarchy (single-table or class-table inheritance). However, this is not confirmed by the schema alone.",
            "test_sql": "SELECT COUNT(*) FROM connectableci t1 JOIN functionalci t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "connectableci",
            "from_column": "finalclass",
            "to_table": "functionalci",
            "to_column": "finalclass",
            "condition": "connectableci.finalclass = functionalci.finalclass",
            "confidence": "high",
            "reasoning": "Both tables have a 'finalclass' field, which appears to be used for polymorphic or inheritance purposes. While this could be used to filter or join records of the same class/type, it is not a unique or identifying relationship and does not establish a parent-child or foreign key relationship. It may be useful for reporting or filtering, but not as a structural join.",
            "test_sql": "SELECT COUNT(*) FROM connectableci t1 JOIN functionalci t2 ON t1.finalclass = t2.finalclass LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 20,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "connectableci",
            "from_column": "id",
            "to_table": "networkdevice",
            "to_column": "id",
            "condition": "connectableci.id = networkdevice.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field of type int and both are primary keys, but there is no explicit foreign key or naming convention indicating a direct relationship. In some polymorphic or inheritance-based designs, a child table (e.g., networkdevice) may share the same primary key as the parent table (e.g., connectableci), but there is no evidence of this pattern here (such as a foreign key constraint or a 'connectableci_id' field in networkdevice). Therefore, this relationship is speculative and not strongly supported by the schema.",
            "test_sql": "SELECT COUNT(*) FROM connectableci t1 JOIN networkdevice t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "connectableci",
            "from_column": "finalclass",
            "to_table": "physicaldevice",
            "to_column": "finalclass",
            "condition": "connectableci.finalclass = physicaldevice.finalclass",
            "confidence": "high",
            "reasoning": "Both tables have a 'finalclass' column of type varchar(255), with default values indicating their respective class names. This field is likely used for polymorphic behavior or type identification, not as a relational key. While a join on this field is technically possible, it is unlikely to represent a meaningful business relationship, as the values are probably static and used for classification rather than linking records.",
            "test_sql": "SELECT COUNT(*) FROM connectableci t1 JOIN physicaldevice t2 ON t1.finalclass = t2.finalclass LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 20,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "connectableci",
            "from_column": "id",
            "to_table": "priv_changeop_links_tune",
            "to_column": "link_id",
            "condition": "connectableci.id = priv_changeop_links_tune.link_id",
            "confidence": "high",
            "reasoning": "The only possible relationship based on field names and data types is that 'link_id' in 'priv_changeop_links_tune' could reference the 'id' in 'connectableci'. Both are integers, and 'link_id' may represent a connection to a configuration item. However, there is no explicit foreign key, naming is generic, and the business purposes do not clearly overlap. This is a speculative relationship based solely on compatible field types and a plausible business scenario where a 'link' could refer to a 'connectable' item.",
            "test_sql": "SELECT COUNT(*) FROM connectableci t1 JOIN priv_changeop_links_tune t2 ON t1.id = t2.link_id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contact",
            "from_column": "email",
            "to_table": "priv_action_email",
            "to_column": "to",
            "condition": "contact.email = priv_action_email.to",
            "confidence": "high",
            "reasoning": "Both tables contain email-related fields, but 'contact.email' is a single email address (varchar), while 'priv_action_email.to' is a text field that may contain one or more email addresses (possibly comma-separated). There is no explicit foreign key or clear naming convention linking these fields, and the data types and intended usage differ. However, in some business logic scenarios, emails may be sent to contacts, and thus a loose relationship could be inferred by matching contact emails to recipient addresses in outgoing emails.",
            "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN priv_action_email t2 ON t2.to LIKE CONCAT('%', t1.email, '%') LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contact",
            "from_column": "phone",
            "to_table": "person",
            "to_column": "mobile_phone",
            "condition": "contact.phone = person.mobile_phone",
            "confidence": "high",
            "reasoning": "Both tables have fields for phone numbers ('contact.phone' and 'person.mobile_phone'). If the same individual exists in both tables, their phone numbers might match. However, phone numbers may be formatted differently, and there is no guarantee of uniqueness or consistency. This is a weak, statistical relationship.",
            "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN person t2 ON t1.phone = t2.mobile_phone LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1221,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contact",
            "from_column": "id",
            "to_table": "priv_urp_userprofile",
            "to_column": "userid",
            "condition": "contact.id = priv_urp_userprofile.userid",
            "confidence": "high",
            "reasoning": "Both 'contact.id' and 'priv_urp_userprofile.userid' are integer fields and could potentially represent a link between a contact and a user profile association. However, there is no explicit indication in the schema or business purpose that 'userid' refers to a contact. The naming convention ('userid' vs 'id') does not strongly suggest a direct relationship, and there is no foreign key constraint. This is a speculative relationship based solely on data type compatibility and a possible business logic overlap if contacts are also considered users.",
            "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN priv_urp_userprofile t2 ON t1.id = t2.userid LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "contract",
            "from_column": "id",
            "to_table": "customercontract",
            "to_column": "id",
            "condition": "contract.id = customercontract.id",
            "confidence": "high",
            "reasoning": "Both tables have a primary key column named 'id' of type int, but there is no explicit foreign key or business logic indicating that these IDs are related. The naming is generic and does not imply a direct relationship. Without additional context or supporting fields, this is likely a coincidence rather than a designed relationship.",
            "test_sql": "SELECT COUNT(*) FROM contract t1 JOIN customercontract t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "datacenterdevice",
            "from_column": "redundancy",
            "to_table": "farm",
            "to_column": "redundancy",
            "condition": "datacenterdevice.redundancy = farm.redundancy",
            "confidence": "high",
            "reasoning": "The only field with matching names and compatible data types is 'redundancy'. However, in both tables, 'redundancy' appears to be a categorical or configuration attribute rather than a unique identifier or foreign key. There is no clear business logic or schema evidence that directly links a device's redundancy setting to a farm's redundancy status. This join could be used for statistical or reporting purposes (e.g., grouping devices and farms by redundancy level), but it does not represent a true relational or foreign key relationship.",
            "test_sql": "SELECT COUNT(*) FROM datacenterdevice t1 JOIN farm t2 ON t1.redundancy = t2.redundancy LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 12,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "datacenterdevice",
            "from_column": "id",
            "to_table": "functionalci",
            "to_column": "id",
            "condition": "datacenterdevice.id = functionalci.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field as their primary key, but there is no evidence these IDs are related or share a common sequence. The business purposes are distinct: one is for physical devices, the other for functional configuration items. Unless there is an undocumented design where each device is also a configuration item with matching IDs, this relationship is unlikely.",
            "test_sql": "SELECT COUNT(*) FROM datacenterdevice t1 JOIN functionalci t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "datacenterdevice",
            "from_column": "finalclass",
            "to_table": "functionalci",
            "to_column": "finalclass",
            "condition": "datacenterdevice.finalclass = functionalci.finalclass",
            "confidence": "high",
            "reasoning": "Both tables have a 'finalclass' field, likely for polymorphic or inheritance purposes. However, these fields are used for internal classification and not as foreign keys. Matching on this field would only show records of the same class type, not a true relational join.",
            "test_sql": "SELECT COUNT(*) FROM datacenterdevice t1 JOIN functionalci t2 ON t1.finalclass = t2.finalclass LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 20,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "datacenterdevice",
            "from_column": "id",
            "to_table": "physicaldevice",
            "to_column": "id",
            "condition": "datacenterdevice.id = physicaldevice.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field as their primary key, but there is no evidence that these IDs are related or that one references the other. The IDs are likely auto-incremented independently in each table, so a direct relationship is unlikely.",
            "test_sql": "SELECT COUNT(*) FROM datacenterdevice t1 JOIN physicaldevice t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 6,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "datacenterdevice",
            "from_column": "managementip",
            "to_table": "physicaldevice",
            "to_column": "serialnumber",
            "condition": "datacenterdevice.managementip = physicaldevice.serialnumber",
            "confidence": "high",
            "reasoning": "While both fields are varchar and could theoretically store unique identifiers, 'managementip' is an IP address and 'serialnumber' is a hardware serial number. There is no logical or business reason to expect overlap.",
            "test_sql": "SELECT COUNT(*) FROM datacenterdevice t1 JOIN physicaldevice t2 ON t1.managementip = t2.serialnumber LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 30,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "datacenterdevice",
            "from_column": "finalclass",
            "to_table": "physicaldevice",
            "to_column": "finalclass",
            "condition": "datacenterdevice.finalclass = physicaldevice.finalclass",
            "confidence": "high",
            "reasoning": "Both tables have a 'finalclass' field, likely for polymorphic or inheritance purposes, but this is not a relational key and does not establish a row-level relationship between the tables.",
            "test_sql": "SELECT COUNT(*) FROM datacenterdevice t1 JOIN physicaldevice t2 ON t1.finalclass = t2.finalclass LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 20,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "datacenterdevice",
            "from_column": "managementip",
            "to_table": "virtualmachine",
            "to_column": "managementip",
            "condition": "datacenterdevice.managementip = virtualmachine.managementip",
            "confidence": "high",
            "reasoning": "Both tables have a 'managementip' field of the same data type (varchar(255)), which could theoretically be used to link a physical device to a virtual machine if the management IPs are shared or mapped. However, in most data center designs, a physical device and a virtual machine would have distinct management IPs. There is no explicit foreign key or naming convention indicating a direct relationship. This is a weak, statistical or logical relationship at best.",
            "test_sql": "SELECT COUNT(*) FROM datacenterdevice t1 JOIN virtualmachine t2 ON t1.managementip = t2.managementip LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 20,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "dbserver",
            "from_column": "id",
            "to_table": "priv_changeop",
            "to_column": "objkey",
            "condition": "dbserver.id = priv_changeop.objkey",
            "confidence": "high",
            "reasoning": "The only possible field-level relationship is between dbserver.id and priv_changeop.objkey, as both are integers and objkey is designed to reference the primary key of various objects. However, there is no explicit indication that objclass in priv_changeop ever refers to 'dbserver' records, nor is there a naming convention or foreign key constraint to confirm this. This is a common polymorphic pattern, but without more context, the relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM dbserver t1 JOIN priv_changeop t2 ON t1.id = t2.objkey LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 21,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "farm",
            "from_column": "id",
            "to_table": "priv_changeop_create",
            "to_column": "id",
            "condition": "farm.id = priv_changeop_create.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of type int and both are primary keys, but there is no explicit foreign key or business logic linking a farm entity to a change operation privilege/event. The identical field name and type allow for a possible join, but without further context or supporting fields, this is likely coincidental and not a meaningful relationship.",
            "test_sql": "SELECT COUNT(*) FROM farm t1 JOIN priv_changeop_create t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "functionalci",
            "from_column": "name",
            "to_table": "software",
            "to_column": "name",
            "condition": "functionalci.name = software.name",
            "confidence": "high",
            "reasoning": "Both tables have a 'name' field of the same type (varchar), but there is no explicit foreign key or business logic in the schema tying a functional configuration item directly to a software record by name. While it is possible that some functional CIs represent software and thus may share names with software entries, this is not guaranteed and could lead to false matches. This relationship is speculative and would need data validation.",
            "test_sql": "SELECT COUNT(*) FROM functionalci t1 JOIN software t2 ON t1.name = t2.name LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "networkdevice",
            "from_column": "id",
            "to_table": "physicaldevice",
            "to_column": "id",
            "condition": "networkdevice.id = physicaldevice.id",
            "confidence": "high",
            "reasoning": "Both tables use an 'id' field as their primary key, but there is no evidence that these IDs are related or synchronized across tables. The 'id' fields are likely independent auto-incrementing primary keys for each table. No business logic or naming convention suggests a direct relationship.",
            "test_sql": "SELECT COUNT(*) FROM networkdevice t1 JOIN physicaldevice t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "networkdevice",
            "from_column": "ram",
            "to_table": "server",
            "to_column": "ram",
            "condition": "networkdevice.ram = server.ram",
            "confidence": "high",
            "reasoning": "Both tables have a 'ram' field (varchar), but this is a hardware specification and not a unique or identifying attribute. While a join is technically possible, it is unlikely to be meaningful for business logic or foreign key relationships. It could be used for statistical or reporting purposes (e.g., finding devices and servers with the same RAM size), but not for entity relationships.",
            "test_sql": "SELECT COUNT(*) FROM networkdevice t1 JOIN server t2 ON t1.ram = t2.ram LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "physicaldevice",
            "from_column": "id",
            "to_table": "server",
            "to_column": "id",
            "condition": "physicaldevice.id = server.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column as their primary key, but there is no explicit foreign key or naming convention indicating a relationship. The 'id' fields are likely independent auto-incremented primary keys. However, in some database designs, a 'server' could be a specialized type of 'physicaldevice' and share the same id, but there is no evidence of this in the provided schemas.",
            "test_sql": "SELECT COUNT(*) FROM physicaldevice t1 JOIN server t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 4,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_action",
            "from_column": "id",
            "to_table": "priv_changeop_create",
            "to_column": "id",
            "condition": "priv_action.id = priv_changeop_create.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of type int, but there is no explicit foreign key or naming convention indicating a direct relationship. The business purposes are related to permissions and actions, but without additional context or supporting fields, any relationship is speculative. The only possible join is on the 'id' field due to data type compatibility, but this is a weak inference.",
            "test_sql": "SELECT COUNT(*) FROM priv_action t1 JOIN priv_changeop_create t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_action_email",
            "from_column": "id",
            "to_table": "priv_changeop_create",
            "to_column": "id",
            "condition": "priv_action_email.id = priv_changeop_create.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of type int and primary key, but there is no explicit foreign key or business logic linking them. The naming conventions and business purposes do not indicate a direct relationship. The only possible join is on the 'id' field due to data type compatibility, but this is likely coincidental and not meaningful.",
            "test_sql": "SELECT COUNT(*) FROM priv_action_email t1 JOIN priv_changeop_create t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_action_notification",
            "from_column": "id",
            "to_table": "priv_changeop_create",
            "to_column": "id",
            "condition": "priv_action_notification.id = priv_changeop_create.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of type int and both are primary keys, but there is no explicit foreign key or business logic linking them. The naming conventions and business purposes do not indicate a direct relationship. The only possible join is on the 'id' fields due to data type compatibility, but this is likely coincidental and not meaningful.",
            "test_sql": "SELECT COUNT(*) FROM priv_action_notification t1 JOIN priv_changeop_create t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_change",
            "from_column": "id",
            "to_table": "priv_changeop_create",
            "to_column": "id",
            "condition": "priv_change.id = priv_changeop_create.id",
            "confidence": "high",
            "reasoning": "The only possible join is on the 'id' field, which is the primary key in both tables. However, there is no explicit foreign key, and the business purposes do not clearly indicate that these IDs are related. The naming conventions suggest both tables are related to privilege changes, but there is no direct evidence that the 'id' in priv_changeop_create references the 'id' in priv_change. This join is speculative and based solely on matching primary key names and types.",
            "test_sql": "SELECT COUNT(*) FROM priv_change t1 JOIN priv_changeop_create t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "id",
            "to_table": "priv_changeop_links_tune",
            "to_column": "id",
            "condition": "priv_changeop.id = priv_changeop_links_tune.id",
            "confidence": "high",
            "reasoning": "Both tables have a primary key column named 'id' of type int, but there is no explicit foreign key or business logic indicating that these IDs are related. The matching names and types could suggest a possible relationship, but this is a common pattern and may be coincidental. Without further context, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN priv_changeop_links_tune t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "id",
            "to_table": "priv_changeop_create",
            "to_column": "id",
            "condition": "priv_changeop.id = priv_changeop_create.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of type int and primary key, but there is no explicit foreign key or business logic linking them. The naming does not strongly suggest a direct relationship, and 'id' is a common field name. However, if 'priv_changeop_create' is intended to mark or flag certain 'priv_changeop' records (e.g., those representing creation operations), a one-to-one or sparse one-to-one relationship could exist. This is speculative and not strongly supported by the schema alone.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN priv_changeop_create t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 232,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "optype",
            "to_table": "priv_changeop_links",
            "to_column": "optype",
            "condition": "priv_changeop.optype = priv_changeop_links.optype",
            "confidence": "high",
            "reasoning": "Both tables have an 'optype' field, but the default values and likely semantics differ (e.g., 'CMDBChangeOp' vs. 'CMDBChangeOpSetAttributeLinks'). While a join on this field is technically possible, it is unlikely to yield meaningful relationships except in specific cases where operation types are intentionally aligned. This join may be useful for statistical or reporting purposes but is not a strong business logic relationship.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN priv_changeop_links t2 ON t1.optype = t2.optype LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 12770,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "objclass",
            "to_table": "priv_trigger",
            "to_column": "realclass",
            "condition": "priv_changeop.objclass = priv_trigger.realclass",
            "confidence": "high",
            "reasoning": "Both 'objclass' in priv_changeop and 'realclass' in priv_trigger are varchar(255) fields that appear to represent the class/type of an object or trigger. While their naming conventions are similar and both relate to object classification, there is no explicit foreign key or strong business logic directly connecting these fields. The relationship is speculative and based on possible shared domain concepts (object class/type), but there is no guarantee that the values will overlap or that a join would yield meaningful results.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN priv_trigger t2 ON t1.objclass = t2.realclass LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 8,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop",
            "from_column": "objkey",
            "to_table": "webserver",
            "to_column": "id",
            "condition": "priv_changeop.objkey = webserver.id",
            "confidence": "high",
            "reasoning": "The only possible field-level match is between priv_changeop.objkey (int) and webserver.id (int). However, there is no explicit indication that objkey refers to a webserver; objkey is a generic reference, and its meaning depends on objclass. Without a value in objclass indicating 'webserver', this relationship is speculative. There are no naming conventions or schema hints directly linking these tables.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop t1 JOIN webserver t2 ON t1.objkey = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 18,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_changeop_setatt",
            "from_column": "id",
            "to_table": "priv_changeop_setatt_scalar",
            "to_column": "id",
            "condition": "priv_changeop_setatt.id = priv_changeop_setatt_scalar.id",
            "confidence": "high",
            "reasoning": "Both tables have a primary key column named 'id' of type int, but there is no explicit foreign key or naming convention indicating a direct relationship. The business purposes suggest that priv_changeop_setatt defines attribute change operations, while priv_changeop_setatt_scalar logs old/new values for changes. It is possible, though not certain, that priv_changeop_setatt_scalar records detail the changes for operations defined in priv_changeop_setatt, using a shared 'id'. However, without explicit foreign keys or additional context, this relationship is speculative.",
            "test_sql": "SELECT COUNT(*) FROM priv_changeop_setatt t1 JOIN priv_changeop_setatt_scalar t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_extension_install",
            "from_column": "code",
            "to_table": "priv_module_install",
            "to_column": "name",
            "condition": "priv_extension_install.code = priv_module_install.name",
            "confidence": "high",
            "reasoning": "Both 'code' (in priv_extension_install) and 'name' (in priv_module_install) are varchar fields that could represent the identifier of an extension or module. If the business logic treats 'extension' and 'module' as related or overlapping concepts, there may be cases where an extension's code matches a module's name. However, there is no explicit foreign key or naming convention to guarantee this relationship, and the business purposes suggest they may track different entities.",
            "test_sql": "SELECT COUNT(*) FROM priv_extension_install t1 JOIN priv_module_install t2 ON t1.code = t2.name LIMIT 1",
            "relationship_type": "business_logic",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_internaluser",
            "from_column": "id",
            "to_table": "priv_user",
            "to_column": "id",
            "condition": "priv_internaluser.id = priv_user.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' field of type int and both are primary keys. However, there is no explicit foreign key or naming convention indicating that these IDs are related. In some database designs, a user table and an internal user table may share a common ID if one extends the other (single-table inheritance or table-per-type), but there is no direct evidence of this here. The presence of a 'finalclass' field in both tables suggests possible inheritance or polymorphism, but without further context, this is speculative.",
            "test_sql": "SELECT COUNT(*) FROM priv_internaluser t1 JOIN priv_user t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "logical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_internaluser",
            "from_column": "finalclass",
            "to_table": "priv_user",
            "to_column": "finalclass",
            "condition": "priv_internaluser.finalclass = priv_user.finalclass",
            "confidence": "high",
            "reasoning": "Both tables have a 'finalclass' field, which may be used for class/type discrimination in an inheritance hierarchy. However, this is not a typical foreign key relationship, and matching on this field would only make sense for statistical or reporting purposes, not for joining individual records.",
            "test_sql": "SELECT COUNT(*) FROM priv_internaluser t1 JOIN priv_user t2 ON t1.finalclass = t2.finalclass LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_module_install",
            "from_column": "name",
            "to_table": "typology",
            "to_column": "name",
            "condition": "priv_module_install.name = typology.name",
            "confidence": "high",
            "reasoning": "Both tables have a 'name' field of the same data type (varchar(255)), but there is no explicit indication that the 'name' in 'priv_module_install' refers to a typology. The business purposes are different: one tracks module installations, the other stores typologies/classifications. The overlap in field names is likely coincidental, and there is no evidence of a foreign key or business logic relationship. However, a statistical or logical relationship could exist if, in practice, module names are also typologies.",
            "test_sql": "SELECT COUNT(*) FROM priv_module_install t1 JOIN typology t2 ON t1.name = t2.name LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 1,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "priv_trigger",
            "from_column": "id",
            "to_table": "priv_trigger_onobjmention",
            "to_column": "id",
            "condition": "priv_trigger.id = priv_trigger_onobjmention.id",
            "confidence": "high",
            "reasoning": "Both tables have an 'id' column of type int and both are primary keys, but there is no explicit foreign key or naming convention indicating a direct relationship. The business purposes are related to triggers, but the schemas do not provide evidence that the 'id' values are meant to align. This could be a coincidence due to auto-incrementing primary keys, and joining on these fields is not supported by any clear business logic or design pattern.",
            "test_sql": "SELECT COUNT(*) FROM priv_trigger t1 JOIN priv_trigger_onobjmention t2 ON t1.id = t2.id LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 2,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "server",
            "from_column": "cpu",
            "to_table": "virtualmachine",
            "to_column": "cpu",
            "condition": "server.cpu = virtualmachine.cpu",
            "confidence": "high",
            "reasoning": "Both tables have a 'cpu' field, but this is a free-text or descriptive field and may not be standardized. A join on this field could be used for statistical or reporting purposes, but is not a reliable foreign key or business logic relationship.",
            "test_sql": "SELECT COUNT(*) FROM server t1 JOIN virtualmachine t2 ON t1.cpu = t2.cpu LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        },
        {
            "type": "inferred",
            "from_table": "server",
            "from_column": "ram",
            "to_table": "virtualmachine",
            "to_column": "ram",
            "condition": "server.ram = virtualmachine.ram",
            "confidence": "high",
            "reasoning": "Both tables have a 'ram' field, but as with 'cpu', this is likely a descriptive field and may not be standardized. A join on this field could be used for statistical or reporting purposes, but is not a reliable foreign key or business logic relationship.",
            "test_sql": "SELECT COUNT(*) FROM server t1 JOIN virtualmachine t2 ON t1.ram = t2.ram LIMIT 1",
            "relationship_type": "statistical",
            "verified": true,
            "test_result": 16,
            "verification_method": "sql_test"
        }
    ]
}