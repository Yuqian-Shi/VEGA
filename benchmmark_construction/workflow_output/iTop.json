{
  "platform": "iTop",
  "core_tables": [
    "applicationsolution",
    "brand",
    "connectableci",
    "contact",
    "contacttype",
    "contract",
    "customercontract",
    "databaseschema",
    "datacenterdevice",
    "dbserver",
    "deliverymodel",
    "farm",
    "functionalci",
    "hypervisor",
    "lnkapplicationsolutiontofunctionalci",
    "lnkcustomercontracttoservice",
    "lnkdeliverymodeltocontact",
    "lnkpersontoteam",
    "lnkslatoslt",
    "location",
    "model",
    "networkdevice",
    "networkdevicetype",
    "organization",
    "osfamily",
    "osversion",
    "person",
    "physicaldevice",
    "priv_action",
    "priv_action_email",
    "priv_action_notification",
    "priv_app_preferences",
    "priv_change",
    "priv_changeop",
    "priv_changeop_create",
    "priv_changeop_links",
    "priv_changeop_links_addremove",
    "priv_changeop_links_tune",
    "priv_changeop_setatt",
    "priv_changeop_setatt_scalar",
    "priv_db_properties",
    "priv_extension_install",
    "priv_internaluser",
    "priv_link_action_trigger",
    "priv_module_install",
    "priv_query",
    "priv_query_oql",
    "priv_tagfielddata",
    "priv_trigger",
    "priv_trigger_onobject",
    "priv_trigger_onobjmention",
    "priv_urp_profiles",
    "priv_urp_userprofile",
    "priv_user",
    "priv_user_local",
    "rack",
    "remoteapplicationtype",
    "server",
    "service",
    "servicefamily",
    "servicesubcategory",
    "sla",
    "slt",
    "software",
    "softwareinstance",
    "team",
    "typology",
    "virtualdevice",
    "virtualhost",
    "virtualmachine",
    "webapplication",
    "webserver"
  ],
  "discovered_workflows": {
    "service_catalog_and_sla_management": {
      "name": "Service Catalog and SLA Management",
      "description": "Manages the full lifecycle of services offered by the organization, including their classification, subcategorization, and the definition and enforcement of Service Level Agreements (SLAs) and Service Level Targets (SLTs). This workflow ensures that all services are properly cataloged, categorized, and governed by measurable performance targets.",
      "core_tables": [
        "service",
        "servicefamily",
        "servicesubcategory",
        "sla",
        "slt",
        "lnkslatoslt"
      ],
      "key_relationships": [
        {
          "type": "inferred",
          "from_table": "service",
          "from_column": "servicefamily_id",
          "to_table": "servicefamily",
          "to_column": "id",
          "condition": "service.servicefamily_id = servicefamily.id",
          "confidence": "high",
          "reasoning": "The 'service' table contains a 'servicefamily_id' column, which by naming convention and data type (int) matches the primary key 'id' of the 'servicefamily' table. The business purpose of both tables supports a one-to-many relationship: each service belongs to a single service family, and each service family can have multiple services. This is a common database design pattern for categorizing or grouping records.",
          "test_sql": "SELECT COUNT(*) FROM service t1 JOIN servicefamily t2 ON t1.servicefamily_id = t2.id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 3,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "service",
          "from_column": "id",
          "to_table": "servicesubcategory",
          "to_column": "service_id",
          "condition": "service.id = servicesubcategory.service_id",
          "confidence": "high",
          "reasoning": "The 'servicesubcategory' table contains a 'service_id' column of type int, which matches the primary key 'id' of the 'service' table. The business purpose and naming convention indicate that each subcategory is associated with a parent service, forming a classic one-to-many (service to servicesubcategory) relationship. This is a common database design pattern for categorizing sub-entities under a parent entity.",
          "test_sql": "SELECT COUNT(*) FROM service t1 JOIN servicesubcategory t2 ON t1.id = t2.service_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 17,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "lnkslatoslt",
          "from_column": "sla_id",
          "to_table": "sla",
          "to_column": "id",
          "condition": "lnkslatoslt.sla_id = sla.id",
          "confidence": "high",
          "reasoning": "The field 'sla_id' in 'lnkslatoslt' matches the primary key 'id' in 'sla' by both naming convention and data type (int). The business purpose of 'lnkslatoslt' is to link SLAs to another entity, and this is a standard join table pattern. This relationship is likely intended to associate each record in 'lnkslatoslt' with a specific SLA.",
          "test_sql": "SELECT COUNT(*) FROM lnkslatoslt t1 JOIN sla t2 ON t1.sla_id = t2.id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 2,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "lnkslatoslt",
          "from_column": "slt_id",
          "to_table": "slt",
          "to_column": "id",
          "condition": "lnkslatoslt.slt_id = slt.id",
          "confidence": "high",
          "reasoning": "The 'lnkslatoslt' table is a linking table, and the 'slt_id' column is an integer that matches the primary key 'id' in the 'slt' table. This is a common database pattern for establishing a many-to-many relationship. The business purpose of 'lnkslatoslt' is to associate SLAs with SLTs, and the only way to reference an SLT is via its 'id'.",
          "test_sql": "SELECT COUNT(*) FROM lnkslatoslt t1 JOIN slt t2 ON t1.slt_id = t2.id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 2,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "servicesubcategory",
          "from_column": "request_type",
          "to_table": "slt",
          "to_column": "request_type",
          "condition": "servicesubcategory.request_type = slt.request_type",
          "confidence": "high",
          "reasoning": "Both tables have a 'request_type' field with identical ENUM values ('incident', 'service_request'). This suggests that service subcategories and SLTs are both classified by the type of request, and it is likely that business logic would require joining these tables to determine which SLTs apply to which subcategories based on request type. However, this is not a strict foreign key relationship, as there is no unique constraint or explicit reference.",
          "test_sql": "SELECT COUNT(*) FROM servicesubcategory t1 JOIN slt t2 ON t1.request_type = t2.request_type LIMIT 1",
          "relationship_type": "business_logic",
          "verified": true,
          "test_result": 10,
          "verification_method": "sql_test"
        }
      ],
      "business_value": "Enables IT operations to define, manage, and monitor the organization's service offerings and their associated performance targets, ensuring service quality and compliance with contractual obligations.",
      "workflow_type": "service_catalog_management"
    },
    "customer_contract_and_service_delivery_management": {
      "name": "Customer Contract and Service Delivery Management",
      "description": "Handles the assignment of services to customer contracts, including the management of associated SLAs and the mapping of service subcategories and SLTs. This workflow ensures that each customer contract is linked to the correct services and governed by the appropriate service level agreements and targets.",
      "core_tables": [
        "customercontract",
        "lnkcustomercontracttoservice",
        "service",
        "sla",
        "slt",
        "lnkslatoslt",
        "servicesubcategory"
      ],
      "key_relationships": [
        {
          "type": "inferred",
          "from_table": "customercontract",
          "from_column": "id",
          "to_table": "lnkcustomercontracttoservice",
          "to_column": "customercontract_id",
          "condition": "customercontract.id = lnkcustomercontracttoservice.customercontract_id",
          "confidence": "high",
          "reasoning": "The field 'customercontract_id' in 'lnkcustomercontracttoservice' matches the primary key 'id' in 'customercontract' by naming convention and data type (both int). The business purpose of 'lnkcustomercontracttoservice' is to link contracts to services, so it is logical that each record references a contract via this field. This is a standard foreign key pattern, even though the foreign key is not explicitly defined in the schema.",
          "test_sql": "SELECT COUNT(*) FROM customercontract t1 JOIN lnkcustomercontracttoservice t2 ON t1.id = t2.customercontract_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 3,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "lnkcustomercontracttoservice",
          "from_column": "service_id",
          "to_table": "service",
          "to_column": "id",
          "condition": "lnkcustomercontracttoservice.service_id = service.id",
          "confidence": "high",
          "reasoning": "The field 'service_id' in 'lnkcustomercontracttoservice' matches the primary key 'id' in 'service' by both naming convention and data type (int). The business purpose of 'lnkcustomercontracttoservice' is to link customer contracts to specific services, which are catalogued in the 'service' table. This is a classic foreign key relationship, even though it is not explicitly defined in the schema.",
          "test_sql": "SELECT COUNT(*) FROM lnkcustomercontracttoservice t1 JOIN service t2 ON t1.service_id = t2.id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 3,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "lnkcustomercontracttoservice",
          "from_column": "sla_id",
          "to_table": "sla",
          "to_column": "id",
          "condition": "lnkcustomercontracttoservice.sla_id = sla.id",
          "confidence": "high",
          "reasoning": "The field 'sla_id' in 'lnkcustomercontracttoservice' matches the primary key 'id' in 'sla', both are of type int, and the business logic indicates that each service linked to a customer contract can be associated with a specific SLA. This is a common foreign key pattern, even though the foreign key is not explicitly defined in the schema.",
          "test_sql": "SELECT COUNT(*) FROM lnkcustomercontracttoservice t1 JOIN sla t2 ON t1.sla_id = t2.id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 3,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "lnkcustomercontracttoservice",
          "from_column": "sla_id",
          "to_table": "lnkslatoslt",
          "to_column": "sla_id",
          "condition": "lnkcustomercontracttoservice.sla_id = lnkslatoslt.sla_id",
          "confidence": "high",
          "reasoning": "Both tables contain a column named 'sla_id' of the same data type (int), and both schemas and business purposes reference 'SLA' as a key entity. In lnkcustomercontracttoservice, 'sla_id' links a contract-service association to an SLA, while in lnkslatoslt, 'sla_id' links to SLT records. This suggests a logical relationship where you may want to find all SLT records associated with the SLA assigned to a contract-service pair.",
          "test_sql": "SELECT COUNT(*) FROM lnkcustomercontracttoservice t1 JOIN lnkslatoslt t2 ON t1.sla_id = t2.sla_id LIMIT 1",
          "relationship_type": "business_logic",
          "verified": true,
          "test_result": 6,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "lnkslatoslt",
          "from_column": "sla_id",
          "to_table": "sla",
          "to_column": "id",
          "condition": "lnkslatoslt.sla_id = sla.id",
          "confidence": "high",
          "reasoning": "The field 'sla_id' in 'lnkslatoslt' matches the primary key 'id' in 'sla' by both naming convention and data type (int). The business purpose of 'lnkslatoslt' is to link SLAs to another entity, and this is a standard join table pattern. This relationship is likely intended to associate each record in 'lnkslatoslt' with a specific SLA.",
          "test_sql": "SELECT COUNT(*) FROM lnkslatoslt t1 JOIN sla t2 ON t1.sla_id = t2.id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 2,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "lnkslatoslt",
          "from_column": "slt_id",
          "to_table": "slt",
          "to_column": "id",
          "condition": "lnkslatoslt.slt_id = slt.id",
          "confidence": "high",
          "reasoning": "The 'lnkslatoslt' table is a linking table, and the 'slt_id' column is an integer that matches the primary key 'id' in the 'slt' table. This is a common database pattern for establishing a many-to-many relationship. The business purpose of 'lnkslatoslt' is to associate SLAs with SLTs, and the only way to reference an SLT is via its 'id'.",
          "test_sql": "SELECT COUNT(*) FROM lnkslatoslt t1 JOIN slt t2 ON t1.slt_id = t2.id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 2,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "lnkcustomercontracttoservice",
          "from_column": "service_id",
          "to_table": "servicesubcategory",
          "to_column": "service_id",
          "condition": "lnkcustomercontracttoservice.service_id = servicesubcategory.service_id",
          "confidence": "high",
          "reasoning": "Both tables contain a 'service_id' field of type int, which likely refers to the same conceptual 'service'. In 'lnkcustomercontracttoservice', 'service_id' links a contract to a service, while in 'servicesubcategory', 'service_id' associates a subcategory with its parent service. This suggests a logical relationship where you can find all subcategories for services linked to a contract, or vice versa. However, since there is no direct foreign key or unique constraint, and the relationship is not explicitly defined, the confidence is medium.",
          "test_sql": "SELECT COUNT(*) FROM lnkcustomercontracttoservice t1 JOIN servicesubcategory t2 ON t1.service_id = t2.service_id LIMIT 1",
          "relationship_type": "business_logic",
          "verified": true,
          "test_result": 17,
          "verification_method": "sql_test"
        }
      ],
      "business_value": "Ensures that customer contracts are accurately linked to the services provided, with clear SLA and SLT governance, supporting compliance, customer satisfaction, and efficient service delivery.",
      "workflow_type": "contract_service_management"
    },
    "configuration_item_and_application_solution_mapping": {
      "name": "Configuration Item and Application Solution Mapping",
      "description": "Tracks the relationships between application solutions and the underlying functional configuration items (CIs) that support them. This workflow enables impact analysis, dependency mapping, and change management for business applications and their technical components.",
      "core_tables": [
        "applicationsolution",
        "functionalci",
        "lnkapplicationsolutiontofunctionalci"
      ],
      "key_relationships": [
        {
          "type": "inferred",
          "from_table": "applicationsolution",
          "from_column": "id",
          "to_table": "lnkapplicationsolutiontofunctionalci",
          "to_column": "applicationsolution_id",
          "condition": "applicationsolution.id = lnkapplicationsolutiontofunctionalci.applicationsolution_id",
          "confidence": "high",
          "reasoning": "The field 'applicationsolution_id' in 'lnkapplicationsolutiontofunctionalci' is clearly named to reference the 'id' field in 'applicationsolution'. This follows standard database design patterns for many-to-many relationships, where a junction table (lnkapplicationsolutiontofunctionalci) links records from a parent table (applicationsolution) via a foreign key. The data types (both int) are compatible, and the business logic aligns with mapping application solutions to other entities.",
          "test_sql": "SELECT COUNT(*) FROM applicationsolution t1 JOIN lnkapplicationsolutiontofunctionalci t2 ON t1.id = t2.applicationsolution_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 8,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "functionalci",
          "from_column": "id",
          "to_table": "lnkapplicationsolutiontofunctionalci",
          "to_column": "functionalci_id",
          "condition": "functionalci.id = lnkapplicationsolutiontofunctionalci.functionalci_id",
          "confidence": "high",
          "reasoning": "The 'lnkapplicationsolutiontofunctionalci' table is a classic junction/bridge table designed to map application solutions to functional configuration items. The field 'functionalci_id' in the link table is clearly intended to reference the primary key 'id' of the 'functionalci' table. This is a standard many-to-many relationship pattern in relational database design.",
          "test_sql": "SELECT COUNT(*) FROM functionalci t1 JOIN lnkapplicationsolutiontofunctionalci t2 ON t1.id = t2.functionalci_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 8,
          "verification_method": "sql_test"
        }
      ],
      "business_value": "Provides a clear mapping between business applications and their supporting infrastructure, enabling effective change impact analysis, risk management, and compliance reporting.",
      "workflow_type": "cmdb_dependency_mapping"
    },
    "asset_inventory_and_physical_device_lifecycle_management": {
      "name": "Asset Inventory and Physical Device Lifecycle Management",
      "description": "Manages the inventory, classification, and lifecycle of physical devices, including their association with brands, models, and locations. This workflow supports asset tracking, warranty management, and device allocation across the organization.",
      "core_tables": [
        "physicaldevice",
        "brand",
        "model",
        "location"
      ],
      "key_relationships": [
        {
          "type": "inferred",
          "from_table": "brand",
          "from_column": "id",
          "to_table": "model",
          "to_column": "brand_id",
          "condition": "brand.id = model.brand_id",
          "confidence": "high",
          "reasoning": "The 'model' table contains a 'brand_id' column of type int, which matches the primary key 'id' in the 'brand' table. The naming convention and data types strongly suggest that 'brand_id' is intended to reference 'brand.id', establishing a one-to-many relationship where each model belongs to a single brand. This is a common database design pattern for associating models with their respective brands.",
          "test_sql": "SELECT COUNT(*) FROM brand t1 JOIN model t2 ON t1.id = t2.brand_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 3,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "brand",
          "from_column": "id",
          "to_table": "physicaldevice",
          "to_column": "brand_id",
          "condition": "brand.id = physicaldevice.brand_id",
          "confidence": "high",
          "reasoning": "The 'physicaldevice' table contains a 'brand_id' column of type int, which matches the primary key 'id' in the 'brand' table. The naming convention and data type compatibility strongly suggest that 'brand_id' in 'physicaldevice' is intended to reference 'id' in 'brand', establishing a many-to-one relationship where each physical device is associated with a single brand. This is a common database design pattern for associating assets with their manufacturer or brand.",
          "test_sql": "SELECT COUNT(*) FROM brand t1 JOIN physicaldevice t2 ON t1.id = t2.brand_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 5,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "model",
          "from_column": "id",
          "to_table": "physicaldevice",
          "to_column": "model_id",
          "condition": "model.id = physicaldevice.model_id",
          "confidence": "high",
          "reasoning": "The 'physicaldevice' table has a 'model_id' column that matches the primary key 'id' of the 'model' table. This is a classic foreign key pattern where each physical device instance references the model it is based on. The data types are compatible (both int), and the business logic aligns: each device is of a specific model.",
          "test_sql": "SELECT COUNT(*) FROM model t1 JOIN physicaldevice t2 ON t1.id = t2.model_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 4,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "location",
          "from_column": "id",
          "to_table": "physicaldevice",
          "to_column": "location_id",
          "condition": "location.id = physicaldevice.location_id",
          "confidence": "high",
          "reasoning": "The 'physicaldevice' table contains a 'location_id' field of type int, which matches the primary key 'id' in the 'location' table. The naming convention and business logic both strongly suggest that each physical device is assigned to a specific location, and this is a common foreign key pattern in asset management systems.",
          "test_sql": "SELECT COUNT(*) FROM location t1 JOIN physicaldevice t2 ON t1.id = t2.location_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 5,
          "verification_method": "sql_test"
        }
      ],
      "business_value": "Enables accurate tracking of physical assets, supports warranty and lifecycle management, and ensures devices are properly allocated and maintained across all organizational locations.",
      "workflow_type": "asset_management"
    },
    "contact_and_organization_relationship_management": {
      "name": "Contact and Organization Relationship Management",
      "description": "Manages the association of contacts with organizations, including their roles in delivery models and teams. This workflow supports communication, notification, and organizational structuring for ITSM processes.",
      "core_tables": [
        "contact",
        "organization",
        "lnkdeliverymodeltocontact",
        "deliverymodel",
        "lnkpersontoteam",
        "team"
      ],
      "key_relationships": [
        {
          "type": "inferred",
          "from_table": "contact",
          "from_column": "org_id",
          "to_table": "organization",
          "to_column": "id",
          "condition": "contact.org_id = organization.id",
          "confidence": "high",
          "reasoning": "The 'org_id' field in the 'contact' table is an integer and is named in a way that strongly suggests it references the 'id' field of the 'organization' table. This is a common pattern in database design for establishing a many-to-one relationship, where multiple contacts can be associated with a single organization. The business purposes of both tables also align: contacts are likely to belong to organizations.",
          "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN organization t2 ON t1.org_id = t2.id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 37,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "contact",
          "from_column": "id",
          "to_table": "lnkdeliverymodeltocontact",
          "to_column": "contact_id",
          "condition": "contact.id = lnkdeliverymodeltocontact.contact_id",
          "confidence": "high",
          "reasoning": "The 'lnkdeliverymodeltocontact' table contains a 'contact_id' field, which by naming convention and data type (int) matches the primary key 'id' in the 'contact' table. This is a classic pattern for a many-to-many relationship link table, where 'contact_id' references the 'contact' table. The business purpose of associating contacts with delivery models further supports this relationship.",
          "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN lnkdeliverymodeltocontact t2 ON t1.id = t2.contact_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 3,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "deliverymodel",
          "from_column": "id",
          "to_table": "lnkdeliverymodeltocontact",
          "to_column": "deliverymodel_id",
          "condition": "deliverymodel.id = lnkdeliverymodeltocontact.deliverymodel_id",
          "confidence": "high",
          "reasoning": "The field 'deliverymodel_id' in 'lnkdeliverymodeltocontact' matches the primary key 'id' in 'deliverymodel' by both naming convention and data type (int). The business purpose of 'lnkdeliverymodeltocontact' is to link contacts to delivery models, which strongly suggests that 'deliverymodel_id' is a reference to 'deliverymodel.id'. This is a standard many-to-many linking pattern.",
          "test_sql": "SELECT COUNT(*) FROM deliverymodel t1 JOIN lnkdeliverymodeltocontact t2 ON t1.id = t2.deliverymodel_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 3,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "contact",
          "from_column": "id",
          "to_table": "lnkpersontoteam",
          "to_column": "person_id",
          "condition": "contact.id = lnkpersontoteam.person_id",
          "confidence": "high",
          "reasoning": "The 'lnkpersontoteam' table is designed to link persons to teams, and the field 'person_id' is likely intended to reference a unique identifier for a person. In the provided schemas, the 'contact' table represents individual people and has a primary key 'id'. The data types (both int) and business logic (contacts as persons) strongly suggest that 'lnkpersontoteam.person_id' refers to 'contact.id'. This is a common database pattern for many-to-many relationships between people and teams.",
          "test_sql": "SELECT COUNT(*) FROM contact t1 JOIN lnkpersontoteam t2 ON t1.id = t2.person_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 9,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "lnkpersontoteam",
          "from_column": "team_id",
          "to_table": "team",
          "to_column": "id",
          "condition": "lnkpersontoteam.team_id = team.id",
          "confidence": "high",
          "reasoning": "The 'team_id' field in 'lnkpersontoteam' matches the primary key 'id' in 'team' by both naming convention and data type (int). The business purpose of 'lnkpersontoteam' is to link persons to teams, so it is logical that 'team_id' references 'team.id'. This is a standard foreign key pattern, even though the foreign key is not explicitly defined in the schema.",
          "test_sql": "SELECT COUNT(*) FROM lnkpersontoteam t1 JOIN team t2 ON t1.team_id = t2.id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 9,
          "verification_method": "sql_test"
        }
      ],
      "business_value": "Facilitates effective communication, role assignment, and organizational structuring, supporting ITSM processes such as incident escalation, change approval, and service delivery.",
      "workflow_type": "contact_management"
    },
    "software_asset_and_instance_management": {
      "name": "Software Asset and Instance Management",
      "description": "Tracks software products and their individual deployments (instances) across the organization's configuration items, supporting license compliance, deployment tracking, and software lifecycle management.",
      "core_tables": [
        "software",
        "softwareinstance",
        "functionalci"
      ],
      "key_relationships": [
        {
          "type": "inferred",
          "from_table": "software",
          "from_column": "id",
          "to_table": "softwareinstance",
          "to_column": "software_id",
          "condition": "software.id = softwareinstance.software_id",
          "confidence": "high",
          "reasoning": "The 'softwareinstance' table contains a 'software_id' column of type int, which matches the primary key 'id' in the 'software' table. The business purpose of 'softwareinstance' is to represent individual deployments of software, and it logically references the software definition in the 'software' table. This is a classic foreign key relationship, even though it is not explicitly defined in the schema.",
          "test_sql": "SELECT COUNT(*) FROM software t1 JOIN softwareinstance t2 ON t1.id = t2.software_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 3,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "functionalci",
          "from_column": "id",
          "to_table": "softwareinstance",
          "to_column": "functionalci_id",
          "condition": "functionalci.id = softwareinstance.functionalci_id",
          "confidence": "high",
          "reasoning": "The 'softwareinstance' table contains a column named 'functionalci_id' of type int, which matches the primary key 'id' in the 'functionalci' table. The naming convention and data types strongly suggest that each software instance is associated with a specific functional configuration item, likely representing the asset or environment where the software is installed. This is a common foreign key pattern in configuration management and asset tracking systems.",
          "test_sql": "SELECT COUNT(*) FROM functionalci t1 JOIN softwareinstance t2 ON t1.id = t2.functionalci_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 5,
          "verification_method": "sql_test"
        }
      ],
      "business_value": "Ensures accurate tracking of software assets, supports compliance with licensing agreements, and enables efficient management of software deployments across the IT environment.",
      "workflow_type": "software_asset_management"
    },
    "virtualization_infrastructure_management": {
      "name": "Virtualization Infrastructure Management",
      "description": "Manages the relationships between farms, hypervisors, and servers, supporting the provisioning and tracking of virtualization resources within the IT infrastructure.",
      "core_tables": [
        "farm",
        "hypervisor",
        "server"
      ],
      "key_relationships": [
        {
          "type": "inferred",
          "from_table": "farm",
          "from_column": "id",
          "to_table": "hypervisor",
          "to_column": "farm_id",
          "condition": "farm.id = hypervisor.farm_id",
          "confidence": "high",
          "reasoning": "The 'hypervisor' table contains a 'farm_id' column of type int, which matches the primary key 'id' in the 'farm' table. The naming convention and data type compatibility strongly suggest that 'farm_id' in 'hypervisor' is intended to reference 'id' in 'farm', establishing a many-to-one relationship where each hypervisor is associated with a single farm. This is a common database design pattern for representing parent-child relationships.",
          "test_sql": "SELECT COUNT(*) FROM farm t1 JOIN hypervisor t2 ON t1.id = t2.farm_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 3,
          "verification_method": "sql_test"
        },
        {
          "type": "inferred",
          "from_table": "hypervisor",
          "from_column": "server_id",
          "to_table": "server",
          "to_column": "id",
          "condition": "hypervisor.server_id = server.id",
          "confidence": "high",
          "reasoning": "The 'hypervisor' table contains a 'server_id' column of type int, which matches the primary key 'id' in the 'server' table. This strongly suggests that each hypervisor record is associated with a specific server, likely representing the physical or virtual machine hosting the hypervisor. This is a common pattern in infrastructure management databases, where a hypervisor is mapped to the server it runs on.",
          "test_sql": "SELECT COUNT(*) FROM hypervisor t1 JOIN server t2 ON t1.server_id = t2.id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 2,
          "verification_method": "sql_test"
        }
      ],
      "business_value": "Enables efficient management and monitoring of virtualization resources, supporting capacity planning, high availability, and rapid provisioning of virtualized environments.",
      "workflow_type": "virtualization_management"
    },
    "organizational_structure_and_delivery_model_management": {
      "name": "Organizational Structure and Delivery Model Management",
      "description": "Manages the hierarchical structure of the organization and its association with delivery models, supporting organizational reporting, process alignment, and delivery optimization.",
      "core_tables": [
        "organization",
        "deliverymodel"
      ],
      "key_relationships": [
        {
          "type": "inferred",
          "from_table": "deliverymodel",
          "from_column": "id",
          "to_table": "organization",
          "to_column": "deliverymodel_id",
          "condition": "deliverymodel.id = organization.deliverymodel_id",
          "confidence": "high",
          "reasoning": "The 'organization' table contains a 'deliverymodel_id' column, which matches the primary key 'id' of the 'deliverymodel' table. This is a common foreign key pattern, suggesting that each organization can be associated with a specific delivery model. The data types are compatible (both int), and the business logic supports organizations being linked to delivery models.",
          "test_sql": "SELECT COUNT(*) FROM deliverymodel t1 JOIN organization t2 ON t1.id = t2.deliverymodel_id LIMIT 1",
          "relationship_type": "foreign_key",
          "verified": true,
          "test_result": 1,
          "verification_method": "sql_test"
        }
      ],
      "business_value": "Supports clear organizational structuring and alignment of delivery models, enabling process optimization and effective resource allocation.",
      "workflow_type": "organization_management"
    }
  },
  "discovery_metadata": {
    "total_tables_analyzed": 72,
    "relationships_found": 181,
    "workflows_identified": 8,
    "table_analysis_count": 72,
    "config_used": {
      "discovery_type": "universal",
      "llm_model": "gpt-4.1",
      "max_relationships": 1000,
      "confidence_levels": {
        "high": 3,
        "medium": 2,
        "low": 1
      }
    }
  }
}